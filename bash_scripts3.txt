1. Tilde extension

$ cd
$ cd ~  	<= ~ (home)
$ echo ~-	<= prints out last location
$ cd ~-		<= go to last location

2. Brace extension
$ mkdir brace && cd brace
$ touch {apple,banana,cherry}
	$ ls
	apple  banana  cherry
$ touch file _{1..1000}
$ ls
	file_1     file_189  file_279  file_369  file_459  file_549  file_639  file_729  file_819  file_909

$ touch file_{01..1000}			<= adding 0 fixes the file issue
$ ls
	file_0001  file_0113  file_0225  file_0337  file_0449  file_0561  file_0673  file_0785  file_0897

$ echo {0..10..2}	
	0 2 4 6 8 10
$ echo {0..10..3}
	0 3 6 9
$ echo {a..z}
	a b c ... x y z
$ echo {A..Z}
	A B C ... X Y Z
$ echo {A..z}				<= Capital first
	A B C ... X Y Z [  ] ^ _ ` a b c ... x y z
$ echo {A..z..2}
A C E ... U W Y [ ] _ a c e ... u w y

$ touch {apple,banana,cherry}_{01..100}{a..z}
apple_001a  apple_038n  apple_076a   banana_013n  banana_051a  banana_088n  cherry_026a  cherry_063n

3. Pipe and Redirect
$ pwd  /home/apark/braces
$ mkdir ../pipes
$ ls ../
	braces pipes
$ touch {01..10}
$ chmod 000 *
$ cp -v * ../pipes
$ ls -l ../pipes
	----------. 1 apark apark 0 Jan 17 16:11 01
	----------. 1 apark apark 0 Jan 17 16:11 02
$ touch {01..100}
$ chmod 000 *09*
$ cp -v * ../pipe 1> ../success.txt 2> ../error.txt       	<= NO output because redirect
$ cp -v * ../pipe &> ../log.txt					      		<= & redirect both STDOUT & STDERR 
$ ls > /dev/null

4. grep, awk and cut
$ grep --color=auto apark /var/log/secure
$ export GREP_OPTIONS='--color=auto'
$ grep -i break-in auth.log | awk {'print $12'}
$ ping -c 1 example.com | grep 'bytes from' | cut -d = -f 4
	2.69 ms

5. Bash Version
$ bash -version
$ echo $BASH_VERSION
4.2.46(1)-release


6. Echo
$ echo no quote
$ echo 'single quote'
$ echo "double quote"

# same result
$ echo greeting, \(world\)!
$ echo 'greeting (world)!'
$ echo "greeting (world)!"
	greeting (world)!

7. Variables
a=hello
b="hello world"
c=16
	$echo $a $b $c
	hello hello world 16
Adding attributes to variables
declare -i d=123		<= d is an integer
declare -r e=456		<= e is read-only
declare -l f="LOLCats"	<= f is lolcats  #lower case
declare -u g="LOLCats"	<= f is LOLCATS  #Upper case

# Built-in variables(RESERVED)
$PWD
$HOME
$HOSTNAME
$MACHTYPE
$BASH_VERSION
$SECONDS

$ echo $0

8. Command substitution
pwd=$(pwd)						<= put the command in side parenthesis
echo $pwd

$ a=$(ping -c 1 example.com | grep 'bytes from' | cut -d = -f 4)
$ echo $a


9. Working with Numbers

# Arithmetic Operations	
	val=$(( expression ))
-----------------------------------------
	Operation				Operator
-----------------------------------------
	Exponentiation			(( $a ** $b ))
	Multiplication			(( $a * $b ))
	Division				(( $a / $b ))
	Modulo					(( $a % $b ))
	Addition				(( $a + $b ))
	Subtraction				(( $a - $b ))
-----------------------------------------
	
d=2
e=$((d+3))
echo $e
$((e++))
$ echo $e
	7
$((e--))
	6
((e+=5))
	11
((e-=3))
	8
((e*=3))
((e/=3))

# Bash only works with Integers, not decimals
$a=$(echo 1/3 |bc -l)						<= user BC An arbitrary precision calculator language
												-l, --mathlib
												Define the standard math library.
$ echo $a
.33333333333333333333



10. Comparison Operations (STRING)
	[[  expressions  ]]
	0: True    1: False
-----------------------------------------------
	Operation						Operator
-----------------------------------------------
	Less than					[[ $a < $b ]]
	Greater than				[[ $a > $b ]]
	Less than or equal to 		[[ $a <= $b ]]
	Greater than or equal to	[[ $a >= $b ]]
	Equal(single or double)		[[ $a == $b ]] or [[ $a = $b ]]
	Not Equal 					[[ $a != $b ]]
-----------------------------------------------	
# Equal
$ [[ cat == cat ]]  or	[[ cat = cat ]]  or [ cat = cat ] or [ cat=cat ]
$ [[ 'cat' == 'cat']]  or	[[ 'cat' = 'cat' ]] or [ 'cat' = 'cat' ] or [[ 'cat'='cat' ]] 
$ [[ "cat" == "cat" ]]
$ echo $? 
	0 <= true

$ [[ 20 > 100 ]]
$ echo $? 
	0 <= true because it compares STRINGS, not the number! 20 is higher than 100 lexcially.

# Comparison Operations (INTEGER)
-----------------------------------------------
	Operation						Operator
-----------------------------------------------
	Less than					[[ $a -lt $b ]]
	Greater than				[[ $a -gt $b ]]
	Less than or equal to 		[[ $a -le $b ]]
	Greater than or equal to	[[ $a -ge $b ]]
	Equal(single or double)		[[ $a -eq $b ]] 
	Not Equal 					[[ $a -nq $b ]]
-----------------------------------------------


# Logic Operations
-----------------------------------------------
	Operation						Operator
-----------------------------------------------
	AND							[[ $a && $b ]]
	OR							[[ $a || $b ]]
	NOT 						[[ ! $a ]]
-----------------------------------------------

# String NULL value
-----------------------------------------------
	Operation						Operator
-----------------------------------------------
	Is NULL?					[[ -z $a ]]
	Is NOT NULL?				[[ !-z $a ]]
	Is NOT NULL?				[[ -n $a ]]
	Is NULL?					[[ !-n $a ]]
-----------------------------------------------

a=""
b="cat"
[[ -z $a ]]
echo $?      <= 0 true
[[ -n $b ]]
echo $?  	 <= 0 true


# [ ]  single test statement "test - check file types and compare values"
# [[ ]] 		<= bash 2.2 extended test


11. Working with string
$ a="hello"
$ b="world"
$ c=$a$b
echo $c

# how long is the string 
$echo ${#a}
5
$echo ${#c}
10

# sub string or piece
d=${c:3}			<= starting at the 3rd character
loworld				<= $c=helloworld   h=0, e=1, l=2, l=3
d=${c:3:4}			<= starting at the 3rd character to next 4 character
echo $d 
lowo
d=${c: -4}			<= count from end of string
orld
d=${c: -4:3}		<= 3 of last 4
ord

# Replace
fruit="apple banana banana cherry"

$ echo ${fruit/banana/mango}				<= change first banana to mango 
	apple mango banana cherry
$ echo $fruit
	apple banana banana cherry				<= same 
$ echo ${fruit//banana/mango}				<= // for both change banana 
	apple mango mango cherry
$ echo ${fruit/#banana/mango}				<= # ONLY FIRST list item change
	mango banana banana cherry
$ echo ${fruit/%cherry/mango}				<= % only the END of string
	apple banana banana mango
$ echo ${fruit/c*/mango}					<= * Matching


12. Coloring and Styling

# NCSA Escape code - Sequence
$ bash -e			<= enable, echo with Escaping

$echo -e "\033[34;42mThis is a Color Test\033[0m"
This is a Color Test

# Colored test(ANSI)
-----------------------------------------------
	Color		Foreground 	Background
-----------------------------------------------
	Black			30			40
	Red				31			41
	Green			32			42
	Yellow			33			43
	Blue			34			44
	Magenta(분홍)	35			45
	Cyan(하늘색)	36			46
	White			37			47
-----------------------------------------------	


13. Date and Printf
date is not part of BASH

# printf
http://wiki.bash-hackers.org/commands/builtin/printf

$ printf "Name:\t%s\nID:\t%04d\n" "Albert" "12" 				<= \t tab, %s string,\n new line,%04d 4digit
Name:   Albert
ID:     0012
-----------------------------------------------
#!/bin/bash
today=$(date +%F)
time=$(date +%T)
printf -v d "\tCurrent User:\t%s\n\tDate:\t\t%s at(@) %s\n"  $USER $today $time
echo "$d"
-----------------------------------------------
	Current User:   apark
	Date:           2017-01-18 at(@) 17:02:28

printf "My name is \"%s\".\nIt's a pleasure to meet you."  "Albert"
My name is "Albert".
It's a pleasure to meet you.

$ echo $USER
$ echo $LOGNAME
$ whoami

14. Array
a=()
b=("apple" "banana" "cherry")   or  $b=(apple banana cherry)
$ echo $b						<= only returns apple
$ echo ${b[2]}
$ b[5]="kiwi"					<= add to 5th position in array
$ echo ${b[5]}
kiwi
$ b+=("mango")					<= add to the end of array
$ echo ${b[@]}					<= @ as whole array list	
apple banana cherry kiwi mango
$ b+=melon						<= add to the 0 position of array
$ echo ${b[@]}
applemelon banana cherry kiwi mango

$ echo ${b[@]}
applemelon banana cherry kiwi mango melon melon

#grep last
$ echo ${b[@]: -1}				<= grep last element on the array
melon				

# Bash 4 <, associate ARRAY
-----------------------------------------------
#!/bin/bash
declare -A my_array
my_array[car_brand]=BMW
my_array["car_model"]="X6"
echo ${my_array["car_brand"]} is ${my_array[car_model]}
-----------------------------------------------
#!/bin/bash
declare -A my_array
my_array[brand]=BMW
my_array["model"]="X6"
echo I have a ${my_array["brand"]} ${my_array[model]} car.
-----------------------------------------------



15. Reading and writing
$ echo "something" | sudo tee --append /var/log.file    <= non suoder gets permission error so use " sudo tee --append" 

----------------------------------------------- 
#!/bin/bash								
i=0
while read f; do
	echo "Line $i: $f"
	((i++)
done < file.txt
-----------------------------------------------
file.txt 		<= test1, test2, test3, test4

$./while.sh 
Line 0: test1
Line 1: test2
Line 2: test3
Line 3: test4


#
cat file.txt  VS.  cat < file.txt
http://unix.stackexchange.com/questions/258931/difference-between-cat-and-cat
cat file.txt  	<= reads the file myfile.txt then prints it to the standard output.

cat < file.txt 	<= here cat isn't given any file(s) to open, so -like many Unix commands do- reads 
					the data from the standard input, which is directed there from file.txt by the shell, 
					and prints to standard output.


















