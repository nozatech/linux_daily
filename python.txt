### Python ###


-----------------------------------------------------
Python3. ImportError: no module named 'myfile'
$ which   python  <=
$ whereis python

$ python
>>> import sys
>>> print(sys.path)
Python PATH: [/home/apark/google-cloud-sdk/lib/third_party:/home/apark/google-cloud-sdk/lib:/usr/lib64/python27.zip:/usr/lib64/python2.7/:/usr/lib64/python2.7/plat-linux2:/usr/lib64/python2.7/lib-tk:/usr/lib64/python2.7/lib-old:/usr/lib64/python2.7/lib-dynload]




-----------------------------------------------------
Python Dev Environment
https://www.digitalocean.com/community/tutorials/how-to-install-python-3-and-set-up-a-local-programming-environment-on-ubuntu-16-04


https://www.digitalocean.com/community/tutorials/how-to-install-python-3-and-set-up-a-programming-environment-on-an-ubuntu-16-04-server

$ source my_env/bin/activate

$ deactivate 
$ source deactivate




### IDE(Integrated Development Environment) ### 
# PyCharm
Ctrl+Y 		<= Remove a Line
Shift+Enter	<= add a line

# Visual Studio


# Python 32 or 64bit version check in Python Shell
>>> import struct;print struct.calcsize("P") * 8


1.  Python Installation

### CentOS7  <- Python 3.5.2 Install on
https://www.digitalocean.com/community/tutorials/how-to-install-python-3-and-set-up-a-local-programming-environment-on-centos-7
sudo yum -y install yum-utils
sudo yum -y groupinstall development
sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm
sudo yum -y install python35u-3.5.2
sudo yum -y install python35u-pip
sudo yum -y install python35u-devel

$ python3.5 -V
	Python 3.5.6

sudo yum -y install python36u-pip



### For MAC
$ brew install python

### Boto install
$ pip install boto
$ pip install --target c:/python27/Lib/site-packages boto
$ pip install --target c:/python34/Lib/site-packages boto  <= if boto is keep installing on python27 folder

### Win7 	<- Cygwin "ImportError: No module named boto"
http://stackoverflow.com/questions/5599872/python-windows-importerror-no-module-named-site

$ vi botoCheck.py
#!/usr/bin/env python
import boto
print boto.Version
>>> 2.45.0


# Django version check
python -c "import django; print(django.get_version())"


$ yum install python-pip
$ pip install pudb 	<=debug tool
http://stackoverflow.com/questions/1623039/python-debugging-tips	




#--------------------------------------------------------------------------------
### Object-oriented programming (OOP) ###
#--------------------------------------------------------------------------------
	is a programming paradigm that represents the concept of "objects" that have data fields 
	(attributes that describe the object) and associated procedures known as methods. Objects, 
	which are usually instances of classes, are used to interact with one another to design applications 
	and computer programs.[1][2] C++,Objective-C, Smalltalk, Java, C#, Perl, Python, Ruby and PHP are 
	examples of object-oriented programming languages.

	Object-oriented programming is an approach to designing modular, reusable software systems. Although 
	discussions of object-oriented technology often get mired in the details of one language vs. the other, 
	the real key to the object-oriented approach is that it is a modelling approach first.[3] Although often 
	hyped as a revolutionary way to develop software by zealous proponents, the object-oriented approach is 
	in reality a logical extension of good design practices that go back to the very beginning of computer 
	programming. Object-orientation is simply the logical extension of older techniques such as structured 
	programming andabstract data types. An object is an abstract data type with the addition 
	of polymorphism and inheritance.

	Rather than structure programs as code and data, an object-oriented system integrates the two using the 
	concept of an "object". An object has state (data) and behavior (code). Objects correspond to things 
	found in the real world. So for example, a graphics program will have objects such as circle, square, menu. 
	An online shopping system will have objects such as shopping cart, customer, product. The shopping system 
	will support behaviors such as place order, make payment, and offer discount. The objects are designed as 
	class hierarchies. So, for example, with the shopping system there might be high level classes such as 
	electronics product, kitchen product, and book. There may be further refinements for example under electronic 
	products: CD Player, DVD player, etc. These classes and subclasses correspond to sets and subsets 
	in mathematical logic.

	The goals of object-oriented programming are:
	•	Increased understanding.
	•	Ease of maintenance.
	•	Ease of evolution.

	The overall understanding of the system is increased because the semantic gap—the distance between the 
	language spoken by developers and that spoken by users—is lessened. Rather than talking about database 
	tables and programming subroutines, the developer talks about things the user is familiar with: 
	objects from their application domain.[4]
	
Object orientation eases maintenance by the use of encapsulation and information hiding. One of the 
most common sources of errors in programs is when one part of the system accidentally interferes with 
another part. For example, in the very earliest days of programming, it was common for developers to 
use "go to" statements to jump to arbitrary locations within only a few routines and functions. 
Critics called this "spaghetti code" because it is disorganized. Structured programming addresses 
this by encouraging the use of procedures and subroutines. Appropriate usage sections off 
responsibility for individual blocks to implement separate functionality. So, for example, one 
would know that the square root function was separate from the launch missiles function, and a 
change to one could not affect the other.[5]

Object-orientation takes this to the next step. It essentially merges abstract data types with 
structured programming and divides systems into modular objects which own their own data and are 
responsible for their own behavior. This feature is known as encapsulation. With encapsulation, 
not only can the "square root" and "launch missiles" functions not interfere with each other, 
but also the data for the two are divided up so that changes to one object cannot affect the other. 
Note that all this relies on the various languages being used appropriately, which, of course, 
is never certain. Object-orientation is not a software silver bullet, and it is not magic that 
makes all development problems go away.[6]

In addition to providing ease of maintenance, encapsulation and information hiding provide ease 
of evolution as well. Defining software as modular components that support inheritance makes it 
easy both to re-use existing components and to extend components as needed by defining new 
subclasses with specialized behaviors. This goal of being easy to both maintain and reuse is 
known in the object-oriented paradigm as the "open closed principle". A module is open if it 
supports extension (e.g. can easily modify behavior, add new properties, provide default values, etc.). 
A module is closed if it has a well defined stable interface that all other modules must use 
and that limits the interaction and potential errors that can be introduced into one module 
by changes in another.[7]

The object-oriented approach encourages the programmer to place data where it is not directly 
accessible by the rest of the system. Instead, the data is accessed by calling specially 
written functions, called methods, which are bundled with the data. These act as the 
intermediaries for retrieving or modifying the data they control. The programming construct 
that combines data with a set of methods for accessing and managing those data is called 
an object. The practice of using subroutines to examine or modify certain kinds of data 
was also used in non-OOP modular programming, well before the widespread use of object-oriented programming.
An object-oriented program usually contains different types of objects, each corresponding 
to a real-world object or concept such as a bank account, a hockey player, or a bulldozer. 
A program might contain multiple copies of each type of object, one for each of the real-world 
objects the program deals with. For instance, there could be one bank account object for 
each real-world account at a particular bank. Each copy of the bank account object would 
be alike in the methods it offers for manipulating or reading its data, but the data inside 
each object would differ, reflecting the different history of each account.
Objects can be thought of as encapsulating their data within a set of functions designed 
to ensure that the data are used appropriately, and to assist in that use. The object's 
methods typically include checks and safeguards specific to the data types the object 
contains. An object can also offer simple-to-use, standardized methods for performing 
particular operations on its data, while concealing the specifics of how those tasks 
are accomplished. In this way, alterations can be made to the internal structure or 
methods of an object without requiring that the rest of the program be modified. 
This approach can also be used to offer standardized methods across different types 
of objects. As an example, several different types of objects might offer print methods. 
Each type of object might implement that print method in a different way, reflecting 
the different kinds of data each contains, but all the different print methods might 
be called in the same standardized manner from elsewhere in the program. These features 
become especially useful when more than one programmer is contributing code to a project 
or when the goal is to reuse code between projects.
 
###	Object-Oriented Programming ###
https://jeffknupp.com/blog/2014/06/18/improve-your-python-python-classes-and-object-oriented-programming/
The "CLASS" is a fundamental building block in Python(blueprints or TEMPLATE for creating objects).
	Like its function-based cousin def, it concerns the definition of things
def: define FUNCTION
class: define CLASS functions (referred to as "methods" when defined within a class)
	classes are based on objects in the real world (like Customer or Product)
	classes are based on concepts in our system, like HTTPRequest or Owner.
#--------------------------------------------------------------------------------
# 
#--------------------------------------------------------------------------------



//depot/mobile/OO/buildScripts/trafficSplit/


1. Environment PATH
#!/usr/local/python3.5 or 2.7			<= specific version of Python3.5 
#!/usr/bin/env python   	 			<= run almost every linux using env PATH 

Python Programming Built-in Functions
https://www.programiz.com/python-programming/built-in-function


2. Debugging Python Debuger
python -m pdb myscript.py
l <=list
n <=next
c <=continue
s <=step
w <=where 
u <=up
d <=down
locals()

3. Reading file
http://www.afterhoursprogramming.com/tutorial/Python/Reading-Files/


f = open("test.txt","r") #opens file with name of "test.txt"

myList = []

for line in f:

    myList.append(line)

print(myList)


4. Run BASH cmd
http://stackoverflow.com/questions/26236126/how-to-run-bash-command-inside-python-script
import subprocess
subprocess.Popen("aws ec2 describe-instances --query 'Reservations[*].Instances[*].[InstanceId]' --filters Name=instance-state-name,Values=running --output text > ~/instanceId.txt")


###	Python2 vs 3 differences ###
http://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html

Python 2.x  
	print "Hello World"			<= NO  ()
	input()
	
Python 3.x
	print ("Hello World")       <= YES ()
	raw_input()
	
	
### Variable ###
Python 2.x
	f = 0;					<= Declared,  number Don't need "" 
	print f	
# Re-declaring the variable works
	f = "abc"				<= 	f = 0 becomes f = abc   letters needs "" 
	print f
	
Python 3.x
	f =0;
	pinrt (f)
	

print "string type" + 123   	<= ERROR  String + Number DO NOT WORK!	
# Python 2.x
print "string type" + str(123)	<= Convert 123 to String.
# Python 3.x
print ("string type" + str(123))
	
	
### Exit status  exit() vs sys.exit()
	exit()		<- interactive shell 
	sys.exit()  <- use in programs.	
	
	
### Global vs Local Variables(in side of function)
f = 0;								<= Global
print("Global var f is: ", f)				

def someFunction():
    #global f			
    f = "local var"					<= Local
    print (f)						<= Python 3.x print ()

someFunction()						<= Calling function
print("----------")
print(f)

>>> Global var f is: 0
>>> local var
>>> ----------
>>> Global var f is: 0
----------------------------------------------------------------------
f = 0;					<= Global
print(f)

def someFunction():
    global f			<= Declare as Global variable f = def variable		
    f = "local var"		<= Local becoming Global variable from '0' to 'def'
    print(f)			<= Python 3.x print ()

someFunction()			<= Calling function
print("----------")
print(f)				<= print global var f, but print local var f cuz global

>>> 0
>>> local var
>>> ----------
>>> local var				    <= inside function's variable become Global variable
----------------------------------------------------------------------

# Undefined the variable using 'del' function	
f = 0;
print (f)

del f
print (f)

>>> NameError: name 'f' is not defined
	
----------------------------------------------------------------------	
###	Function  ###
----------------------------------------------------------------------
# Define a function
def func1():						<= defining "func1" function name
	print ("I am a function")
func1()								<= Invoke func1	
print func1()						<= Python3 Doesn't Work!	
print func1							<= Print func1's Object value

>>> I am a function					<= func1() calling
# print func1()
>>> I am a function					<= func1() calling
>>> None							<= No return value from func1 so 'print' 
										out put default value 'None'
>>> print func1
<function func1 at 0x6ffffe688c0>   <= Print func1's Object value


def func1():						<= defining "func1" function name
	print ("I am a function")
def func2(arg1, arg2):
	print (arg1, " space ", arg2)
	
func2(10,20)
print func2(10,20)					<= only code works on Python 2.x


----------------------------------------------------------------------
def func1():
	print ("I am a function")
def func2(arg1, arg2):
	print (arg1, " space ", arg2)
def cube(x):
    return x*x*x

print (cube(3))						<= Python 3.x
	
	
	
----------------------------------------------------------------------	
	
	
# For function need to use RETURN instead of Print!!!	
### Print vs Return
https://www.codecademy.com/en/forum_questions/518ffbfeb3f05c44fe001395	
	
def print_a_number(num):
    print num

def return_a_number(num):
    return num

def add_three(num):
    return num + 3

f1 = print_a_number(7)
f2 = return_a_number(2)

print f1
print f2
f3 = add_three(f2)
print f3
f4 = add_three(f1)
print f4
>>>
7
None
2
5
TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'
>>>

Notice that we got an error when we tried to pass f1 to add_three because f1 
had a value of None, even though it had printed out the correct number. This 
is why it is important to return values and not print them (except when we 
want to know what the value is).
	
----------------------------------------------------------------------	

### Conditional

def main():
    x, y = 10, 100
    if (x < y):
        st = "x is less than y"
    elif(x == y):
        st = "x is same as y"
    else:
        st = "x is greater than y"
   
	###Conditional statements let you use "a if C else b"  <= put into 1 line 
	# st = "x is less than y" if (x <y) else "x is greater than or equal to y"
	print (st)
	
if name == "__main__":				<= = x2 '=='
    main()
	
	
----------------------------------------------------------------------	
### What does if __name__ == “__main__”: do?
http://stackoverflow.com/questions/419163/what-does-if-name-main-do
https://www.youtube.com/watch?v=sugvnHA7ElY

if __mame__ == "__main__":				<= invoking a main function in Python files.
	main()

# Python3	
	print("__name__")
	>>> __main__
	
	print("First Module's Name: {}".format(__name__))
	>>> First Module's Name: __main__
	
# Python2
	print __name__	
	>>> __main__	

	print "First Module's Name: {}".format(__name__)	
	>>> First Module's Name: __main__

	
	
	
	
	



----------------------------------------------------------------------
# While Loop
----------------------------------------------------------------------

def main():
    x = 0								<= start 0
    while (x < 5):						<= up to 4 because when x=5, look break!
        print (x)
        x = x + 1
if __name__ == "__main__":				<= name == main
    main()
-----------------------------
# For Loop
def main():
	for i in range(5,10):
		print (i)
if __name__ == "__main__":				<= name == main
	main()
-----------------------------	
# For Loop using LIST
def main():
	x = 0
	days = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"]
	for day in days:
		print (day)
if __name__ == "__main__":
	main()
-----------------------------	
	
# For Loop using BREAK!
def main():
	x = 0
	for x in range(5,10):
		if (x == 7): break
		print (x)
if __name__ == "__main__":
	main()
-----------------------------
# For Loop using Continue!
def main():
	#x = 0
	for x in range(5,10):
		if (x % 2 == 0): continue		# <= 5, 7, 9
		#same as if (x % 2):
		#if (x % 2): continue			# <= 6, 8
		
		print (x)
		
if __name__ == "__main__":
	main()
-----------------------------
# For Loop using Index Enumerate function
def main():
	#x = 0
	days = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"]
	for i, d in enumerate(days):						<= returns two values
		print (i, d)

if __name__ == "__main__":
	main()

	

	
	
	
	
	
	
-----------------------------
### CLASSes OOP		<= Complete module to pass around

class myClass():									<= Super Class
	def method1(self):								<= ALWAYS!!!  itself
		print ("myClass method1")

	def method2(self, someString):
		print("myClass method2: " + someString)
		
class anotherClass(myClass):						<= Inherent ^Class 
	def method2(self):
		print "anotherClass method2"
		
	def method1(self):
		myClass.method1(self);
		print "anotherClass method1"

def main():
	c = myClass()
	c.method1()
	c.method2("This is a string")

if __name__ == "__main__":
	main()

----------------------------------------------------------
# Inherent from SUPER myClass

class myClass():								<= SUPER myClass
  def method_1(self):
    print("myClass method_1")

  def method_2(self, someString):
    print("myClass method_2: " + someString)

class anotherClass(myClass):   					<=Inherent from myClass()
  def method_2(self):
    print ("anotherClass method2")
  def method_1(self):
    myClass.method_1(self);
    print ("anotherClass method1")

def main():
    c = myClass()
    c.method_1()
    c.method_2("This is a string")
    print ("----------------------")
    c2=anotherClass()
    c2.method_1()
    c2.method_2()

if __name__ == "__main__":
    main()

>>>----------------------------------------------------------
myClass method_1 
myClass method_2: This is a string
----------------------
myClass method_1
anotherClass method1
anotherClass method2
>>>----------------------------------------------------------


class Car:                          <= Class uses Carmel Case convention
    def __init__(self, name):		<= constructor method 
        self.name = name			<= initiating object(instance)

    def driving(self):				<= Method1 driving(function)
        print(self.name + " is a nice car to drive.")

    def looks(self):				<= Method2 looks(function)
        print(self.name + " looks awesome nice.")

def main():								<= Main function

    bmw = Car("BMW X6")
    bmw.driving()
    bmw.looks()
    print("")                           # print an empty line| print() works, too.
    mb = Car("MB GLC300 Coupe")
    mb.driving()
    mb.looks()

if __name__ == "__main__":				<= 
    main()

>>>----------------------------------------------------------
BMW X6 is a nice car to drive.
BMW X6 looks awesome nice.

MB GLC300 Coupe is a nice car to drive.
MB GLC300 Coupe looks awesome nice.
>>>----------------------------------------------------------

# Define function names()
def function1():
    # Set up name variable with input
    name = str(input("Enter your name: "))

    # checking vowels
    if set('aeiou'). intersection(name.lower()):  			# set is built-in function
        print("Your name contains a vowel.")
    else:
        print("Your name doesn't contain a vovwel.")

    # Iterate over(review through) name
    for letter in name:
        print(letter)

# Call function1 function()
function1()
----------------------------------------------------------

def profileInfo(userName, followers=1):
#def profileInfo(userName, followers=1):
    print("User name: " + userName)
    print("Followers: " + str(followers))         # when print(), converts int to string

# Call function with parameters assigned as above
# input values into function parameters userName as Albert Park, followers as 965
profileInfo("Albert", 965)

profileInfo("Sujin")				# No Followers, but it will use default value=1

# Call function with keyword arguments
# Input userName="Nozatech", followers=343) to
profileInfo(userName="Nozatech", followers=343)

>>>----------------------------------------------------------
User name: Albert
Followers: 965
User name: Sujin
Followers: 1			<= Using default value 'followers=1 '
User name: Nozatech
Followers: 343
>>>----------------------------------------------------------

### function Returning a Value using "RETURN'
def sq(x):
    y = x ** 2
    return y
answer = sq(3)			<= variable
print(answer)			<= print funtion
-------------------------------------------
def sq(x):
    y = x ** 2
    return y
result = sq(3)			<= variable
print(result)
-------------------------------------------
def sq(x):
    y = x ** 2
    print(y)
answer = sq(3)
print(answer)
>>>	9
>>> None
-------------------------------------------
def sq(x):
    y = x ** 2
#    return y				<= Without 'return' 
answer = sq(3)
print(answer)

>>> None
-------------------------------------------

def addNumbers(x, y, z):
    a = x + y
    b = x + z
    c = y + z
    print(a, b, c)			<= Values are PRINTED

addNumbers(1, 2, 3)

>>>3 4 5
-------------------------------------------
def addNumbers(x, y, z):
    a = x + y
    b = x + z
    c = y + z
    return a, b, c				<= Values are RETURNED as TUPLE a, b, c by "," comma

sums = addNumbers(1, 2, 3)		
print(sums)

>>>(3, 4, 5)					<= TUPLE RETURN with , comma seperation
-------------------------------------------
def loopFive():
    for i in range(0, 25):
        print(i)
        if i == 5:
            # Stopping at i == 5
            return
    print("This will not execute.")
loopFive()
>>>-------------------------------------------	
0
1
2
3
4
5   <= RETURN breaks the for loop at 5
-------------------------------------------		

### Using main() as a Function
# declare a global variable


name = str(input("Enter your name: "))
print(name)
>>>Enter your name: Albert
>>>Albert
-------------------------------------------	
# Declare global variable name for use in all functions
name = str(input('Enter your name: '))


# Define function to check if name contains a vowel
def has_vowel():
    if set('aeiou').intersection(name.lower()):
        print('Your name contains a vowel.')
    else:
        print('Your name does not contain a vowel.')


# Iterate over letters in name string
def print_letters():
    for letter in name:
        print(letter)


# Put has_vowel & print_letters into main functions
def main():
    has_vowel()
    print_letters()


# Execute main() function
if __name__ == '__main__':
    main()  


-------------------------------------------	
### Write Modules
The Python Standard Library
https://docs.python.org/3/library/





-------------------------------------------
### Import Modules 
-------------------------------------------
https://www.digitalocean.com/community/tutorials/how-to-import-modules-in-python-3#checking-for-and-installing-modules
Modules can contain definitions of functions, classes, and variables that can 
then be utilized in other Python programs
e.g. 
import name_of_module   <= importing from module.py file

-------------------------------------------	
1. vi hello_module.py

def hello_world():
	print("This is Hello World module you have imported.")
	
2. vi hello_module_import.py

import hello_module						<= importing module py file from same dir
hello_module.hello_world()				<= using same import_module name + 
										   . (append) 
										   hello_module function name "hello_world"
--------------------------------------------------											   
>>>This is Hello World module you have imported.
--------------------------------------------------

### Global and Local Variables

#Create a global variable, outside of a function
global_var = "Global variable i.e. outside of function"

#Define a function
def variable_function():
    local_var = "Local variable i.e. only inside of var_function"
    print(local_var)

#Call function to print local variable
variable_function()

#Print global variable outside function
print(global_var)

--------------------------------------------------
glb_var = "global"

def var_function():
    lcl_var = "local"
    print(lcl_var)
    print(glb_var)			 #Print glb_var within function

var_function()
print(glb_var)
print(lcl_var)			<= NameError: name 'lcl_var' is not defined
--------------------------------------------------
num1 = 5  # Global variable

def my_function():
    num1 = 10    # Use the same variable name num1
    num2 = 7     # Assign local variable
	global num3 = 5
	
    print(num1)  # Print local variable num1
    print(num2)  # Print local variable num2

my_function()	 # Call my_function()
print(num1)		 # Print global variable num1
print(num3)		 #	
--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------
--------------------------------------------------
--------------------------------------------------
--------------------------------------------------
--------------------------------------------------
--------------------------------------------------
--------------------------------------------------
--------------------------------------------------
--------------------------------------------------

















































	
	
	
	
	

#!/usr/local/python3.5
print("Hello World")
def subr():
        return 5+37
x = subr
print(x)

From Python Shell
>>> print "\t" ":"		<= "\t" tab
        :

$ python3.5 helloworld.py
$ chmod +x helloworld.py
$ ./helloworld.py




----------------------------------
x=1
print(x)
x='foo'
print(x)
x = x + "1"    <= Switch to string from integer
print(x)
y = input("Your name?")
print(y)
----------------------------------
name = input("What is your name: ")

----------------------------------
# For Loop
----------------------------------
for i in range (1,10):
    print("Welcome", name,"", i)

----------------------------------
# While Loop
----------------------------------
x=0
while 1: # True:
    print (x)
    x = x + 1
    if (x == 15):
        break
		
----------------------------------
# For Loop using a list
----------------------------------
myCar = ['BMW', 'Lexus', 'Ferrari']
for i in myCar:
    print(i)

----------------------------------
# Scoping
----------------------------------
x = 0      # <=without x, error for initial value set
for i in range(1,25):
    x = i + x  
print(x)

----------------------------------
# Function
----------------------------------
def main():
    print ("Hello World")
if __name__ == "__main__":
    main()
	
	
def sub(x,y):
    z = x - y
    print(z)

def add( x, y ):
    return x + y

print(add(15,4))
sub(4,3)
----------------------------------
x = int(input("Type a number:   "))
if ( x < 1):
    print ("Too small")
elif (x >= 1) and ( x <= 10 ):  #ge , le
    print("ok")
else:
    print("too high")
----------------------------------

### Call Linux host command
----------------------------------
#!/usr/bin/python3.5
import os
from subprocess import call

print(os.getcwd())     		# same as PWD
print(os.getuid())			# 0
print(os.getenv("PATH"))	#/sbin:/bin:/usr/sbin:/usr/bin
os.system("ls -al")			# system
inp=input("Hit enter")

call(["ls", "-la"])			# sub

----------------------------------
#!/usr/bin/python3.5
import threading

# v-Object
class aThread(threading.Thread):
    def __init__(self, num, val):
        threading.Thread.__init__(self)
        self.threadNum = num
        self.loopCount = val

    def run(self):
        print("Starting run:  ", self.threadNum)
        myfunc(self.threadNum, self.loopCount)

def myfunc(num, val):
    count = 0
    while count < val:
        print(num, " : ", val * count)
        count = count + 1

t1 = aThread(1, 15)
t2 = aThread(2, 20)
t3 = aThread(3, 25)
t4 = aThread(4, 30)

t1.start()
t2.start()
t3.start()
t4.start()

threads = []
threads.append(t1)
threads.append(t2)
threads.append(t3)
threads.append(t4)

for t in threads:
    t.join()
	
----------------------------------
### OOP ###
----------------------------------
class Car():
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year =year
        self.fuel_capacity = 20
        self.fuel_level = 0
    def fill_tank(self):
        self.fuel_level = self.fuel_capacity
        print("Fuel tank is full.")
    def drive(self):
        print("Car is moving")

my_car = Car('BMW', 'X6', 2011)
my_old_car = Car('BMW', 'M3', 1997)
my_new_car = Car('BMW', 'M6', 2020)

print(my_car.make, my_old_car.make,my_new_car.make)
print(my_car.model, my_old_car.model, my_new_car.model)
print(my_car.year, my_old_car.year, my_new_car.year)

### Output
> BMW BMW BMW
> X6 M3 M6
> 2011 1997 2020


----------------------------------
import random
import sys
import os

'''
Comments
Data type: number, string, list, tuple, dictionary
'''

### Print ###
print("Hello World")
name = "Albert"
print(name)

print("5 + 2 =", 5+2)
print("5 - 2 =", 5-2)
print("5 * 2 =", 5*2)
print("5 / 2 =", 5/2)
print("5 % 2 =", 5%2)
print("5 ** 2 =", 5**2)
print("5 // 2 =", 5//2)  						# floor division: discard remainder 1, 14.5 =14

quote = " \"Always remember"   					# \ is ignoring "
print(quote)

multi_string = quote + name
print(multi_string)
print('\n' * 1)             					# 1 new lines

print("%s %s %s" % ('new type quote', quote, name))
print("I don't like ", end="")
print("newlines")


### List  ###
import random
import sys
import os

### List

grocery_list = ['Juice', 'Tomatoes', 'Potatoes', 'Bananas']
print(grocery_list)
print('Frist Item', grocery_list[0])
grocery_list[0] = "Orange Juice"        # Change to  Juice to Orange Juice
print('First Item', grocery_list[0])
print(grocery_list[1:3])
other_events = ['Wash car', 'Pickup kids', 'Cash Check']
to_do_list = [other_events, grocery_list]
print (to_do_list)
print((to_do_list[1][1]))    # 1st [] list is other_event which is 0, 2nd [] is grocery_list's 2nd item 1
grocery_list.append('Onion')
print(to_do_list)
grocery_list.insert(1, "Pickle")
print(to_do_list)
grocery_list.remove("Pickle")
print(to_do_list)
grocery_list.sort()
grocery_list.reverse()
del grocery_list[1]
print(to_do_list)
to_do_list2 = other_events + grocery_list
print(to_do_list2)
print(len(to_do_list2))
print(max(to_do_list2))
print(min(to_do_list2))


### TUPLE ###
pi_tuple = (3,1,4,1,5,9)

new_tuple = list(pi_tuple)
new_list = tuple(new_tuple)
len(tuple) min(tuple) max(tuple)

### Dictionaries ###
import random
import sys
import os

super_villains = {'Fiddler'        : 'Isaac Bowin',
                  'Captain Cold'   : 'Leonard Snart',
                  'Weather Wizard' : 'Mark Mardon',
                  'Mirror master'  : 'Sam Scudder',
                  'Pied Piper'     : 'Thomas Peterson'}

print(super_villains ['Captain Cold'])

del super_villains['Fiddler']

super_villains['Pied Piper'] = 'Hartly Rathway'

print(super_villains ['Pied Piper'])

print(super_villains.keys())

print(super_villains.values())


--------------------------------------------------------------------------------######
### Conditional ###
--------------------------------------------------------------------------------######


# if else elif    ==    !=    >    >=    <=
age =30
if age >16:
    print('You can drive')
else:
    print('You cant drive')
print('----')
if age >= 21 :
    print('You can drive')
elif age >= 16 :
    print('drive')
else :
    print ('You can\'t')

# Logical Operators: and, or, not
if ((age >= 1 ) and (age <=18)):
    print("you get a b-day")
elif ((age >= 21 ) and (age <=65)):
    print("you get a b-day")
elif not(age ==30) :
    print('No b-party')
else :
    print('B-Party')



for x in range(0,10):
    print(x, '', end="")
# a new line
print('\n')


grocery_list = [ 'juice', 'tomato', 'potatos','banaba']
for y in grocery_list:
    print(y)

for x in [2,4,6,8,10]:
    print (x)
#list in list
print('\n')

num_list = [[1,2,3],[10,20,30],[100,200,300]]
for x in range(0,3):
    for y in range(0,3):
        print(num_list[x][y])	#<=?? why

----------------------		
### While Loop ###
----------------------
random_num = random.randrange(0,100)
while(random_num != 15):
    print(random_num)
    random_num = random.randrange(0,100)	
	

i = 0;
while(i <= 20):
    if (i%2 == 0):
        print(i)
    elif (i == 21):
        break
    else:
        i += 1    #<= Python doesn't support i++
        continue
    i += 1
	

----------------------	
###function
----------------------

def addNumber(firstNum, lastNum):
    sumNum = firstNum + lastNum
    return sumNum
print(addNumber(1, 4))
	

### User Input ###	
import random
import sys
import os

print("What is your name?")
name = sys.stdin.readline()
print("Hello", name)

import sys
for line in sys.stdin:
    print line	

sys.stdin is a file-like object on which you can call functions read or readlines if you want to read everything 
or you want to read everything and split it by newline automatically. (You need to import sys for this to work.)

If you want to prompt the user for input, you can use raw_input in Python 2.X, and just input in Python 3.
	
name = raw_input("Enter your name: ")   # Python 2.x	
name = input("Enter your name: ")   	# Python 3	
	
import random
import sys
import os

long_string = "I will change you if you fall = The Floor ok"
print("1st-",long_string)
	# 1st- I will change you if you fall = The Floor ok
print(long_string[:])
print(long_string[0:4]) #first 4 letters space don't count?
	# I wi
print(long_string[-5])
	# o
print(long_string[:-5])
	# I will change you if you fall = The Flo
print(long_string[:4] + " be there")
	# I wi be there
print("%c is my %s letter and my number %d number is %.5f" %
      ('X', 'favorite', 1, .14))
	# X is my favorite letter and my number 1 number is 0.14000	
	
###	
print(long_string.capitalize())
print(long_string.find("ok"))
print(long_string.isalpha())
print(long_string.isalnum())
print(long_string.replace("Floor", "Ground"))
print(long_string.strip())
print(len(long_string))
quote_list = long_string.split(" ")
print(quote_list)
###
I will change you if you fall = the floor ok
42
False
False
I will change you if you fall = The Ground ok
I will change you if you fall = The Floor ok
44
['I', 'will', 'change', 'you', 'if', 'you', 'fall', '=', 'The', 'Floor', 'ok']
###

	
	
	
	
	
	
	
	
	
	
	


# Checking argument using function "len(sys.argv)" count the number of arguments(command line arguments)
argv is "argument value" from C program 

sys.argv[0] is the name of the script( like Bash using variable $0 as script itself)
http://stackoverflow.com/questions/13263951/what-is-argv-and-what-does-it-do
# sys.argv				<= command line arguments to passed in to next argument
						<= get argument list using sys module


--------------------------------------------------------------------------------	
$ vi python_len.py   				<= run script without the parameter, print out usage

import os, sys
if len(sys.argv) != 4:				<= requires 4 parameters(count the number of arguments)
    print "USAGE: python_len.py    1st_arg    2nd_arg    3rd_arg"
    print "\t" "e.g. python python_len.py  1st_arg  2nd_arg  3rd_arg"
	print "You need 4 arguments to run this script!"
    sys.exit(1)

$ python python_len.py				<= run
--------------------------------------------------------------------------------	

http://stackoverflow.com/questions/4117530/sys-argv1-meaning-in-script
For every invocation(call) of Python, sys.argv is automatically a list of strings representing 
the arguments(as separated by spaces) on the command-line. The name "sys.argv" comes from the C programming 
convention in which "argv" and "argc" represent the command line arguments.	

e.g. create a script that prints the arguments as they're represented. 
It also prints the number of arguments, using the len function on the list.

	from __future__ import print_function
	import sys
	print(sys.argv, len(sys.argv))

>>> [''] 1



user_args = sys.argv[1:] 		<= get everything after the script name




--------------------------------------------------------------------------------	
### Import 

# import sys
The sys module provides information about constants, functions and methods of the Python interpreter. 
dir(system) gives a summary of the available constants, functions and methods. Another possibility 
is the help() function. Using help(sys) provides valuable detail information. 	
	
# Exit code "sys.exit(1)"
sys.exit() is the proper, defined, cross-platform way to exit from
a program and return a value to the calling program

http://stackoverflow.com/questions/19862438/python-sys-exit-with-a-number
Exit code meanings are a convention; 0 means success, anything else usually means there was a problem. 
Explicitly exiting the program with sys.exit(1) simply means the program adheres to that convention; 
it is signalling something to whatever started the script, namely that things didn't work out.	 
-------------------------------------	
import sys

def main(args):
    if len(args) < 2:
        sys.exit("I need arguments!")
print("rest of program...")

if __name__=='__main__':
    main(sys.argv)	
-------------------------------------	
https://www.cyberciti.biz/faq/python-command-line-arguments-argv-example/
-------------------------------------	
#!/usr/bin/python
# demo.py - CMD Args Demo By nixCraft
import sys
 
# Get the total number of args passed to the demo.py
total = len(sys.argv)
 
# Get the arguments list 
cmdargs = str(sys.argv)
 
# Print it
print ("The total numbers of args passed to the script: %d " % total)
print ("Args list: %s " % cmdargs)
-------------------------------------
http://ngee.tistory.com/159
#systest.py

import sys
var1 = sys.argv[1]
var2 = sys.argv[2]
var3 = sys.argv[3]

print "var1 = " + var1
print "var2 = " + var2
print "var3 = " + var3

print sys.argv[0]
--------------------------------------------------------------------------
vi  sys.argv.py
--------------------------------------------------------------------------
import sys
print sys.argv[0], 	 " <= name of this script." 
print len(sys.argv), " <= is number of arguments." 				
print str(sys.argv), " <= is the arguments." 				
----------------------------------------------------------------
>>>sys.argv.py      <= name of this script.
>>>1                <= is number of arguments
>>>['sys.argv.py']  <= is the argument.
--------------------------------------------------------------------------


http://stackoverflow.com/questions/997797/what-does-s-mean-in-python
	
if len(sys.argv) < 2:
    sys.exit('Usage: %s database-name' % sys.argv[0])

if not os.path.exists(sys.argv[1]):
    sys.exit('ERROR: Database %s was not found!' % sys.argv[1])	
	
	
%s	<=It is a string formatting syntax (which it borrows from C).
----------------------------------------------------------------	
name = raw_input("who are you?")
print "hello %s" % (name,)	
----------------------------------------------------------------	
The %s token allows me to insert (and potentially format) a string. Notice that the %s token is 
replaced by whatever I pass to the string after the % symbol. Notice also that I am using a tuple 
here as well (when you only have one string using a tuple is optional) to illustrate that multiple 
strings can be inserted and formatted in one statement.	
	
	
"Hello %s, my name is %s" % ('john', 'mike') # Hello john, my name is mike".
If you are using ints instead of string, use %d instead of %s.

"My name is %s and i'm %d" % ('john', 12) #My name is john and i'm 12	
	
	
'%s' indicates a conversion type of 'string' when using python's string formatting capabilities. 
More specifically, '%s' converts a specified value to a string using the str() function. Compare 
this with the '%r' conversion type that uses the repr() function for value conversion.	
	
	
	
	
	
	
	
	
	
--------------------------------------------------------------------------------
1. Calculator	
--------------------------------------------------------------------------------
#!/usr/bin/python3.5
def add(x, y):
    return x + y
def sub(x, y):
    return x - y
def multi(x, y):
    return x * y
def div(x, y):
    return x / y

print("Select operation.")
print("1. Addition")
print("2. Subtract")
print("3. Multiply")
print("4. Divide")

choice = int(input("Enter a choice from 1/2/3/4: "))
# Verify choice
choice = int(input("Ente a choice from 1,2,3,4: "))
if choice == 0:
    print ("0 no option for zero")
elif choice > 4:
    print(" No option choice")
else:
    print("you have entered: ", choice )


num1 = int(input("Enter first number: "))
num2 = int(input("Enter second number: "))

if   choice == '1':
    print(num1,"+",num2,"=",add(num1,num2))
elif choice == '2':
    print(num1,"-",num2,"=",sub(num1,num2))
elif choice == '3':
    print(num1,"x",num2,"=",multi(num1,num2))
elif choice == '4':
    print(num1,"x",num2,"=",div(num1,num2))
else:
    print("You put the wrong input")
	
	
	
--------------------------------------------------------------------------------	
2. Find the Largest Among 3 Numbers
--------------------------------------------------------------------------------
#!/usr/bin/python3.5
print("Please enter 3 numbers to find biggest number among them!")
num1 = int(input("Enter first number: "))
print("You entered: ", num1)
num2 = int(input("Enter second number: "))
print("You entered: ", num2)
num3 = int(input("Enter second number: "))
print("You entered: ", num3)

if (num1 > num2) and (num1 > num3):
    print(num1,"is the biggest")
elif (num2 > num1) and (num2 > num3):
    print(num2,"is the biggest")
else:
    print(num3, "is the biggest.")	
	
	
	
--------------------------------------------------------------------------------	
3. Sq root
--------------------------------------------------------------------------------
# Python Program to calculate the square root

num = float(input('Enter a number: '))
num_sqrt = num ** 0.5
print('The square root of %0.3f is %0.3f'%(num ,num_sqrt))


--------------------------------------------------------------------------------	
4. # Python program to swap two variables
--------------------------------------------------------------------------------
#x = input('Enter value of x: ')
#y = input('Enter value of y: ')
x = 5
y = 10

# create a temporary variable and swap the values
change = x
x = y
y = change

# chgY = x
# chgX = y
# x = chgX
# y = chgY

print('The value of x after swapping: {}'.format(x))
print('The value of y after swapping: {}'.format(y))


--------------------------------------------------------------------------------	
# random
--------------------------------------------------------------------------------
import random

print(random.randint(0,9))

--------------------------------------------------------------------------------	
# check if a number is positive, negative or zero
# Using if...elif...else
--------------------------------------------------------------------------------
num = float(input("Enter a number"))

if num > 0:
    print(num, " is Positive")
elif num == 0:
    print (num, " is Zero")
else:
    print(num, " is Negative Number")
print("")

# Using Nested if
if num >= 0:
    if num == 0:
        print ("Zero")
    else:
        print("Positive")
else:
    print ("Negative")

	
--------------------------------------------------------------------------------	
# Check if a Number is Odd or Even
--------------------------------------------------------------------------------
num = int(input("Enter a number: "))

if (num % 2) == 0:
    print("Even")
else:
    print("odd")
''''------------------------------------'''
if (num % 2) == 0:
   print("{0} is Even".format(num))
else:
   print("{0} is Odd".format(num))

--------------------------------------------------------------------------------	
# Check Prime Numbers( Can't divide except 1) 2, 3, 5, 7, 11, 13, 17, 19, 23, and 29
http://www.programiz.com/python-programming/examples/prime-number
--------------------------------------------------------------------------------
num = int(input("Enter a number to check prime number: "))
if num > 1:
    for i in range(2, num):  	# e.g. 2..... 100(num)
        if ( num % i ) == 0:   	# modulo
            print(num, "is not a prime number")
            print(i, "times", num//i, "is", num)  #??
            break
#   <- indent for line because of break  
	else:
        print(num, "is a prime number")
else:
    print(num, "can't be used as a prime number!")

	#The break statement, like in C, breaks out of the smallest enclosing for or while loop.
	
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
#   |<- indent on for line, not if line 
	else:
        # loop fell through without finding a factor
        print(n, 'is a prime number')	
	
--------------------------------------------------------------------------------	

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------	

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------	

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------	

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------	

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------	

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------	

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------	

--------------------------------------------------------------------------------
Python3 Advance Topics(Pluralsight - Python Beyond The Basics)
---------------------------------------------------------------------------------------------------
Prerequisite
Built-in types
int, float, str, list, dict, set, tuple
object model
Rasing and handling exceptions
Iterables and Iterators
for loop
Classes with methods
Reading and writing text and binary files
Unit-testing, Debugging, Deployment
Terminologies: special methods
__<method name>__    
^^             ^^  	<= Dunder 던덜 (double underscore)
__len__				<= dunder len

---------------------------------------------------------------------------------------------------
02-01 Packages
---------------------------------------------------------------------------------------------------
Python Module

my_module.py				<= single file module

>>> import my_module
>>> type (my_module)
<class 'module'>

package 			<= a module which can contain other modules
    |- module
	|- package - module

>>> import urllib
>>> import urllib.request	
	>>> type(urllib)
	<class 'module'>
>>> type(urllib.request)
	<class 'module'>
>>> urllib.__path__
	['/usr/lib/python3.4/urllib']
>>> urllib.request.__path__
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute '__path__'

Packages 	<= are generally directories
Module 		<= are generally files

### How Python where to look packages and modules????
sys.path		<= list of direcotries Python searches for modules

>>> import sys
>>> sys.path
['', '/usr/lib/python34.zip', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-cygwin', 
'/usr/lib/python3.4/lib-dynload', '/usr/lib/python3.4/site-packages']

>>> sys.path[0]				<= indexing and slicing
''							<= empty string
>>> sys.path[-5]
'/usr/lib/python34.zip'


--------------------------------------------------------------------------------	

--------------------------------------------------------------------------------


### *args and **kwargs? 
The *args and **kwargs is a common idiom to allow arbitrary number of arguments to functions 
http://stackoverflow.com/questions/36901/what-does-double-star-and-star-do-for-parameters?noredirect=1&lq=1

http://stackoverflow.com/questions/3394835/args-and-kwargs
*args 
	when you're not sure how many arguments might be passed to your function, i.e. it allows you 
	pass an arbitrary number of arguments to your function
**kwargs 
	allows you to handle named arguments that you have not defined in advance:
	
you can use * and ** when calling functions as well. This is a shortcut that allows you to pass 
multiple arguments to a function directly using either a list/tuple or a dictionary. 
	
	
	
	
	
### return None	
http://stackoverflow.com/questions/17778372/why-does-my-function-return-none
It is returning None because when you recursively call it:	
Often in Python, functions which return None are used like void functions in C -- Their purpose 
is generally to operate on the input arguments in place (unless you're using global data (shudders)). 
Returning None usually makes it more explicit that the arguments were mutated. This makes it a 
little more clear why it makes sense to leave off the return statement from a "language conventions" 
standpoint.	
	
### variable None	
http://stackoverflow.com/questions/19473185/what-is-a-none-value
Assigning a value of None to a variable is one way to reset it to its original, empty state.
sns_topic = None	
	
	
### .pyc extension file	
	Python automatically compiles your script to compiled code, so called "byte code", before running it. 
	When a module is imported for the first time, or when the source is more recent than the current 
	compiled file, a .pyc file containing the compiled code will usually be created in the same 
	directory as the .py file.	
	
	
### sys.argv     <= "argument value" from C-style that PASS the the arugment to script
	http://www.pythonforbeginners.com/system/python-sys-argv
	a [] list in Python, which contains the "command-line arguments passed to the script". 
	With the "len(sys.argv)" function you can count the number of arguments. 
	If you are gonna work with command line arguments, you probably want to use sys.argv. 
	To use sys.argv, you will first have to import the sys module. 	
	-------------------------------------------------------------
	import sys
	print "This is the name of the script: ", sys.argv[0]    <= 1
	print "Number of arguments: ", len(sys.argv)			 <=3
	print "The arguments are: " , str(sys.argv)
	-------------------------------------------------------------
	Output:
	This is the name of the script:  sysargv.py
	Number of arguments in:  1
	The arguments are:  ['sysargv.py']

	If I run it again with additional arguments, I will get this output:

	This is the name of the script:  sysargv.py
	Number of arguments in:  3
	The arguments are:  ['sysargv.py', 'arg1', 'arg2']
	
### .rst file
	reStructuredText (sometimes abbreviated as RST, ReST, or reST) is a file format for textual data used 
	primarily in the Python programming language community for technical documentation.	
	
	
	

	
###################################	
### Python built-in functions   ###
###################################
Built-in Function	Description
abs()			Return the absolute value of a number.
all()			Return True if all elements of the iterable are true (or if the iterable is empty).
any()			Return True if any element of the iterable is true. If the iterable is empty, return False.
ascii()			Return a string containing a printable representation of an object, but escape the non-ASCII characters.
bin()			Convert an integer number to a binary string.
bool()			Convert a value to a Boolean.
bytearray()		Return a new array of bytes.
bytes()			Return a new "bytes" object.
callable()		Return True if the object argument appears callable, False if not.
chr()			Return the string representing a character.
classmethod()	Return a class method for the function.
compile()		Compile the source into a code or AST object.
complex()		Create a complex number or convert a string or number to a complex number.
delattr()		Deletes the named attribute of an object.
dict()			Create a new dictionary.
dir()			Return the list of names in the current local scope.
divmod()		Return a pair of numbers consisting of quotient and remainder when using integer division.
enumerate()		Return an enumerate object.
eval()			The argument is parsed and evaluated as a Python expression.
exec()			Dynamic execution of Python code.
filter()		Construct an iterator from elements of iterable for which function returns true.
float()			Convert a string or a number to floating point.
format()		Convert a value to a "formatted" representation.
frozenset()		Return a new frozenset object.
getattr()		Return the value of the named attribute of an object.
globals()		Return a dictionary representing the current global symbol table.
hasattr()		Return True if the name is one of the object's attributes.
hash()			Return the hash value of the object.
help()			Invoke the built-in help system.
hex()			Convert an integer number to a hexadecimal string.
id()			Return the "identity" of an object.
input()			Reads a line from input, converts it to a string (stripping a trailing newline), and returns that.
int()			Convert a number or string to an integer.
isinstance()	Return True if the object argument is an instance.
issubclass()	Return True if class is a subclass.
iter()			Return an iterator object.
len()			Return the length (the number of items) of an object.
list()			Return a list.
locals()		Update and return a dictionary representing the current local symbol table.
map()			Return an iterator that applies function to every item of iterable, yielding the results.
max()			Return the largest item in an iterable.
memoryview()	Return a "memory view" object created from the given argument.
min()			Return the smallest item in an iterable.
next()			Retrieve the next item from the iterator.
object()		Return a new featureless object.
oct()			Convert an integer number to an octal string.
open()			Open file and return a corresponding file object.
ord()			Return an integer representing the Unicode.
pow()			Return power raised to a number.
print()			Print objects to the stream.
property()		Return a property attribute.
range()			Return an iterable sequence.
repr()			Return a string containing a printable representation of an object.
reversed()		Return a reverse iterator.
round()			Return the rounded floating point value.
set()			Return a new set object.
setattr()		Assigns the value to the attribute.
slice()			Return a slice object.
sorted()		Return a new sorted list.
staticmethod()	Return a static method for function.
str()			Return a str version of object.
sum()			Sums the items of an iterable from left to right and returns the total.
super()			Return a proxy object that delegates method calls to a parent or sibling class.
tuple()			Return a tuple
type()			Return the type of an object.
vars()			Return the __dict__ attribute for a module, class, instance, or any other object.
zip()			Make an iterator that aggregates elements from each of the iterables.
__import__()	This function is invoked by the import statement.	
	
	
	
-----------------------------------------------
-----------------------------------------------
AWS CLOUDWATCH + Python + BOTO
-----------------------------------------------
-----------------------------------------------	

AWS CLOUDWATCH

# METRIC
http://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html
 A metric represents a time-ordered set of data points that are published to CloudWatch. 
 Think of a metric as a variable to monitor, and the data points represent the values of 
 that variable over time. For example, the CPU usage of a particular EC2 instance is one 
 metric provided by Amazon EC2. The data points themselves can come from any application 
 or business activity from which you collect data.
 
 
# Namespaces
	A namespace is a container for CloudWatch metrics. Metrics in different namespaces are 
	isolated from each other, so that metrics from different applications are not mistakenly 
	aggregated into the same statistics.
	
# Dimensions
	A dimension is a name/value pair that uniquely identifies a metric. You can assign up to 10 
	dimensions to a metric.

-----------------------------------------------		
	alarm_templates = [
    { 
        'name': alarm_prefix + " - Latency Spike",
        'description': "Latency Spike",
        'namespace': 'AWS/ELB',
        'metric': "Latency",
        'statistic': "Average",
        'comparison': '>=',
        'threshold': 6.5,
        'period': 60,
        'evaluation_periods': 5,
        'alarm_actions': [sns_topic],
        'dimensions': alarm_dimensions
    },
-----------------------------------------------		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	



---------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------

Question 1

What is Python really? 
	- Python is dynamically typed, this means that you don't need to state the types of variables when you declare them 
	  or anything like that. You can do things like x=111 and then x="I'm a string" without error
	-Python is well suited to object orientated programming in that it allows the definition of classes along 
	  with composition and inheritance. Python does not have access specifiers (like C++'s public, private), 
	  the justification for this point is given as "we are all adults here"
	- In Python, functions are first-class objects. This means that they can be assigned to variables, returned from 
	  other functions and passed into functions. Classes are also first class objects
	- Writing Python code is quick but running it is often slower than compiled languages. Fortunately，Python allows 
	  the inclusion of C based extensions so bottlenecks can be optimised away and often are. The numpy package is a 
	  good example of this, it's really quite quick because a lot of the number crunching it does isn't actually done 
	  by Python
	- Python finds use in many spheres - web applications, automation, scientific modelling, big data applications 
	  and many more. It's also often used as "glue" code to get other languages and components to play nice.
	- Python makes difficult things easy so programmers can focus on overriding algorithms and structures rather 
	  than nitty-gritty low level details.
	  
### Question 2

Fill in the missing code:
###
def print_directory_contents(sPath):
    """
    This function takes the name of a directory and prints out the paths files within that 
    directory as well as any files contained in contained directories. 

    This function is similar to os.walk. Please don't use os.walk in your answer. We are interested in your 
    ability to work with nested structures. 
    """
###
	### Answer ###
###
def print_directory_contents(sPath):
    import os                                       
    for sChild in os.listdir(sPath):                
        sChildPath = os.path.join(sPath,sChild)
        if os.path.isdir(sChildPath):
            print_directory_contents(sChildPath)
        else:
            print(sChildPath)
###			
			
Pay special attention
	- be consistent with your naming conventions. If there is a naming convention evident in any sample code, 
	  stick to it. Even if it is not the naming convention you usually use
	- recursive functions need to recurse and terminate. Make sure you understand how this happens so that 
	  you avoid bottomless callstacks
	- we use the os module for interacting with the operating system in a way that is cross platform. 
	  You could say sChildPath = sPath + '/' + sChild but that wouldn't work on windows
	- familiarity with base packages is really worthwhile, but don't break your head trying to memorize 
	  everything, Google is your friend in the workplace!
	- ask questions if you don't understand what the code is supposed to do
	- KISS! Keep it Simple, Stupid!
	Why this matters:
	displays knowledge of basic operating system interaction stuff
	recursion is hella useful
	
	
### Question 3

Looking at the below code, write down the final values of A0, A1, ...An.

A0 = dict(zip(('a','b','c','d','e'),(1,2,3,4,5)))
A1 = range(10)
A2 = sorted([i for i in A1 if i in A0])
A3 = sorted([A0[s] for s in A0])
A4 = [i for i in A1 if i in A3]
A5 = {i:i*i for i in A1}
A6 = [[i,i*i] for i in A1]
If you dont know what zip is don't stress out. No sane employer will expect you to memorize the standard library. Here is the output of help(zip).

zip(...)
    zip(seq1 [, seq2 [...]]) -> [(seq1[0], seq2[0] ...), (...)]

    Return a list of tuples, where each tuple contains the i-th element
    from each of the argument sequences.  The returned list is truncated
    in length to the length of the shortest argument sequence.
If that doesn't make sense then take a few minutes to figure it out however you choose to.

Answer

A0 = {'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4}  # the order may vary
A1 = range(0, 10) # or [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] in python 2
A2 = []
A3 = [1, 3, 2, 5, 4]
A4 = [1, 2, 3, 4, 5]
A5 = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
A6 = [[0, 0], [1, 1], [2, 4], [3, 9], [4, 16], [5, 25], [6, 36], [7, 49], [8, 64], [9, 81]]	
	
	
### Question 4

Python and multi-threading. Is it a good idea? List some ways to get some Python code to run in a parallel way.

	Python doesn't allow multi-threading in the truest sense of the word. It has a multi-threading package but 
	if you want to multi-thread to speed your code up, then it's usually not a good idea to use it. Python has 
	a construct called the Global Interpreter Lock (GIL). The GIL makes sure that only one of your 'threads' 
	can execute at any one time. A thread acquires the GIL, does a little work, then passes the GIL onto the 
	next thread. This happens very quickly so to the human eye it may seem like your threads are executing 
	in parallel, but they are really just taking turns using the same CPU core. All this GIL passing adds overhead 
	to execution. This means that if you want to make your code run faster then using the threading package often isn't a good idea.

	There are reasons to use Python's threading package. If you want to run some things simultaneously, and 
	efficiency is not a concern, then it's totally fine and convenient. Or if you are running code that needs 
	to wait for something (like some IO) then it could make a lot of sense. But the threading library wont let 
	you use extra CPU cores.

	Multi-threading can be outsourced to the operating system (by doing multi-processing), some external 
	application that calls your Python code (eg, Spark or Hadoop), or some code that your Python code calls 
	(eg: you could have your Python code call a C function that does the expensive multi-threaded stuff).

	Why this is important
	Because the GIL is an A-hole. Lots of people spend a lot of time trying to find bottlenecks in their 
	fancy Python multi-threaded code before they learn what the GIL is.	
	
	
	
### Question 6
What does this code output:
###
def f(x,l=[]):
    for i in range(x):
        l.append(i*i)
    print(l) 
f(2)
f(3,[3,2,1])
f(3)
###

Answer
[0, 1]
[3, 2, 1, 0, 1, 4]
[0, 1, 0, 1, 4]

	The first function call should be fairly obvious, the loop appends 0 and then 1 to the empty list, l. 
	l is a name for a variable that points to a list stored in memory. 
	The second call starts off by creating a new list in a new block of memory. l then refers to this new list. 
	It then appends 0, 1 and 4 to this new list. So that's great. 
	The third function call is the weird one. It uses the original list stored in the original memory block. 
	That is why it starts off with 0 and 1.

l_mem = []

# When f(2)
l = l_mem           # the first call
for i in range(2):
    l.append(i*i)
print(l)            # [0, 1]

# When f(3, [3,2,1])
l = [3,2,1]         # the second call
for i in range(3):
    l.append(i*i)
print(l)            # [3, 2, 1, 0, 1, 4]

# when f(3)
l = l_mem           # the third call
for i in range(3):
    l.append(i*i)
print(l)            # [0, 1, 0, 1, 4]	
	
	
	
### Question 7

What is "monkey patching" and is it ever a good idea?

	Monkey patching is changing the behaviour of a function or object after it has already been defined. 
	For example:

	import datetime
	datetime.datetime.now = lambda: datetime.datetime(2012, 12, 12)

	Most of the time it's a pretty terrible idea - it is usually best if things act in a well-defined way. 
	One reason to monkey patch would be in testing. The mock package is very useful to this end.

	Why does this matter?
	It shows that you understand a bit about methodologies in unit testing. Your mention of monkey avoidance 
	will show that you aren't one of those coders who favor fancy code over maintainable code .
	And it shows that you know a little bit about how Python works on a lower level, 
	how functions are actually stored and called and suchlike.
	
	
### Question 8

What does this stuff mean: *args, **kwargs? And why would we use it?
	Use *args when we aren't sure how many arguments are going to be passed to a function, or if we want 
	to pass a stored list or tuple of arguments to a function. **kwargs is used when we dont know how many 
	keyword arguments will be passed to a function, or it can be used to pass the values of a dictionary 
	as keyword arguments. The identifiers args and kwargs are a convention, you could also use *bob and 
	**billy but that would not be wise.

e.g.

def f(*args,**kwargs): print(args, kwargs)

l = [1,2,3]
t = (4,5,6)
d = {'a':7,'b':8,'c':9}

f()
f(1,2,3)                    # (1, 2, 3) {}
f(1,2,3,"groovy")           # (1, 2, 3, 'groovy') {}
f(a=1,b=2,c=3)              # () {'a': 1, 'c': 3, 'b': 2}
f(a=1,b=2,c=3,zzz="hi")     # () {'a': 1, 'c': 3, 'b': 2, 'zzz': 'hi'}
f(1,2,3,a=1,b=2,c=3)        # (1, 2, 3) {'a': 1, 'c': 3, 'b': 2}

f(*l,**d)                   # (1, 2, 3) {'a': 7, 'c': 9, 'b': 8}
f(*t,**d)                   # (4, 5, 6) {'a': 7, 'c': 9, 'b': 8}
f(1,2,*t)                   # (1, 2, 4, 5, 6) {}
f(q="winning",**d)          # () {'a': 7, 'q': 'winning', 'c': 9, 'b': 8}
f(1,2,*t,q="winning",**d)   # (1, 2, 4, 5, 6) {'a': 7, 'q': 'winning', 'c': 9, 'b': 8}

def f2(arg1,arg2,*args,**kwargs): print(arg1,arg2, args, kwargs)

f2(1,2,3)                       # 1 2 (3,) {}
f2(1,2,3,"groovy")              # 1 2 (3, 'groovy') {}
f2(arg1=1,arg2=2,c=3)           # 1 2 () {'c': 3}
f2(arg1=1,arg2=2,c=3,zzz="hi")  # 1 2 () {'c': 3, 'zzz': 'hi'}
f2(1,2,3,a=1,b=2,c=3)           # 1 2 (3,) {'a': 1, 'c': 3, 'b': 2}

f2(*l,**d)                   # 1 2 (3,) {'a': 7, 'c': 9, 'b': 8}
f2(*t,**d)                   # 4 5 (6,) {'a': 7, 'c': 9, 'b': 8}
f2(1,2,*t)                   # 1 2 (4, 5, 6) {}
f2(1,1,q="winning",**d)      # 1 1 () {'a': 7, 'q': 'winning', 'c': 9, 'b': 8}
f2(1,2,*t,q="winning",**d)   # 1 2 (4, 5, 6) {'a': 7, 'q': 'winning', 'c': 9, 'b': 8} 	
	
	NOte: Sometimes we will need to pass an unknown number of arguments or keyword arguments into a function. 
	Sometimes we will want to store arguments or keyword arguments for later use. Sometimes it's just a time saver.	
	
### Question 9
What do these mean to you: @classmethod, @staticmethod, @property?

	Answer Background knowledge
	These are decorators. A decorator is a special kind of function that either takes a function and returns 
	a function, or takes a class and returns a class. The @ symbol is just syntactic sugar that allows you 
	to decorate something in a way that's easy to read.
###
@my_decorator
def my_func(stuff):
    do_things
###   
   same as 
###
def my_func(stuff):
    do_things
my_func = my_decorator(my_func)
###

You can find a tutorial on how decorators in general work here.
https://www.codementor.io/python/tutorial/advanced-use-python-decorators-class-function

Actual Answer

The decorators @classmethod, @staticmethod and @property are used on functions defined within classes. Here is how they behave:

class MyClass(object):
    def __init__(self):
        self._some_property = "properties are nice"
        self._some_other_property = "VERY nice"
    def normal_method(*args,**kwargs):
        print("calling normal_method({0},{1})".format(args,kwargs))
    @classmethod
    def class_method(*args,**kwargs):
        print("calling class_method({0},{1})".format(args,kwargs))
    @staticmethod
    def static_method(*args,**kwargs):
        print("calling static_method({0},{1})".format(args,kwargs))
    @property
    def some_property(self,*args,**kwargs):
        print("calling some_property getter({0},{1},{2})".format(self,args,kwargs))
        return self._some_property
    @some_property.setter
    def some_property(self,*args,**kwargs):
        print("calling some_property setter({0},{1},{2})".format(self,args,kwargs))
        self._some_property = args[0]
    @property
    def some_other_property(self,*args,**kwargs):
        print("calling some_other_property getter({0},{1},{2})".format(self,args,kwargs))
        return self._some_other_property

o = MyClass()
# undecorated methods work like normal, they get the current instance (self) as the first argument

o.normal_method 
# <bound method MyClass.normal_method of <__main__.MyClass instance at 0x7fdd2537ea28>>

o.normal_method() 
# normal_method((<__main__.MyClass instance at 0x7fdd2537ea28>,),{})

o.normal_method(1,2,x=3,y=4) 
# normal_method((<__main__.MyClass instance at 0x7fdd2537ea28>, 1, 2),{'y': 4, 'x': 3})

# class methods always get the class as the first argument

o.class_method
# <bound method classobj.class_method of <class __main__.MyClass at 0x7fdd2536a390>>

o.class_method()
# class_method((<class __main__.MyClass at 0x7fdd2536a390>,),{})

o.class_method(1,2,x=3,y=4)
# class_method((<class __main__.MyClass at 0x7fdd2536a390>, 1, 2),{'y': 4, 'x': 3})

# static methods have no arguments except the ones you pass in when you call them

o.static_method
# <function static_method at 0x7fdd25375848>

o.static_method()
# static_method((),{})

o.static_method(1,2,x=3,y=4)
# static_method((1, 2),{'y': 4, 'x': 3})

# properties are a way of implementing getters and setters. It's an error to explicitly call them
# "read only" attributes can be specified by creating a getter without a setter (as in some_other_property)

o.some_property
# calling some_property getter(<__main__.MyClass instance at 0x7fb2b70877e8>,(),{})
# 'properties are nice'

o.some_property()
# calling some_property getter(<__main__.MyClass instance at 0x7fb2b70877e8>,(),{})
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: 'str' object is not callable

o.some_other_property
# calling some_other_property getter(<__main__.MyClass instance at 0x7fb2b70877e8>,(),{})
# 'VERY nice'

# o.some_other_property()
# calling some_other_property getter(<__main__.MyClass instance at 0x7fb2b70877e8>,(),{})
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: 'str' object is not callable

o.some_property = "groovy"
# calling some_property setter(<__main__.MyClass object at 0x7fb2b7077890>,('groovy',),{})

o.some_property
# calling some_property getter(<__main__.MyClass object at 0x7fb2b7077890>,(),{})
# 'groovy'

o.some_other_property = "very groovy"
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# AttributeError: can't set attribute

o.some_other_property
# calling some_other_property getter(<__main__.MyClass object at 0x7fb2b7077890>,(),{})
# 'VERY nice'
	
	
	
###	Question 10

Consider the following code, what will it output?

class A(object):
    def go(self):
        print("go A go!")
    def stop(self):
        print("stop A stop!")
    def pause(self):
        raise Exception("Not Implemented")

class B(A):
    def go(self):
        super(B, self).go()
        print("go B go!")

class C(A):
    def go(self):
        super(C, self).go()
        print("go C go!")
    def stop(self):
        super(C, self).stop()
        print("stop C stop!")

class D(B,C):
    def go(self):
        super(D, self).go()
        print("go D go!")
    def stop(self):
        super(D, self).stop()
        print("stop D stop!")
    def pause(self):
        print("wait D wait!")

class E(B,C): pass

a = A()
b = B()
c = C()
d = D()
e = E()

# specify output from here onwards

a.go()
b.go()
c.go()
d.go()
e.go()

a.stop()
b.stop()
c.stop()
d.stop()
e.stop()

a.pause()
b.pause()
c.pause()
d.pause()
e.pause()



Answer

The output is specified in the comments in the segment below:

a.go()
# go A go!

b.go()
# go A go!
# go B go!

c.go()
# go A go!
# go C go!

d.go()
# go A go!
# go C go!
# go B go!
# go D go!

e.go()
# go A go!
# go C go!
# go B go!

a.stop()
# stop A stop!

b.stop()
# stop A stop!

c.stop()
# stop A stop!
# stop C stop!

d.stop()
# stop A stop!
# stop C stop!
# stop D stop!

e.stop()
# stop A stop!

a.pause()
# ... Exception: Not Implemented

b.pause()
# ... Exception: Not Implemented

c.pause()
# ... Exception: Not Implemented

d.pause()
# wait D wait!

e.pause()
# ...Exception: Not Implemented

Why do we care?
	Because OO programming is really important. Answering this question shows your understanding of inheritance 
	and the use of Python's super function. Most of the time the order of resolution doesn't matter. 
	Sometimes it does, it depends on your application.


	
	
### Question 11

Consider the following code, what will it output?

class Node(object):
    def __init__(self,sName):
        self._lChildren = []
        self.sName = sName
    def __repr__(self):
        return "<Node '{}'>".format(self.sName)
    def append(self,*args,**kwargs):
        self._lChildren.append(*args,**kwargs)
    def print_all_1(self):
        print(self)
        for oChild in self._lChildren:
            oChild.print_all_1()
    def print_all_2(self):
        def gen(o):
            lAll = [o,]
            while lAll:
                oNext = lAll.pop(0)
                lAll.extend(oNext._lChildren)
                yield oNext
        for oNode in gen(self):
            print(oNode)

oRoot = Node("root")
oChild1 = Node("child1")
oChild2 = Node("child2")
oChild3 = Node("child3")
oChild4 = Node("child4")
oChild5 = Node("child5")
oChild6 = Node("child6")
oChild7 = Node("child7")
oChild8 = Node("child8")
oChild9 = Node("child9")
oChild10 = Node("child10")

oRoot.append(oChild1)
oRoot.append(oChild2)
oRoot.append(oChild3)
oChild1.append(oChild4)
oChild1.append(oChild5)
oChild2.append(oChild6)
oChild4.append(oChild7)
oChild3.append(oChild8)
oChild3.append(oChild9)
oChild6.append(oChild10)

# specify output from here onwards

oRoot.print_all_1()
oRoot.print_all_2()	
	
	
Answer

oRoot.print_all_1() prints:

<Node 'root'>
<Node 'child1'>
<Node 'child4'>
<Node 'child7'>
<Node 'child5'>
<Node 'child2'>
<Node 'child6'>
<Node 'child10'>
<Node 'child3'>
<Node 'child8'>
<Node 'child9'>
oRoot.print_all_2() prints:

<Node 'root'>
<Node 'child1'>
<Node 'child2'>
<Node 'child3'>
<Node 'child4'>
<Node 'child5'>
<Node 'child6'>
<Node 'child8'>
<Node 'child9'>
<Node 'child7'>
<Node 'child10'>


Why do we care?
	Because composition and object construction is what objects are all about. Objects are composed of stuff 
	and they need to be initialised somehow. This also ties up some stuff about recursion and use of generators.

	Generators are great. You could have achieved similar functionality to print_all_2 by just constructing 
	a big long list and then printing it's contents. One of the nice things about generators is that they 
	don't need to take up much space in memory.

	It is also worth pointing out that print_all_1 traverses the tree in a depth-first manner, while print_all_2 
	is width-first. Make sure you understand those terms. Sometimes one kind of traversal is more appropriate 
	than the other. But that depends very much on your application.	
	
	
### Question 12

Describe Python's garbage collection mechanism in brief.

	Python maintains a count of the number of references to each object in memory. If a reference count 
	goes to zero then the associated object is no longer live and the memory allocated to that object 
	can be freed up for something else occasionally things called "reference cycles" happen. 
	The garbage collector periodically looks for these and cleans them up. An example would be if you 
	have two objects o1 and o2 such that o1.x == o2 and o2.x == o1. If o1 and o2 are not referenced 
	by anything else then they shouldn't be live. But each of them has a reference count of 1.
	Certain heuristics are used to speed up garbage collection. For example, recently created objects 
	are more likely to be dead. As objects are created, the garbage collector assigns them to generations. 
	Each object gets one generation, and younger generations are dealt with first.
	This explanation is CPython specific.	
	
	
### Question 13

Place the following functions below in order of their efficiency. They all take in a list of numbers between 0 and 1. 
The list can be quite long. An example input list would be [random.random() for i in range(100000)]. 
How would you prove that your answer is correct?

def f1(lIn):
    l1 = sorted(lIn)
    l2 = [i for i in l1 if i<0.5]
    return [i*i for i in l2]

def f2(lIn):
    l1 = [i for i in lIn if i<0.5]
    l2 = sorted(l1)
    return [i*i for i in l2]

def f3(lIn):
    l1 = [i*i for i in lIn]
    l2 = sorted(l1)
    return [i for i in l1 if i<(0.5*0.5)]


	Most to least efficient: f2, f1, f3. To prove that this is the case, you would want to profile your code. 
	Python has a lovely profiling package that should do the trick.

import cProfile
lIn = [random.random() for i in range(100000)]
cProfile.run('f1(lIn)')
cProfile.run('f2(lIn)')
cProfile.run('f3(lIn)')
For completion's sake, here is what the above profile outputs:

>>> cProfile.run('f1(lIn)')
         4 function calls in 0.045 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.009    0.009    0.044    0.044 <stdin>:1(f1)
        1    0.001    0.001    0.045    0.045 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.035    0.035    0.035    0.035 {sorted}


>>> cProfile.run('f2(lIn)')
         4 function calls in 0.024 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.008    0.008    0.023    0.023 <stdin>:1(f2)
        1    0.001    0.001    0.024    0.024 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.016    0.016    0.016    0.016 {sorted}


>>> cProfile.run('f3(lIn)')
         4 function calls in 0.055 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.016    0.016    0.054    0.054 <stdin>:1(f3)
        1    0.001    0.001    0.055    0.055 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.038    0.038    0.038    0.038 {sorted}
	
	Note: Locating and avoiding bottlenecks is often pretty worthwhile. A lot of coding for efficiency 
	comes down to common sense - in the example above it's obviously quicker to sort a list if it's 
	a smaller list, so if you have the choice of filtering before a sort it's often a good idea. 
	The less obvious stuff can still be located through use of the proper tools. 
	It's good to know about these tools.	
	



1) What is Python? What are the benefits of using Python?
	Python is a programming language with objects, modules, threads, exceptions and automatic memory 
	management. The benefits of pythons are that it is simple and easy, portable, extensible, 
	build-in data structure and it is an open source.

2)  What is PEP 8?
	PEP 8 is a coding convention, a set of recommendation, about how to write your Python code more readable.

3) What is pickling and unpickling?
	Pickle module accepts any Python object and converts it into a string representation and dumps 
	it into a file by using dump function, this process is called pickling.  While the process 
	of retrieving original Python objects from the stored string representation is called unpickling.

4) How Python is interpreted?
	Python language is an interpreted language. Python program runs directly from the source code. 
	It converts the source code that is written by the programmer into an intermediate language, 
	which is again translated into machine language that has to be executed.

5) How memory is managed in Python?
	Python memory is managed by Python private heap space. All Python objects and data structures are 
	located in a private heap. The programmer does not have an access to this private heap and interpreter 
	takes care of this Python private heap.
	The allocation of Python heap space for Python objects is done by Python memory manager.  The core API 
	gives access to some tools for the programmer to code.
	Python also have an inbuilt garbage collector, which recycle all the unused memory and frees the 
	memory and makes it available to the heap space. 

6) What are the tools that help to find bugs or perform static analysis?
	PyChecker is a static analysis tool that detects the bugs in Python source code and warns about 
	the style and complexity of the bug. Pylint is another tool that verifies whether the module meets 
	the coding standard.

7) What are Python decorators?
	A Python decorator is a specific change that we make in Python syntax to alter functions easily.

8) What is the difference between list and tuple?
	The difference between list and tuple is that list is mutable while tuple is not. Tuple can be 
	hashed for e.g as a key for dictionaries.

9) How are arguments passed by value or by reference?
	Everything in Python is an object and all variables hold references to the objects. 
	The references values are according to the functions; as a result you cannot change the value 
	of the references. However, you can change the objects if it is mutable.

10) What is Dict and List comprehensions are?
	They are syntax constructions to ease the creation of a Dictionary {key:value}
	or List [...]based on existing iterable.

11) What are the built-in type does python provides?
	There are Mutable and Immutable types of Pythons built in types 
	Mutable built-in types	- List, Sets, Dictionaries, 
	Immutable built-in types - Strings, Tuples, Numbers

12) What is namespace in Python?
	In Python, every name introduced has a place where it lives and can be hooked for. 
	This is known as namespace. It is like a box where a variable name is mapped to the object placed.  
	Whenever the variable is searched out, this box will be searched, to get corresponding object.

13) What is lambda in Python?
	It is a single expression anonymous function often used as inline function.

14) Why lambda forms in python does not have statements?
	A lambda form in python does not have statements as it is used to make new function object and 
	then return them at runtime.

15) What is pass in Python?
	Pass means, no-operation Python statement, or in other words it is a place holder in compound 
	statement, where there should be a blank left and nothing has to be written there.

16) In Python what are iterators?
	In Python, iterators are used to iterate a group of elements, containers like list.

17) What is unittest in Python?
	A unit testing framework in Python is known as unittest.  It supports sharing of setups, 
	automation testing, shutdown code for tests, aggregation of tests into collections etc.

18) In Python what is slicing?
	A mechanism to select a range of items from sequence types like list, tuple, strings etc. is known as slicing.

19) What are generators in Python?
	The way of implementing iterators are known as generators.  It is a normal function except 
	that it yields expression in the function.

20) What is docstring in Python?
	A Python documentation string is known as docstring, it is a way of documenting Python functions, 
	modules and classes.

21)  How can you copy an object in Python?
	To copy an object in Python, you can try copy.copy () or copy.deepcopy() for the general case. 
	You cannot copy all objects but most of them.

22) What is negative index in Python?
	Python sequences can be index in positive and negative numbers.   For positive index, 0 is the first index, 
	1 is the second index and so forth.  For negative index, (-1) is the last index and (-2) is the second last 
	index and so forth.

23) How you can convert a number to a string?
	In order to convert a number into a string, use the inbuilt function str(). 
	If you want a octal or hexadecimal representation, use the inbuilt function oct() or hex().

24) What is the difference between Xrange and range?
	Xrange returns the xrange object while range returns the list, and uses the same memory and 
	no matter what the range size is.

25) What is module and package in Python?
	The module is the way to structure program. Each Python program file is a module, which 
	imports other modules like objects and attributes.
	The folder of Python program is a package of modules.  A package can have modules or subfolders.

26) Mention what are the rules for local and global variables in Python?
	local variables: If a variable is assigned a new value anywhere within the function’s body, 
	it’s assumed to be local.
	Global variables: Those variables that are only referenced inside a function are implicitly global.

27) How can you share global variables across modules?
	To share global variables across modules within a single program, create a special module. 
	Import the config module in all modules of your application. The module will be available as a 
	global variable across modules.

28) Explain how can you make a Python Script executable on Unix?
	To make a Python Script executable on Unix, you need to do two things, Script file’s mode must be 
	executable and the first line must begin with (#!/usr/bin/env python)

29) Explain how to delete a file in Python?
	By using a command os.remove (filename) or os.unlink(filename)

30) Explain how can you generate random numbers in Python?
	To generate random numbers in Python, you need to import command as
	import random
	random.random()
	This returns a random floating point number in the range [0,1)

31) Explain how can you access a module written in Python from C?
	You can access a module written in Python from C by following method,
	Module =  =PyImport_ImportModule(“<modulename>”);

32) Mention the use of // operator in Python?
	It is a Floor Division operator, which is used for dividing two operands with the result as quotient 
	showing only digits before the decimal point. For instance, 10//3 = 3 and 10.0//3.0 = 3.0.

33) Mention five benefits of using Python?
	1.Python comprises of a huge standard library for most Internet platforms like Email, HTML, etc.
	2.Python does not require explicit memory management as the interpreter itself allocates 
		the memory to new variables and free them automatically
	3.Provide easy readability due to use of square brackets
	4.Easy-to-learn for beginners
	4.Having the built-in data types saves programming time and effort from declaring variables.
	
34) Mention the use of the split function in Python?
	The use of the split() function in Python is that it breaks a string into shorter strings using the 
	defined separator. It gives a list of all words present in the string.	
	x = ‘blue,red,green’
	x.split(“,”)
	[‘blue’, ‘red’, ‘green’]
	
	>>> s = 'AGGCATGCATGCAT'
	>>> s[0:3]
	'AGG'
	>>> [s[i:i+3] for i in range(0,len(s),3)]   <<<***
	['AGG', 'CAT', 'GCA', 'TGC', 'AT']
	

27) How can you copy objects in Python?
	The functions used to copy objects in Python are-
	1) Copy.copy () for shallow copy
	2) Copy.deepcopy () for deep copy

	However, it is not possible to copy all objects in Python using these functions.  
	For instance, dictionaries have a separate copy method whereas sequences in Python have to be copied by ‘Slicing’.

30) Is all the memory freed when Python exits?
	No it is not, because the objects that are referenced from global namespaces of Python modules are 
	not always de-allocated when Python exits.

31) What does _init_.py do?
	_init_.py is an empty py file used for importing a module in a directory. 
	_init_.py provides an easy way to organize the files. If there is a module 
	maindir/subdir/module.py,_init_.py is placed in all the directories so that the 
	module can be imported using the following command-
	import  maindir.subdir.module

32) What is the different between range () and xrange () functions in Python?
	range() returns a "list" whereas 
	xrange() returns an "object" that acts like an iterator for generating numbers on demand.

33) How can you randomize the items of a list in place in Python?
	Shuffle (lst) can be used for randomizing the items of a list in Python

34) What is a pass in Python?
	Pass in Python signifies a no operation statement indicating that nothing is to be done.

35) If you are gives the first and last names of employees, which data type in Python will you use to store them?
	You can use a list that has first name and last name included in an element or use Dictionary.

36) What happens when you execute the statement mango=banana in Python?
	A name error will occur when this statement is executed in Python.

37) Write a sorting algorithm for a numerical dataset in Python. 

38) Optimize the below python code-
	word = 'word'
	print word.__len__()
	
	Answer: print ‘word’._len_()

39) What is monkey patching in Python?
	Monkey patching is a technique that helps the programmer to modify or extend other code at runtime. 
	Monkey patching comes handy in testing but it is not a good practice to use it in production environment 
	as debugging the code could become difficult.

40) Which tool in Python will you use to find bugs if any?
	Pylint verifies that a module satisfies all the coding standards or not. 
	Pychecker is a static analysis tool that helps find out bugs in the course code.

 41) How are arguments passed in Python- by reference or by value?
	The answer to this question is neither of these because passing semantics in Python are completely different. 
	In all cases, Python passes arguments by value where all values are references to objects.

42) You are given a list of N numbers. Create a single list comprehension in Python to create a new list that 
	contains only those values which have even numbers from elements of the list at even indices. 
	For instance if list[4] has an even value the it has be included in the new output list because 
	it has an even index but if list[5] has an even value it should not be included in the list because 
	it is not at an even index.
	[x for x in list [: 2] if x%2 == 0]

	The above code will take all the numbers present at even indices and then discard the odd numbers.

43) Explain the usage of decorators.
	Decorators in Python are used to modify or inject code in functions or classes. Using decorators, 
	you can wrap a class or function method call so that a piece of code can be executed before or after 
	the execution of the original code. Decorators can be used to check for permissions, modify or track 
	the arguments passed to a method, logging the calls to a specific method, etc.

44) How can you check whether a pandas data frame is empty or not?
	The attribute df.empty is used to check whether a data frame is empty or not.

45) What will be the output of the below Python code –
	def multipliers ():
    return [lambda x: i * x for i in range (4)]
    print [m (2) for m in multipliers ()]

	The output for the above code will be [6, 6,6,6]. The reason for this is that because of late binding 
	the value of the variable i is looked up when any of the functions returned by multipliers are called.

46) What do you mean by list comprehension?
	The process of creating a list while performing some operation on the data so that it can be accessed using an iterator is referred to as List Comprehension.
	Example:
	[ord (j) for j in string.ascii_uppercase]
    [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90]

47) What will be the output of the below code

	word = ‘aeioubcdfg'
	print word [:3] + word [3:]

	The output for the above code will be: ‘aeioubcdfg'.
	In string slicing when the indices of both the slices collide and a “+” operator is applied on the string 
	it concatenates them.

48) list= [‘a’,’e’,’i’,’o’,’u’]
	print list [8:]

	The output for the above code will be an empty list []. Most of the people might confuse the answer with an 
	index error because the code is attempting to access a member in the list whose index exceeds the total number 
	of members in the list. The reason being the code is trying to access the slice of a list at a starting index 
	which is greater than the number of members in the list.

49) What will be the output of the below code:

def foo(i= []):
	#print(i)		<=hint
    i.append (1)
    return i

foo()
foo()
foo() 
The output for the above code will be
[1]
[1, 1]
[1, 1, 1]
	Argument to the function foo is evaluated only once when the function is defined. 
	However, since it is a list, on every all the list is modified by appending a 1 to it.
-----------------------------------------------
# How and why get 24???
def foo(i):
	#print(i)					<=Hint
    if i == 1:
        return 1
    else:
        return i * foo(i - 1)

foo(4)
>>>-----------------------------------------------
4
3
2
1
-----------------------------------------------


50) Can the lambda forms in Python contain statements?

	No, as their syntax is restricted to single expressions and they are used for creating 
	function objects which are returned at runtime.

	This list of questions for Python interview questions and answers is not an exhaustive one and will 
	continue to be a work in progress. Let us know in comments below if we missed out on any important 
	question that needs to be up here.
	
	
	
----------------------------------------------------------------------------------------------	
	
# Reverse Array	
https://stackoverflow.com/questions/3940128/how-can-i-reverse-a-list-in-python

def reverse_in_place(lst):      # Declare a function
    size = len(lst)             # Get the length of the sequence
    hiindex = size - 1
    its = size/2                # Number of iterations required
    for i in xrange(0, its):    # i is the low index pointer
        temp = lst[hiindex]     # Perform a classic swap
        lst[hiindex] = lst[i]
        lst[i] = temp
        hiindex -= 1            # Decrement the high index pointer
    print "Done!"

# Now test it!!
array = [2, 5, 8, 9, 12, 19, 25, 27, 32, 60, 65, 1, 7, 24, 124, 654]

print array                    # Print the original sequence
reverse_in_place(array)        # Call the function passing the list
print array                    # Print reversed list


**The result:**
[2, 5, 8, 9, 12, 19, 25, 27, 32, 60, 65, 1, 7, 24, 124, 654]
Done!
[654, 124, 24, 7, 1, 65, 60, 32, 27, 25, 19, 12, 9, 8, 5, 2]	
----------------------------------------------------------------------------------------------
	
	
for n in range(5):
...   num_list=range(n+1)
...   print “current num_list: “,num_list
...   new_list=num_list[len(num_list)/2::-1] + num_list[len(num_list)/2+1::]
...   print “new_list is: “,new_list 	
	
	
	
	
	
	
	
	
	
	
	




















































































 









































 









































 









































 









































 









































 









































 









































 









































 









































 









































 