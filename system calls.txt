Unix System Calls

http://codeschool.org/
https://www.youtube.com/watch?v=xHu7qI1gDPA  (1/2)
https://www.youtube.com/watch?v=2DrjQBL5FMU	 (2/2)

System calls are functions that a programmer can call to perform the services of 
the operating system.

1. Process Control 
	(http://www.softpanorama.org/Internals/System_calls/processes_control.shtml )
	load
	execute
	create process (fork)
	terminate process
	get/set process attributes
	wait for time, wait event, signal event
	allocate, free memory
	
2. File management
	create file, delete file
	open, close, check status of file descriptors (select )
	read, write, reposition
	get/set file attributes; get information about inode  (Stat)
	Commit data to disk (sync)
	
3. Device Management
	request device, release device
	read, write, reposition
	get/set device attributes
	logically attach or detach devices
	execute device specific operation (ioctl)
	
4. Information Maintenance
	get/set time or date
	get/set system data
	get/set process, file, or device attributes
	
5. Communication
	create, delete communication connection
	send, receive messages
	transfer status information
	attach or detach remote devices


#--------------------------------------------------------------------------------------
 -----------------------
|	Kernel code			|
|-----------------------|
|	stack				|		<- starts empty, grows automatically
|-----------------------|
|	heap				|
|	heap				|		<- explicitly allocated during execution
|-----------------------|
|	uninitialized data	|		<- global variables without initial values
|	initialized data	|		<- global variables with initial values
|-----------------------|		<- global variables with initial values
|	code				|		<- a.k.a the "text"
 -----------------------


- process:
	address space					| Stack	|
	user ids						| heap	|
	file descriptors				| heap	|	
	environment						| code	|
	current and root dir
	
- files
- networking sockets			( talk to other program sockets)
- signals						( OS to process)
- inter-process communication	( process to communicate one another)
- terminals						( cmd shell)
- threads						( 
- I/O devices					( storage devices, vga, key/mouse, etc)

e.g. languages
# C
	ssize_t read(int fd, void *buf, size_t count);
# Python
	read(fd)

	
mmap 	<- 'memory map' pages to the process address space
munmap 	<- opposit

address = mmap(5000)
... # do stuff with memory at address
nunmap(address)


mmap fails when NOT enough space if HEAP is too big

### Garbage Collection
 

new process
# FORK
if fork() == 0:							<- ***copy only MEMORY TABLE, Not actual files
	.. //new (child) process
else:
	... // original (parent) process

	# FORK	
	stack	->		RAM		->	fork	-> stack
	heap	->		RAM		->	fork	-> heap
	heap 	->		RAM		->	fork	-> heap
	code	->		RAM		->	fork	-> code
	
# EXEC
	executable --> CODE  load a new program

if fork() == 0:							
	.. //new (child) process
	exec('/games/pong')
else:
	... // original (parent) process

				pid 1 ( init), user 0
			/            \
	pid 2,user 3		pid 3, user 5
	/ 			\			\
pid 4, user id  pid 8  		pid6. user ID
								\
								pid 10, user ID

# Terminate the process
	_exit	
	_exit(0)    <- exit code

# WAIT (Block the process until child process terminates)
	pid = fork()
	if pid == 0:
		// new (child) process
		exec('/games/pong')
	else:
		// original (parent) process
		code = wait(pid)
		
# Environment variables		
	#name=value
TERM=xterm
SHELL=/bin/bash		
USER=greys
MAIL=/var/mail/ted
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin
PWD=/home/ted
EDITOR=vi

# USER ID
User owns the process 

# User account
	/etc/passwd
	superuser/root = user id 0
	privileged to d anything it wants

	echo process has thress user ids:
	"REAL" id: the owning user
	"EFFECTIVE" id: determines privileges
	"SAVED" id: set by exec to match the effective id

	each file and directory is owned by a single user

exec : sets effective and saved IDs when binary file has setuid bit
	
seteuid : sets effective user id

setuid	: sets real, effective, and saved user ids

non-supersuser can only directly set effective id to match the real or saved id.



# When Unix system starts with user account

PID 1(init), user 0		| 
	|					V   fork, exec
pid 2(login), user 0
	|					|	for, setuid, exec
pid 3(shell), user 1780 V

# user groups 
	/etc/group
	- user may belong to multiple groups but has one "primary" group
	- each file and directory is owned by one group
	- each process has a real, effective, and saved group ID
	- binary files have setgid bit
	- setegid and setgid
	

#  9 Permissions
	RWX	 	RWX		RWX
	user 	group 	other

if file_user_id == effective_user_id:
	user class
else if file_group_id == effetive_group_id:
	group class
else:
	other

	# File permission
	read:    can read bytes of files
	write:   can modify bytes of files
	execute: can exec file

	# Directory Permission
	read:    can get names of files
	write:   can add/remove/rename files
	execute: can use in file paths


open  : open/create a file and return a file descriptor
close : release file descriptor
read  : copy bytes from a file to memory (blocks)
write : copy bytes of memory to a file (blocks)

# Syscall WRITE
				Process		  -- |
			 ---------------	 |
			| Write Buffer  | <<-         <- process don't need to wait to write
	HDD	<-	| 		OS      |
			 ---------------

f = open('/alice/tim')
write(f, 'bla, bla')
write(f, 'bla, bla, bla')
close(f)


# Syscall READ
				Process		  <<-|
			 ---------------	 |
	HDD	->	| Read  Buffer   | --         <- process don't need to wait to read
			|OS data and code|
			 ---------------

f = ('/alice/tim')
data = read(f)
close(f)


f = open('/alice/tim')
data = read(f)
while len(data) != 0:
	print(data)
	data = read(f)
close(f)


		marker
		   |
	--------------------------------
	|								|
	byte 0						late byte

								marker
									|
	--------------------------------
	|								|
	byte 0						late byte
	
	Move with Truncate
    Move with lseek
--------------------------------	
descriptor
		\
		description
				\
				buffer
					\
					file on disk
--------------------------------	
	f = open('/alice/tim')
	f2 = open ('/alice/tim')
	write(f, 'bla bla')
	data = read(f2)


pid 75 write 'test'		pid 442 read
	\					/
----------------------------------------	
|       |				|				|
byte 0  pid 580 write  pid46 write  last byte
		'bla bla'

	
# umask	
	get/set default permissions for new files/directories
	oldmask = umask(newmask)
	f = open('/alice/tim')
	write(f, 'bla bla')

# chmod
	change mode: set permissions of an existing file/directory
	chmod('/alice/tim', mask)

# chown
	change owner: set owner of an existing file/directory)
	chown('/alice/tim', user, group)
	
	
### Directories
HD1: partition 1, partition 2, partition 3
HD2: partition 4
SD : partition 5
CD : partition 6, partition 7
	
inode number
	each file and directory in a PARTITION is known by unique inode number
	inode 0		<- no pointer for absent
	inode 1 	<- tracking and keeping of bad section
	inode 2 	<- root directory

An inode is an entry in inode table, containing information ( the metadata ) about 
a regular file and directory


# mkdir
# rmdir


# link  
	add directory entry
	link('/alice/ian', '/ben/jill')
# unlink
	unlink('/alice/ian')
	
# getdents
	get directory entries
	
	f = open('/alice')
	entries = getdents(f)
	while len(entries) !=0:
		print(entries)
		entries = getdents(f)
	close(f)
	
### Directories
HD1: /alice/tim
HD2: /
SD : /tim/jim
FD : /jess

# mount
# umount

# Absolute path vs relative path

# chdir
	chdir('/ben/ian')
	f = open('/alice/tim')
	f2 = open('alice/tim')

# regular file
# directory
# symbolic link
# character device file <- network card, flow in & out
# block device file  	<- storage, e.g. HDD 
# pipe  	- communications 
# socket 	- cross networks


# Partition composed of blocks
--------
block 0
block 1 inode 86
block 2 inode 86    <--> block buffer <--> read/write
block 3		<- a block may only read/written as a whole
.....
block 512
---------

# block device file  
block 0		<- byte 0
block 1
block 2
block 3
block ...     <- last byte

# character device  (buffers)

		<-read		|input buffer |     <- input	
process									    		device
		write ->	|output buffer |	output ->

		
# FIFOs 
	permanent objects and can be created using the mkfifo(1) or mknod(1) command. 
	Inside the program, the FIFO can be created using the mknod command, 
	then opened and read from or written to just like a normal file. 
	The FIFO is normally in blocking mode when attempting to perform read operations.
	
	FIFO( input/output buffers(first in, first out)
							write appends data here	
							|
 input buffer |DDDDDDDDDDDDDD_________________|
			   |
			   device takes data starting here
	
		Block device buffers backed by Storage (HDD)
		Character device buffers not backed by storage
			   
# /dev  directory of device files
	bf = open('/dev/sda1')
	cf = open('/dev/lp0')     <- lp0 printer
	lseek(bf, 100)
	bdata = read(bf)
	cdata = read(cf)
	
# pseudo-device files
	/dev/zero		<- returns zeroed bytes
	/dev/random		<- returns random data
	/dev/null
	
	
# PIPE (a FIFO as a file)

		  <-read	|FIFO|  <- Write	
process	A							  Process B
		  write ->	|FIFO|	read ->

# mknode 
	make node: create a regular file, device file, or named pipe
	
	mknod('/ryan/kim', BLOCK, deviceNum)
	mknod('/ryan/erin', CHR, deviceNum)
	mknod('/ryan/tina', FIFO)
	
# pipe 
	creates a new, anonymouse pipe and returns two file descriptors
	fs = pipe()
	f1 = fs[0]
	f2 = fs[1]
	
# memory-mapped files

	kernel code
	stack
	heap					/ byte n
	mmap'd file		 <- file
	code					\ byte 0


f = open('/brad/mike')
address = mmap(500, f, 200)
... # reading/writeing the allocated memory reads/writes the file
munmap(address)
close(f)

### Signals
	signals are sent by KERNEL
	
	The receiving process
	- performs a default action
	- invokes a handler function
	- blocks it
	- ignores it

	4 types
		SIGSEGV
		SIGFPE
		SIGSTOP
		SIGCONT
	
Signal Name	Number	Description
SIGHUP	1	Hangup (POSIX)
SIGINT	2	Terminal interrupt (ANSI)
SIGQUIT	3	Terminal quit (POSIX)
SIGILL	4	Illegal instruction (ANSI)
SIGTRAP	5	Trace trap (POSIX)
SIGIOT	6	IOT Trap (4.2 BSD)
SIGBUS	7	BUS error (4.2 BSD)
SIGFPE	8	Floating point exception (ANSI)
SIGKILL	9	Kill(can't be caught or ignored) (POSIX)
SIGUSR1	10	User defined signal 1 (POSIX)
SIGSEGV	11	Invalid memory segment access (ANSI)
SIGUSR2	12	User defined signal 2 (POSIX)
SIGPIPE	13	Write on a pipe with no reader, Broken pipe (POSIX)
SIGALRM	14	Alarm clock (POSIX)
SIGTERM	15	Termination (ANSI)
SIGSTKFLT	16	Stack fault
SIGCHLD	17	Child process has stopped or exited, changed (POSIX)
SIGCONT	18	Continue executing, if stopped (POSIX)
SIGSTOP	19	Stop executing(can't be caught or ignored) (POSIX)
SIGTSTP	20	Terminal stop signal (POSIX)
SIGTTIN	21	Background process trying to read, from TTY (POSIX)
SIGTTOU	22	Background process trying to write, to TTY (POSIX)
SIGURG	23	Urgent condition on socket (4.2 BSD)
SIGXCPU	24	CPU limit exceeded (4.2 BSD)
SIGXFSZ	25	File size limit exceeded (4.2 BSD)
SIGVTALRM	26	Virtual alarm clock (4.2 BSD)
SIGPROF	27	Profiling alarm clock (4.2 BSD)
SIGWINCH	28	Window size change (4.3 BSD, Sun)
SIGIO	29	I/O now possible (4.2 BSD)
SIGPWR	30	Power failure restart (System V)

# kill
	send a signal to a process
# signal
	set a signal to be handled, ignored, or trigger its default action
	kill (35, SIGSTOP)
	signal(func, SIGFPE)
	
	















