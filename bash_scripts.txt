----------------------------------------------------------------------------------------
###  Bash Shell Scripting ###
----------------------------------------------------------------------------------------
"한 줄의 코딩을 하더라도 실제로 사용할 수 있는 것을 만들자!"
https://mywiki.wooledge.org/BashGuide/Parameters

https://explainshell.com/
https://www.shellcheck.net/

----------------------------------------------------------------------------------------
# Special Characters Names(https://www.owasp.org/index.php/Password_special_characters)
----------------------------------------------------------------------------------------
(	<= Parenthesis
{ 	<= Brace
| 	<= Vertical bar
[	<= Bracket
_	<= Undercore
:	<= Colon
;	<= Semicolon
-	<= Hyphen
*	<= Asterisk
^	<= Caret[캐릿]
~	<= Tilde[틸더]
`	<= Backtic
----------------------------------------------------------------------------------------
# Commenting (http://tldp.org/LDP/abs/html/special-chars.html)
----------------------------------------------------------------------------------------
	$ echo "The # here does not begin a comment."			<= " " prints out as character
	$ echo 'The # here does not begin a comment.'			<= ' ' prints out as is #, $, etc..
	$ echo The \# here does not begin a comment.			<= \ ignore # comment
	$ echo The  # here begins a comment.					<= No Quote, # after wards become comment
	  => The												

	$ echo -e "This is 1st line.\n\tThis is 2nd line.\n\t\tThis is 3rd line."
	  This is 1st line.
          This is 2nd line.
              This is 3rd line 

----------------------------------------------------------------------------------------
# Debugging options
----------------------------------------------------------------------------------------
'Set' or 'unset' values of shell options and positional parameters.
----------------------------------------------------------------------------------------	
  $ help set
----------------------------------------------------------------------------------------
	set -xeu		<= x<-틀린(debug) eu<-이유(exit,undefine vars)를 알아야 고친다
	
	set -ex         # Do both for good practice 
	Set +ex  		<= Unset debug
	
	set -e          # Exit as soon as any line in the bash script fails
	set -x          # Prints each command executed (prefix with ++)

	set -f	(set -o noglob)		Disable file name generation using metacharacters(globbing).
	set -v	(set -o verbose)	Prints shell input lines as they are read.
	set -x	(set -o xtrace)		Print command traces before executing command.
	
	set -u 			<= checks undefined variables
----------------------------------------------------------------------------------------	
  # Run in Debugging and Verbose mode
----------------------------------------------------------------------------------------
    $ sh -x script.sh   			 <= -x 	for debugging mode from Shell
    $ sh +x script.sh   			 <= +x 	Disabling debugging mode
	
	$ bash -x script.sh   			 <= -x 	for debugging mode from Shell
	
    $ sh -v script.sh   			 <= -v 	for Verbose mode Shell
    $ sh +v script.sh   			 <= +v 	Disabling the  Verbose mode
	--------------------------------------------------------------------
	e.g. in a script, add 'set -x' for each line output(debug mode)
	--------------------------------------------------------------------
	#!/bin/bash
	set -x			<= debug mode tracing
	set -u 			<= checks Undefined variables
	
	$ ls -Al | tee -a output.file 			<= 'tee -a' append - A <- removed . & ..

-------------------------------------------------------------------- 
# Syntex error only
https://stackoverflow.com/questions/171924/how-do-i-syntax-check-a-bash-script-without-running-it
--------------------------------------------------------------------
$ bash -n script.sh					    <= prints out Syntex error only
$ sh -n   script.sh						<= prints out Syntex error only
--------------------------------------------------------------------

--------------------------------------------------------------------
# Shell Checker <<<=== Excellent!!! ###
--------------------------------------------------------------------
	https://github.com/koalaman/shellcheck#user-content-installing
	$ yum -y install epel-release
	$ yum install ShellCheck         <= Cap 'S' and 'C'
	
	### Example:
	$ shellcheck script.sh
	
	
	
	--------------------------------------------------------------
	$ vi find_pid.sh
	--------------------------------------------------------------
	#!/bin/bash
	a=1
	echo my PID is $$
	set +x						# Turn off the tracing
	b=2							# no out put for variable 'b'
	set -xu						# Turn on
	echo a is $a b is $b c is $c
		
	$ bash find_pid.sh
		+ a=1					<=+ is debug
		+ echo my PID is 1316
		my PID is 1316
		+ set +x
		find_pid.sh: line 9: c: unbound variable   <= set -u report

	-----------------------------------------------------------------------------------							
    #!/bin/bash -x 					<= add " -x " for debugging mode in #!/bin/bash script
    $ bash -x ./script.sh  			( same as 'bash script.sh') 
    $ bash -vx script.sh			<= add -xv from shell -v <-verbose -x <-debug
	
	# Run a script with Debug mode within VI 
	:! sh -x %						<= -x is for DEBUG(verbose) mode
    set +x              			<= End of file +x for TURN OFF
	
	$ bash -n ./script.sh 			<= checking syntax error
	
----------------------------------------------------------------------------------------
# How to run a script
----------------------------------------------------------------------------------------
  # Change permission before run a script ###
----------------------------------------------------------------------------------------
	$ chmod + x	      script.sh		<= x run 
	$ chmod u + x	  script.sh		<= u only user   
	
----------------------------------------------------------------------------------------	
  # Bash Version 
----------------------------------------------------------------------------------------	
	$ bash -version 
	$ echo $BASH_VERSION 	

----------------------------------------------------------------------------------------
# Script Run
----------------------------------------------------------------------------------------
	$ bash 		script.sh			 <= No Need to change 'chmod +x'
	$ bash 	  ./script.sh
	$   	  ./script.sh			 <= run in Separate shell
	
	$ scource   script.sh   		 <= current login shell to run
			.   script.sh   		 <= . is same as source
	$ 		. ./script.sh   		 <= current login shell to run

    $ sh   script.sh  				
    $ sh ./script.sh  				 <= same as 'sh script.sh')

    $ exec ./script   				 <= after it runs, EXIT from current shell 


----------------------------------------------------------------------------------------
# source command( run in CURRENT SHELL)
----------------------------------------------------------------------------------------
	$ source script.sh
	$ source .bashrc		 		<= reload .bashrc in CURRENT SHELL
	$ . script.sh					<= '.' is same as source
										Execute commands from a file in the current shell.
----------------------------------------------------------------------------------------	
# run a script as a different user from root
----------------------------------------------------------------------------------------
	$ wget http://tecmint.com/wp-content/scripts/tecmint_monitor.sh
	$ su -c "/home/apark/tecmint_monitor.sh" - root
	$ ./tecmint_monitor.sh -i    					<= install
	$ monitor


----------------------------------------------------------------------------------------	
# VI: Run a script 'Within' VIM or VI
----------------------------------------------------------------------------------------
    :w   	      					<= write first
    :! sh %                  		<= : <-cmd, ! <-run, sh <-shell, % =currently open file
    # :!sh %						# works too
    
    # Same as Shell '!!' Repeating command
	:!!         					<= run same script again(Error: No Previous Command)
    
    :!./script_name.sh

    :! python %

    :! perl %

----------------------------------------------------------------------------------------
# VI - Save READ-ONLY file
----------------------------------------------------------------------------------------
  # Save the 'read only' file for under privilege error
	
	:w !sudo tee %                  	<= save as sudo privilege.  
										   type (L) load at the prompt to reload.
	
	:w !chmod 777 %       				<= Change mod 777

----------------------------------------------------------------------------------------
# VI - Short Keys 
----------------------------------------------------------------------------------------
  # Move	
	^		<= Move cursor to the beginning of the line.
	$		<= Move cursor to the end of the current line.
	
	H | L 	<= go to TOP of page
	G 		<= go to BOTTOM of page
	E		<= End of Word
	w		<= Next Word
	
	
 # Save and Exit
	ESC :wq     enter
	ESC Shift + ZZ			<=Cap ZZ
	
  # Insert
	Shift + A	
	o					<= insert underneath line
	i					<= insert
	a
	A
	
  # Go to
	:15					<= go to 15th line
	$ vi +15 script.sh
	G 					<= go to bottom of page
	o					<= insert underneath line

  # Undo & Redo
	Esc + u
	Ctrl + r

  # Help
	:h									<= vi, vim help 			
	:q 									<= quit help page
	
  # Go to line
	$ vi +101 file.txt					<= go to 101 line in file name
	:12									<= Go to particular line number in vi editor 
	
----------------------------------------------------------------------------------------
# VI: Search and replace 	( http://vim.wikia.com/wiki/Search_and_replace )
----------------------------------------------------------------------------------------
    :s/foo/bar/g					<= current line only
	:%s/foo/bar/gc					<= % -all, c - to confirm first but also INSENSITVE
	#:%s/foo/bar/gci				<= i insensitive(save as above cmd)
	
	:%s/\<foo\>/bar/gc				<= Change only whole words exactly matching 'foo' to 'bar'
	
	# blank line delete
	:g/^$/d							<= :g will execute a command on lines which match a regex. 
										The regex is 'blank line'  
										:d (delete)
										


									
---------------------------------------------------
# Writing 2 Scripts at same time in background
---------------------------------------------------
	$ vi 1st.sh
  ## Ctrl + z 						<= exit to shell
	$ vi 2nd.sh
  ## Ctrl + z 						<= exit to shell	

 ## Check list of jobs	
	$ jobs
	[1] Stopped  vim
	[2] Stopped  vim

	$ fg %1							<= go back to 1st.sh
  ## Ctrl + z
	$ fg %2							<= go back to 2nd.sh
	
  ## Save and exit or KILL Jobs
	$ kill %2
	$ kill -9 %1
	
----------------------------------------------------------------------------------------
# Monitoring Scripts		 https://bash.cyberciti.biz/shell/monitoring/

# Bash scripting cheatsheet  https://devhints.io/bash

----------------------------------------------------------------------------------------
### Variables ###	 
----------------------------------------------------------------------------------------
https://bash.cyberciti.biz/guide/Assign_values_to_shell_variables
${Variable} 			<= Actual String 
	
	nameVar="Albert Park"
	$ echo $nameVar        		is awesome
	$ echo "$nameVar"      		is awesome
	$ echo "$nameVar"      		is awesome
	$ echo "${nameVar}"    		is awesome
	$ echo "${nameVar} master"  is awesome

	$ printf "${nameVar}"			<= printf <-format and print data
										No NEW LINE
	$ printf "%s\n" "${nameVar}"	<= %s string, \n new line
	  > Albert							Add a NEW line using %s and \n
	  > Park

$ VAR="$(command)"		<= Command substitution & assign to Variable $VAR <= Newer
$ VAR=`command`			<= Command substitution & assign to Variable $VAR <= Old
	
	$ ll=`ls -Al`
	$ ll=$(ls -Al)
	$ ll="$(ls -Al)"
	$ echo $ll
	$ echo ${ll}
	$ echo "${ll} is weird looking"
	$ printf "${ll}" 
	
----------------------------------------------------------------------------------------
# Variable convention using VarName=$(date)  		<= Execute in subshell $(command)
----------------------------------------------------------------------------------------
	$ NOW=$(date)						<=  `date` is shell program
	$ NOW=`date`
	$ NOW="$(date)"						<= SAME as above
	$ NOW="$(date +%Y-%m-%d-%H-%M-%S)	<= 2019-01-15-11-30-02
	$ TIMESTAMP=$(date +%F) 
	$ TIMESTAMP=`date +%F`  			<= set variable name 'timestamp'
	
	$ echo $NOW							<= Fri Jan 18 15:25:43 PST 2019
			
	$ NOW=`date`
	$ echo $NOW							<= Fri Jan 18 15:25:43 PST 2019
	$ echo ${NOW}							<= Fri Jan 18 15:25:43 PST 2019
	$ echo "${NOW}"							<= Fri Jan 18 15:25:43 PST 2019
	  
----------------------------------------------------------------------------------------

	VAR=varName 								<= VAR Syntax
	VAR=${varName} 								<= VAR Syntax
	VAR="${varName}" 							<= VAR Syntax

	$ echo $SHELL
		/bin/bash
	
	$ echo "MySHELL is at $SHELL"				<= double quotes		
	$ echo "MySHELL is at ${SHELL}"				<= Braces on Var	
	$ echo  MySHELL is at "${SHELL}"			<= Braces + Double Quotes	
	$ echo  MySHELL is at `echo $SHELL`			<= Back-tik
	$ echo  MySHELL is at $(echo $SHELL)		<= Parenthesis		
	$ echo  MySHELL is at "$(echo $SHELL)"		<= Parenthesis + Double Quotes			
		
	=>	MySHELL is at /bin/bash <= All same output
								 


------------------------------------------------------------------------------------
# Length of Variable using {#var]
	https://stackoverflow.com/questions/17368067/length-of-string-in-bash
------------------------------------------------------------------------------------
  $ myVar="some string"
  $ echo ${#myVar}  				<= use '{#...}' for number of 
   => 11
  
  $ myVar="12345 6789"
  $ echo ${#myVar}
    => 10
  
  $ echo echo ${myvar} | wc -c    <= wc -c or wc --bytes for 'BYTE' counts 
    => 11   					   Unicode characters are counted with 2, 3 or more bytes.
  $ echo echo ${myvar} | wc -m   <= wc -m or wc --chars for 'Character' counts 
    => 11							Unicode characters are counted single until they use more bytes.

  $ myvar="some string"
	varSIZE=${#myvar} 
	echo "$varSIZE"
	11
  
  Example:  
	if [ ${#string} -ge 12 ]; then 
		echo ">= 12 characters. too long"
		exit
	else 
		echo "under 12 characters, not too long."
	fi	
	

------------------------------------------------------------------------------------
# NULL variable		<= 'NO Value(Empty)' at the time of definition
------------------------------------------------------------------------------------
	VAR=
	VAR=""
	
	** Use 'set -u' for Unassinged variable in bash script

------------------------------------------------------------------------------------	
# Variable Naming Convention
------------------------------------------------------------------------------------
	# Do not use '?' or '*' and other special characters to name your variable.
	?no=10 							<= Invalid '?' var
	out*put=/tmp/filename.txt 		<= Invalid '*' var

	_GREP=/usr/bin/grep 			# OK (valid)
	$ echo "$_GREP"

------------------------------------------------------------------------------------	
# Variable - Bash built-in 
------------------------------------------------------------------------------------
https://www.tldp.org/LDP/abs/html/internalvariables.html

	$# 	<= number of total arguments. 		
	$@ 	<= what parameters were passed. 	
	$? 	<= was last command successful. 	

	Example:
	$ vi test.sh
	------------------------------------------------------------------------
	#!/bin/sh
	usage="Usage: This script needs arg1, arg2, arg3 values.\n\ 
	e.g. script.sh 1 2 3"
	
	if [ ! $# == 3 ]; then
		echo -e $usage
	fi

	echo '$#' $#
	echo '$@' $@
	echo '$?' $?
	echo '$$' $$			# This script's PID
	
	------------------------------------------------------------------------
	$ bash ./test.sh 1 2 3
	  output:
	  $#  3
	  $@  1 2 3
	  $?  0
	  $$  2123
	  
	*You passed 3 parameters to your script.*

	$# = number of total arguments. 	<= 'Usage' error report if any arg missing
	$@ = what parameters were passed. 	<= Answer is 1 2 3
	$? = was last command successful. 	<= Answer is 0 which means 'True'	

------------------------------------------------------------------------------------
	#!/bin/bash
	#set -x
	clear
	usage="Usage: This script needs arg1, arg2, arg3 values!\n
	e.g. script.sh 1 2 3"

	if [ ! $# == 3 ]; then
		echo -e $usage
		echo 
	fi

	echo "1st argument is $1"
	echo "2nd argument is $2"
	echo "3nd argument is $3"
	echo -----------------------------------------------------------
	echo '$0' $0  '<=This is script itself'
	echo '$#' $#  '<=This should be total argments which should be 3'
	echo '$@' $@  '<=This is what are the argment values passed'
	echo ----------------------------------------------------------
	echo -e '$?' $?  '<=If the value is 0, it ran successfully,\n
                        if the value is 1, it failed'
------------------------------------------------------------------------------------	
	#!/bin/bash
	#set -x
	clear
	USAGE="Usage: This script needs arg1, arg2, arg3 values!\ne.g. script.sh 1 2 3"

	if [ ! $# == 3 ]; then
		echo -e $USAGE
		echo "Try again..........................."
	else
        echo "1st argument is $1"
        echo "2nd argument is $2"
        echo "3nd argument is $3"
        echo -----------------------------------------------------------
        echo '$0' $0  '<=This is script itself'
        echo '$#' $#  '<=This should be total argments which should be 3'
        echo '$@' $@  '<=This is what are the argment values passed'
        echo ----------------------------------------------------------
        echo -e '$?' $?  '<=If the value is 0, it ran successfully,\nif the value is 1, it failed'
	fi

    -----------------------------------------------------------------------------------
	$* <==> $@   Differences
	------------------------------------------------------------------------------------
	bash parameters are same but Difference is using "" 	
	https://javarevisited.blogspot.com/2011/06/special-bash-parameters-in-script-linux.html

#	$* 	<= individual parameters will be separated by first char of IFS characters
#   $@ 	<= individual parameters will appear in quotes and separated by space.

$ vi specialCharacters.sh
------------------------------------------------
#!/bin/sh
echo '$# is' $#
echo '$@ is' $@
echo '$@ is' "$@"
echo '$* is' $*
echo '$* is' "$*"
echo '$? is' $?
------------------------------------------------

	$ bash specialChar.sh  1 2 3 4
		$# is 4
		$@ is 1 2 3 4
		$@ is1 2 3 4
		$* is1 2 3 4
		$* is1 2 3 4
		$? is0

		
---------------------------------------------------
### SHELL (Local) Variable (within function) ####
---------------------------------------------------	  
	- variables can be created in a function that will not be available Global(outside) of it
	- variables are only set within a function
	
	- The 'typeset' cmd makes variables local, can provide a type, or can provide formatting.
		<= Declare variables and/or give them attributes.  If no names are given  then
           display the values of variables. 
	
	$ typeset -i x							<= x must be an integer
		- Arithmetic is faster
		- Let allows for convenient arithmetic:
		
		  let x++; 
		  let y=x**2; 
		  let x=x*3; 
		  let x*=5, ...
		  
------------------------------------------------------------------------
# When to use (List) <- Subshell  vs. { List; } <- Current Shell# in bash?	  
------------------------------------------------------------------------
https://askubuntu.com/questions/606378/when-to-use-vs-in-bash

------------------------------------------------------------------------
# {...; } 
# current shell
------------------------------------------------------------------------
$ function() 
	{ 
	echo this is a function; 
	}  			
$ function 								<= Invoke function like command 
	this is a function													 


$ count_tmp( ) { cd /tmp; files=(*); echo "${#files[@]}"; }
			   ^ space                     ^ NO space	^ space		
			   
$ count_tmp		<= execute the function	  
	=> 3
	
	
$ count_var() { cd /var/log; files=(*); echo "${#files[@]}"; }
	=> 54
$ ls -l | wc -l		<= Same result
	=> 54
 
$ pwd; count_tmp; pwd
	/home/apark
	11
	/tmp

$ echo "${#files[@]}"
	11  													
						


------------------------------------------------------------------------ 						
# (...) 
# Subshell command													
------------------------------------------------------------------------
$ f( ) (echo this is a function)					<= No effect on space nor ; to close

$ cd ; unset files
$ count_tmp() (cd /tmp; files=(*); echo "${#files[@]}")
$ pwd; count_tmp; pwd
	/home/apark
	11
	/home/apark
$ echo "${#files[@]}"
	0	

------------------------------------------------------------------------
# ( )		<= Subshell Command
( list )
------------------------------------------------------------------------
	Placing a list-of-commands between parentheses causes a 'subshell' environment to be created, 
	and each of the commands in list to be executed in that subshell. Since the list is executed 
	in a subshell, variable assignments do not remain in effect after the subshell completes.

	Code in '()' is run inside a separate, child process of bash that is discarded after execution. 
	This child process is often referred to as a sub-shell and can be thought of as a new, child-like scope.
------------------------------------------------------------------------
# { }		<= Current Shell Command
{ list; }
------------------------------------------------------------------------
	Placing a list of commands between curly braces causes the list to be executed in the 'current shell'
	context. No subshell is created. The semicolon (or newline) following list is required.

	Code in '{}' is executed in the current thread/process/environment and changes are preserved, 
	to put it more succinctly, the code is run in the current scope.


------------------------------------------
# FUNCTION
------------------------------------------



------------------------------------	  
#!/bin/bash
# Function for local and global vars  

function f1 {
	typeset x			# make x as a var within function(inside of function as local var)
	x=7
	y=8					# y becomes global var
}

x=1
y=2

echo x is $x
echo y is $y

f1						# Invoking function like command
echo x is $x		<= f1's var X value
echo y is $y		<= f1's var y value

# Output:
x is 1
y is 2
x is 1				<= still using x=1 variable
y is 8				<= y=8 variable from the function	  
		  
		  
---------------------------------------------------
### Declare  #### Make constant value for variable
---------------------------------------------------	
$ help declare 
#!/bin/bash
declare -r NUM1=5
num2=4
sum=$((NUM1+num2))



https://unix.stackexchange.com/questions/254367
When used in a function, declare makes NAMEs local, as with the local command. 
The -g option suppresses this behaviour.

abc=ok 		<= assigns a value to the variable abc. 
				Declare abc declares a variable called abc. 

The two can be combined as declare abc=ok.

In bash, like other shells, string and array variables don't need to be declared, so declare 
isn't necessary unless you want to pass options, e.g. 'declare -A abc' to make abc an associative 
array or declare -r to make a variable read-only. However, inside a function, declare does 
make a difference: it causes the variable to be local to the function, meaning that the value 
of the variable outside the function (if any) is preserved. (Unless you use declare -g, which 
makes the variable not local; this is useful when combined with other options, 
e.g. 'declare -gA' to create a global associative array in a function.) 

Example:
------------------------
#!/bin/bash
func1 () {
  declare a
  a='a in f'
  b='b in f'
  echo "From f: a is $a"
  echo "From f: b is $b"
}
a='Initial a'
b='Initial b'
func1								#Invoking the function like command
echo "After f: a is $a"
echo "After f: b is $b"
------------------------
Output=>
From f: a is a in f
From f: b is b in f
After f: a is Initial a
After f: b is b in f


The declare built-in is unique to bash. It's strongly inspired and very close to ksh's 
typeset built-in, and bash provides typeset as a synonym of declare for compatibility. 
There's a third synonym, local. 
There's also export, which is the same as declare -x, again for compatibility 
(with every Bourne-style shell).

----------------------------------------------------	  
	 $ declare -l upper-case values in the variable are converted to lower-case
	 $ declare -u lower-case values in the variable are converted to upper-case
	 $ declare -r variable is made read-only
	 $ declare -a MyArray will make MyArray an indexed array.
	 $ declare -A MyArray2 will make MyArray2 an Associative array.
----------------------------------------------------
#!/bin/bash
declare -l lowerString="ABCdef"
declare -u upperString="ABCdef"
declare -r readOnly="A Value"
declare -a MyArray
declare -A MyArray2

echo lowerString = $lowerString
echo upperString = $upperString
echo readOnly = $readOnly

readOnly="New Value"

MyArray[2]="Second Value"
echo 'MyArray[2] = '${MyArray[2]}

MyArray2["hotdog"]="baseball"
echo 'MyArray2[hotdog]= ' ${MyArray2["hotdog"]}
----------------------------------------------------

 	 
	 

---------------------------------------------------
# Combines Commands
---------------------------------------------------
# ;						<= run cm1 & cmd2
cmd1 ; cmd2     		<= cmd1 first, then cmd2(even if 'cmd1' has failed or not)
	$ sleep 5 ; ls -l

# &						<= run both
cmd1 & cmd2    			<= Do BOTH at same time 'cmd1 and cmd2' (without waiting for cmd1 to finish)
	$ sleep 4 & ls -l

# &&					<= Run cmd2 if cmd1 OK
cmd1 && cmd2   		    <= If cmd1 successful, run cmd2, otherwise skip.
cmd1 && cmd2 && cmd3    <= If cmd1 successful, run cmd2, run cmd3,  otherwise skip.
[[ conditon1 && condition2 ]]

# ||					<= 
cmd1 || cmd2   		    <= If cmd1 failed, run cmd2, otherwise skip.
cmd1 || cmd2 || cmd3    <= If cmd1 failed, run cmd2, otherwise runs cmd3, otherwise skip.


---------------------------------------------------
# Combines Commands
------------------------------------------
#   !    (not)   [ 1 != b ]   False
#  -a  	 (and)	 
#  -o    (or)	


	if [ "$expr1"  -a  "$expr2" ]; then
		echo "Both expr1 and expr2 are true."
	else
		echo "Either expr1 or expr2 is false."
	fi	
	
	
-----------------------------------------------------------------------------
# File Descriptor  
# RedirectionS 
# Pipes 
-----------------------------------------------------------------------------
https://en.wikipedia.org/wiki/File_descriptor

File Descriptor 0, 1, and 2 reserved as:
	0 - stdin  (Standard input)
	1 - stdout (Standard output)
	2 - stderr (Standard Error)

$ Command 			> stdout-here 2> stderr-here < stdin-from-here
  ./monitoring.sh   > log.txt	  2> Error.log   <- Input.txt

command 2>&1| command2			<= same
command |&    command2			<= same(variable by different shell

-----------------------------------------------------------------------------
command  2>&1 	file.log		<= everything(stdout & stderr)
command  &> 	file.log		<= everything(stdout & stderr)	
command  2> 	file.log		<= Only Error (stderr)	
command  1> 	file.log		<= Only (stdout)	


-----------------------------------------------------------------------------
# <<  				<= Here is a document command
	$ sort << EOF
	  orange
	  apple
	  banana
	  EOF
	  
-----------------------------------------------------------------------------	
# Open and Close File Descriptors ????????????????

- exec N < myfile   <= opens file descriptor N for 'reading' from file 'myfile'
- exec N > myfile   <= opens file descriptor N for 'writing' from file 'myfile'
- exec N <> myfile  <= opens file descriptor N for 'reading & writing' from file 'myfile'
- exec N <> myfile  <= opens file descriptor N for 'writing' from file 'myfile'
	
	
	
	

	
	
	
	
	
	
	
	
----------------------------------------------
# Redirection - stdin, stdout, stderr
----------------------------------------------	
https://en.wikipedia.org/wiki/File_descriptor

pgm > file     # Output of pgm is redirected to 'file'.
pgm < file     # Program pgm reads its input from the 'file'.
pgm >> file    # appending to file.

pgm1 | pgm2    # Output of pgm1 is 'piped' into pgm2 as the input to pgm2.

n > file       # Output from stream with descriptor 'n' 'redirected' to file.
n >> file      # Output from stream with descriptor 'n' 'appended' to file.

n >& m         # 'Merge' output from stream n with stream m.
n <& m         # 'Merge' input from stream  n with stream m.

<< tag         # Standard input comes from here through next tag at start of line.	

	$ cmd << EOF	  # '<<' here document using EOF(End Of File)
	  blah~~
	  EOF		   

	$ cat << EOF
	> Test1
	> Test2
	> EOF
	

# stdin, stdout, stderr
	$ ls +
	  ls: cannot access +: No such file or directory			<= stderr
	$ ls +   2>  error.txt
		
	$ cmd 2>    stderr.txt  1>  stdout.txt
	$ cmd 2&>1	> output.txt	(stdout & stderr into output.txt) 
	$ cmd &> 	> output.txt 	( &> is same as 2&>1 )
	
	$ cmd > /dev/null
	$ cmd > /dev/null 2&>1 		<= redirect the output of your program to /dev/null[black hole]. 
								   Include both the Standard Error and Standard Out.
	
	$ cmd | tee file1 			<= same as  'cmd > file1'
	$ cmd | tee file1 file2		<= tee make 2 copies file1 and file2
	$ cmd | tee -a file1 		<= -a Append to file1
	
	$ cmd < file.txt
		$ cat < file.txt
			file contents
	
	$ cmd &>> output.txt		<= Append stdout & stderr to output.txt
		$ls + &>> output.txt
		$ls + &>> output.txt
		$cat < output.txt
			ls: cannot access '+': No such file or directory
			ls: cannot access '+': No such file or directory

	
	
	
---------------------------------------------------	
#!/bin/bash
echo Redirect the out put to grub.out using '>'
find /etc -name grub > grub.out
echo "The result of grub.out file"
cat grub.out
echo ------------------------------------------

echo Sending error to errs.out using '2>'
find /etc   -name grub 2> errs.out
cat errs.out
echo ------------------------------------------

echo "Redirect both STDOUT & STDERR using '&>'"
find /etc -name grub &> both.out
cat both.out


---------------------------------------------------	
### Parameters ###
---------------------------------------------------
https://mywiki.wooledge.org/BashGuide/Parameters
	
Parameters are a sort of named space in memory you can use to retrieve or store information. 
Generally speaking, they will store string data, but can also be used to store integers, 
indexed and associative arrays.

# Parameters 
	It come in two flavors: variables and special parameters. Special parameters are read-only, 
	pre-set by BASH, and used to communicate some type of 	internal status. 
# Variables 
	They are parameters that you can create and update yourself. Variable names are bound by 
	the following rule:
	Name: A word consisting only of letters, digits and underscores, and beginning with a letter 
		or an underscore. Also referred to as an identifier.	


		
---------------------------------------------------	
# Shell Built-in Variables:
# Special Parameters and Variables
---------------------------------------------------
$0      # Name of this shell script itself.
$1      # Positional Parameters contain the arguments that were passed to the current script or function.
		  Value of first command line parameter (similarly $2, $3, etc)
$@		# Expands to all the words of all the positional parameters. Double quoted, 
		  it expands to a list of them all as individual words.
$#      # In a shell script, the number of command line parameters.
		  the number of positional parameters that are currently set
$*      # All of the command line positional parameters.
$-      # Options given to the shell.
$_		# Expands to the last argument of the last command that was executed.
$?      # Return the exit status of the last command. 0 - Successful, 1 -fail
$$      # Process id of script (id of the shell running the script)	
		  the PID (process ID) of the current shell.

The shell treats several parameters specially. 
These parameters may only be referenced; assignment to them is not allowed.

*
($*) Print all the parameter.
	 Expands to the positional parameters, starting from one. When the expansion is not within double quotes, 
     each positional parameter expands to a separate word. In contexts where it is performed, those words are 
	 subject to further word splitting and pathname expansion. When the expansion occurs within double quotes, 
	 it expands to a single word with the value of each parameter separated by the first character of the IFS 
	 special variable. That is, "$*" is equivalent to "$1c$2c…", where c is the first character of the value 
	 of the IFS variable. If IFS is unset, the parameters are separated by spaces. If IFS is null, the parameters 
	 are joined without intervening separators.

@
($@) Individually double quoted 
	Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, 
	each parameter expands to a separate word. That is, "$@" is equivalent to "$1" "$2" …. If the double-quoted 
	expansion occurs within a word, the expansion of the first parameter is joined with the beginning part of the 
	original word, and the expansion of the last parameter is joined with the last part of the original word. 
	When there are no positional parameters, "$@" and $@ expand to nothing (i.e., they are removed).

#
($#) Expands to the number of positional parameters in decimal(Counts number of parameters).	
 
($?) Exit status of the last command
	0 - successful
	1 - fail
	e.g. echo $?
($$) Process ID under which order getting executed

(?!) Process ID of the last background command


---------------------------------------------------  	
# Pattern Matching:
----------------------------------------------	

*              #Matches 0 or more characters.
?              #Matches 1 character.
[AaBbCc]       #Example: matches any 1 char from the list.
[^RGB]         #Example: matches any 1 char not in the list.
[a-g]          #Example: matches any 1 char from this range.	
	
Quoting:

\c             #Take character c literally.
`cmd`          #Run cmd and replace it in the line of code with its output.
"whatever"     #Take whatever literally, after first interpreting $, `...`, \
'whatever'     #Take whatever absolutely literally.	

Example:
match=`ls *.bak`        #Puts names of .bak files into shell variable match.
echo \*                 #Echos * to screen, not all filename as in:  echo *
echo '$1$2hello'        #Writes literally $1$2hello on screen.
echo "$1$2hello"        #Writes value of parameters 1 and 2 and string hello.

	
-------------------------------------------------------------------
# Command substitution
# BackTic `...` legacy VS Parenthesis $(...)  
-------------------------------------------------------------------
Back Tic `...` It isn't consistent with the syntax of Expansion and is terribly hard to nest. 
Use  $(...)  instead.
http://mywiki.wooledge.org/BashFAQ/082

$ echo "`echo \\a`" is dfifer than "$(echo \\a)"
  a is dfifer than \a

-------------------------------------------------------------------
# Arithmetic: BASH arithmetic is done using the expr command as in:
-------------------------------------------------------------------	


# expr - evaluate expressions
		
result=`expr $1 + 2`   				<= ` back tic
result=`expr $2 + $1 / 2`
result=`expr $2 \* 5`               #note the \ on the * symbol

brace expansion         (see a reference book)
~ expansion             (for login ids)
parameters              (such as $1)
variables               (such as $var)
command substitution    (Example:  match=`grep DNS *` $(date)
arithmetic              (from left to right)
word splitting			${name:0:2}
pathname expansion      (using *, ?, and [abc] )


	
---------------------------------------------------	
### Arithmetic Operators
---------------------------------------------------	
	Use in (( )) or with let
	i++, i--, ++i, --i
	!  ~  **  *  /  %  +  -
	<<  >>  <=  >=  <  >
	== !=  &  ^  |  &&  ||
	expr?expr:expr
	
	n=5
	((n++)
	if
	((n>4 || n == 0))
	
	((n=2**3 + 5))
	((y=n^4))
	echo y = $y

----------------------------------------------------------------------------------------
# incrementing ((i++)) or ((i=i+1))										
----------------------------------------------------------------------------------------
	((i+=1)) == ((i++)) == ((i=i+1))
	   -=   
	   *= 
	   /= 
	   %=
	
	Example:   
	$ i=5
	$ let i+=4                  <= i(5) + 4
	$ echo "$i"                 <= 9
	$ let i+=4                  <= i(9) + 4
	$ echo $i                   <= 13  

	$ echo "i = $(( i++ ))"       <= 13
	$ echo "i = $(( i++ ))"       <= 14

	$ echo "i = $(( ++i ))"       <=15
	$ echo "i = $(( ++i ))"       <=16
	$ echo "i = $(( i-- ))"       <=15
	$ echo "i = $(( --i ))"       <=14




	
---------------------------------------------------	
### Script running remotely
---------------------------------------------------
# Run a script on remote and out to local file

$ ssh-copy-id id@remote_ip             <= copy id_rsa.pub file into remote first

$ ssh id@remote_ip 'bash -s' < /home/scrhipt.sh >> output.log   <= run as sudo mode

	bash -c  <= Command read from string
				If there are arguments after the string, they are assigned to the positional parameters, 
				starting with $0.
	bash -i  <= shell is interactive
	bash -s  <= read from the standard input
	
	$ bash -c "help set"		<= Help page
	$ bash -c help				<= Help page
	
---------------------------------------------------
### Single Line Command script from SHELL ###
---------------------------------------------------

#### For Loop ####

$ for i in $(cat ~/list); do ssh apark@$i [[ -f /home/apark/rkchk.sh ]] && \   (use '\' for next line)
	echo "File exist" || echo "Not Exist";done                      
$ for i in $(cat "/home/apark/nu"); do ssh apark@$i "hostname && ls -l"; done
$ for i in $(cat "/home/apark/nu"); do ssh apark@$i "rm -f rkchk.sh"; done
$ for i in $(cat "/home/apark/nu"); do ssh -t apark@$i "sudo yum update kernel -y"; done
	# ssh -t <= Force pseudo-terminal allocation(Man ssh). 

$ for i in us eu as; do echo sg-$i; ssh sg-$i "uptime"; done
$ for i in sg-us sg-eu sg-as ; do echo $i; date; done
$ for i in sg-eu sg-as ; do rsync -av authorized_keys $i:.ssh; done

$ for i in $(cat pmtip); do echo $i && ssh -t apark@$i "cat /var/log/newrelic/nrsysmond.log" | tail; done  2>&1 > log


# This writes the name of all files ended with ".jpg" in the folder "img":
$ for f in *; do if [ "${f#*.}" == 'jpg' ]; then echo $f; fi; done

# This deletes them:
$ for f in *; do if [ "${f#*.}" == 'jpg' ]; then rm -r $f; fi; done

# Check crontab for all users 
$ for user in $(cut -f1 -d: /etc/passwd); do crontab -u $user -l; done    


#### While Loop ####
$ while  true; do dmesg -c ; sleep 1 ; done				<= -c clear, need subo 
$ while [ 0 ]; do dmesg -c ; sleep 1 ; done				<= -c clear, need subo 
$ while     :; do dmesg -c ; sleep 1 ; done				<= : is same as "while true"

	The : (colon) is a built-in command that does nothing, but returns 0 (success<= TRUE). 
	Thus, it's shorter (and faster) than calling an actual command to do the same thing.


	
$ while [ 1 ] ; do echo "ssh to 45.55.5.69...";ssh apark@45.55.5.69 'date; hostname'; sleep 10; done
$ while false ; do echo "ssh to 45.55.5.69...";ssh apark@45.55.5.69 'date; hostname'; sleep 10; done

$ while true; do tail -n0 -f /var/log/apache2/access.log > /tmp/tmp.log & sleep 2; kill $! ; \
  wc -l /tmp/tmp.log | cut -c-2; done 2> /dev/null




  
  
------------------------------------------------------------------------------------
# while loop - infinite 
------------------------------------------------------------------------------------
https://stackoverflow.com/questions/1289026/syntax-for-a-single-line-bash-infinite-while-loop
$ while sleep 2; do echo "Thinking"; done	
$ while       :; do echo "Thinking"; sleep 2; done				<= : <-true, run echo then sleep cmd
$ while [ 1 ]  ; do echo "Thinking" && sleep 2 || break; done   <= 1 is not true [ test ]


$ until  ((0)); do echo "Thinking"; sleep 2; done
$ while read i; do echo "Thinking"; sleep 2; done < /dev/urandom
$ for   ((;;)); do echo "Thinking"; sleep 2; done
$ until    [ ]; do echo "Thinking"; sleep 2; done


# Move or rename file from CMD
$ if [ -e .vimrc ]; then mv .vimrc .vimrc_bak; fi



---------------------------------------------------	
# Grouping Commands
---------------------------------------------------		
https://www.gnu.org/software/bash/manual/bashref.html#Command-Grouping






	
	

	
	
	
---------------------------------------------------	
### Within script Code

	#!/bin/bash  # or '#!/bin/bash -x'
	### turn on debug mode
	set -x           					<= Turn on/  " +x " Off debug mode
	for i in $(ls)
	do
		file $i
	done
------------------------------------
### /dev/null
	> /dev/null 2>&1     <= redirect the output of your program to /dev/null. 
							Include both the Standard Error and Standard Out	
						&  indicates a file descriptor. There are usually 3 file descriptors 
						   - standard input, output, and error
						   
	e.g. in crontab
	* * * * * /home/apark/check.sh /dev/null 2>&1					   

# more commands
	set -x : Display commands and their arguments as they are executed.
	set -v : Display shell input lines as they are read. 
	

 
 # Move cursor to all the way down
	shift+G		<= All the way down the page
	
 # Check bash 
	$ echo $SHELL
	$ env | grep SHELL
	$ ps					 
	  1453 pts/1    00:00:00 bash  <= BASH
	$ ps | grep `echo $$` | awk '{ print $4 }'


---------------------------------------------------
### Special Shell Variables ###
---------------------------------------------------
https://coderwall.com/p/85jnpq/bash-built-in-variables

	$0 		file name of script
	$1		positional parameter #1
	$2-9	positional parameter #2-9
	${10}	positional parameter #10 and up         e.g. ${10}, ${11}, ${12}....
	
	$* 		the list of arguments passed to the current process
	$#		Total number of positional parameters   e.g. 4
	$@		what parameters were passed 			e.g. 1 2 3 4
	
	"$*"	all the positional parameters(as separate word)*
	"$@"	all the positional parameters(as separate strings)
	${#*}	number of positional parameters
	${#@}	number of positional parameters
	
	$?		return value
	$$	 	process ID(PID) of script
	$!		process ID(PID) of last job run in background
	
	$-		flags passed to script( set's opntion 'himBHs', $help set)
	$_		last argument of previous command
		e.g. $ bash test.txt
			 $ cat $_			<= $_ is test.txt
	
	* Must be quoted, otherwise it defaults to $@

e.g.	
echo $$ <= the PID of the current process.
echo $! <= The PID of the most recent background command
echo $? <= the return code of the last executed command. 0:True, 1:False	

echo $# <= the Total number of arguments in $*
echo $* <= the list of arguments passed to the current process
echo $@ <= List of arguments
	
--------------------------------------------------------------------------------------------------
$* - Expands to the positional parameters, starting from one. When the expansion occurs within 
	double quotes, it expands to a single word with the value of each parameter separated by 
	the first character of the IFS special variable.

$@ - Expands to the positional parameters, starting from one. When the expansion occurs within 
	" "(double quotes), each parameter expands to a separate word.


	

	
------------------------------------------
#!/bin/bash
# save and run script.sh 1 2 3 4
#
echo "With *:"
for arg in "$*"; do echo "< $arg >"; done		#<= $* <- the list of arguments passed

echo "------------------------------------"

echo "With @:"
for arg in "$@"; do echo "< $arg >"; done 		#<= $@ <- 

echo "------------------------------------"

echo "With #:"
for arg in "$#"; do echo "< $arg >"; done 		#<= $# <- the Total number of arguments in $*
  			
------------------------------------------

$ /tmp/test.sh 1  2 "3 4"
With *:
<1 2 3 4>

With @:				<= per line	due to 'For Loop'
<1>
<2>
<3 4>

With #:
<3>

https://coderwall.com/p/85jnpq/bash-built-in-variables

-----------------------
$ vi test.sh
#!/bin/sh
echo 'The number of positional parameters are $# is: ' $#
echo 'All positional parameters are $@ is: ' $@
echo 'The exit code of fg(foreground command $? is: ' $?
-----------------------

$ bash test.sh 1 2 3
output:
$#  3				<= The number of positional parameters
$@  1 2 3			<= all the arg values in the single line(use for loop for colum)
$?  0				<= 'True' exit code

*You passed 3 parameters to your script.*

$# = number of arguments is 3
$@ = what parameters were passed was 1 2 3
$? = was last command successful. Answer is 0 which means 'yes(True)'
	

# Echo in BASH Script	
$ echo -n     do not output the trailing newline (\n)
       -e     enable interpretation of backslash escapes
       -E     disable interpretation of backslash escapes (default)
	   
echo ${PATH#*:}        		<= Parameter substitution, NOT a comment.
echo $(( 2#101011 ))   		<= Base conversion, NOT a comment. 

#--------------------------------------------------------------------------------
### Usage Message ### 
#--------------------------------------------------------------------------------   
#!/bin/bash
usage="Usage: This script needs arg1 and arg2 values"
if [ ! $# == 2 ]; then
    echo $usage
fi

echo "1st argument is $1"
echo "2nd argument is $2"  
	   
	   
#--------------------------------------------------------------------------------
#!/bin/bash
### Comparing two directories ###
#set -x 		<= Debug mode  '+x' <= Disable mode
# Usage: compare2dirs.sh DIR1_Name DIR2_Name #
usage="Usage: $0 DIR1_Name DIR2_Name"

------------------------------------------------------------------------------------
# Test Statement
# Comparing 
------------------------------------------------------------------------------------
if [ $# -gt 2 ]; then                   # number of command line parameters.
    echo $usage;						# if args are more than 2, echo $usage
fi

if [ $# -lt 2 ]; then                   # number of command line parameters.
    echo $usage;						# if args are less than 2, echo $usage
fi
 
if [ -z "$1" ]; then                    # length of '$1' parameter is empty(zero string)
    echo $usage;
fi

#------------ Actual Code ------------#
if [ -d "$1" -a -d "$2" ]; then         # -d "$1" <= file exists and is a directory
                                        # -a      <= 'and' both dirs are exist
                                        # -d "$2" <= file exists and is a directory
    echo "Comparing $1 with $2 ....";
    diff -r $1 $2                       # -r <= recursively compare any subdirectories found
	
	### Where is the result output???
fi


https://stackoverflow.com/questions/16787916/difference-between-two-directories-in-linux/16788549	   
$ diff -r dir1 dir2 | grep dir1 | awk '{print $4}' > difference1.txt
$ diff -rq dir1 dir2 


$  comm -23 <(ls dir1 |sort) <(ls dir2|sort)

---------------------------------------------------
### Quote in shell script ###

	$ greeting="hello"
	### NO Quote	
	echo $greeting, world \(planet\)!
	   => hello, world (planet)!
	
	### Single Quote
	echo '$greeting, world (planet)!'
	   => $greeting, world (planet)!

	### Double Quote
	echo "$greeting, world (planet)!"
	    => hello, world (planet)!

	$ awk '/lemon/ && /rice/'					<= search two words
---------------------------------------------------
# 2>&1 
---------------------------------------------------
	Using "2>&1" , redirect the standard error(2) to standard output(1). The string "2>&1" 
	indicates that any errors should be sent to the standard output(1), that is, the Linux/Linux 
	file id of 2 for standard error, and the file id of 1 for standard output.  If you do not 
	use this string, then you will be capturing only the good messages, and the error messages 
	will not be captured.
	
	cmd 1>&2			<= stdout to same place as stderr
	cmd 2>&1			<= stderr to same place as stdout
	cmd &> file			<= Every output of cmd to file
	
	$ ./script.sh  &> log.txt
		



-------------------------------------------------------------------------------------
# comparisons
-------------------------------------------------------------------------------------
Operator	       Meaning									Example
-------------------------------------------------------------------------------------
-z			Length of String is (zero)EMPTY 					[ -z "$var" ]     var=""
! -z		Length of String is NOT (zero)EMPTY 				[ -z "$var" ]     var="num"

-n			Length of String is NOT (zero)EMPTY					[ -n "$var" ]     var="num"
-f			File is Exists & normal,regular 					[ -f "$file" ]
-d			Directory is Exists  								[ -d "$dir" ]
-e 			file exist
-w			Writeable 
=			Strings are same									[ "abc" = "$my_var" ]
!=			Strings are Not Same   								[ "abc" != "$my_var" ]


-eq	  		Equal (Numeric equality)							[ 3 -eq 3 ("$my_integer") ]
-ne			Not Equal(Numeric inequality)						[ 3 -ne 4 ("$my_integer") ]
-lt			Less than (Numeric strict less than)				[ 3 -lt 4 ("$my_integer") ]
-le			Less than or equals	(Numeric less than or equals)	[ 3 -le 4 ("$my_integer") ]
-gt			Greater than (Numeric strict greater than)			[ 3 -gt 2 ("$my_integer") ]
-ge			Greater than or equals(Numeric) 					[ 3 -ge 3 ("$my_integer") ]

-nt			First file is newer than second one					[ "$myfile" -nt ~/.bashrc ]
-ot			First file is older than second one					[ "$myfile" -ot ~/.bashrc ]



-------------------------------------------------------------------------------------
# Ccomparison - Integers (Number Values only)
-------------------------------------------------------------------------------------
# -eq	<= equal to
		if [ "$a" -eq "$b" ]

# -ne   <= Not equal to
		if [ "$a" -ne "$b" ]

# -gt	<=  greater than
		if [ "$a" -gt "$b" ]

# -ge	<= greater than or equal to
		if [ "$a" -ge "$b" ]

# -lt	<= less than
		if [ "$a" -lt "$b" ]

# -le	<= less than or equal to
		if [ "$a" -le "$b" ]
		
-------------------------------------------------------------------------------------		
# Comparison - Arithmatic (Number Values only)
-------------------------------------------------------------------------------------
# <		<= less than 
		(( "$a" < "$b" ))

# <=    <= less than or equal 
		(( "$a" <= "$b" ))

# >		<= greater than 
		(( "$a" > "$b" ))

# >=	greater than or equal
		((" $a" >= "$b" ))

-------------------------------------------------------------------------------------
# Comparison - Strings (Letters, Numbers, Characters)
-------------------------------------------------------------------------------------
# = 
# != 
# ==
	# Equal to  '$a =  $b'  if same values  $a=1, $b=1 | '1=1 is equal'
	if [ "$a" = "$b" ]; then
		echo "$a" and "$b" are same
	fi
	
	# Not equal to(  if they have same values. e.g.  1 = 1, a = a, IP = IP)
	if [ "$a" != "$b" ]; then 
		echo "$a" and "$b" are same
	fi
	
	# Comparing '$1 == (is same as) $2'      1 == 1 same
	if [ "$a" == "$b" ]; then echo "$a" and "$b" are same; fi


	== is a synonym for =

		The == comparison operator behaves differently
		within a double-brackets [[ ]] test than within single brackets.
		
		[[ $a == z* ]]   # True if $a starts with an "z" (pattern matching).
		[[ $a == "z*" ]] # True if $a is equal to z*     (literal matching).
		
		[ $a == z* ]     # File globbing and word splitting take place.
		[ "$a" == "z*" ] # True if $a is equal to z* (literal matching).
	


# <		<= $a is less than $b, in ASCII alphabetical order
		
		if [[ "$a" < "$b" ]]
		if [ "$a" \< "$b" ]

# >		<= $a is greater than $b, in ASCII alphabetical order
		
		if [[ "$a" > "$b" ]]
		if [ "$a" \> "$b" ]

-------------------------------------------------------------------------------------
# Comparison - Checks Null (Letters, Numbers, Characters)
-------------------------------------------------------------------------------------

# -z	<=	Zero String Length - String is Null(Empty String-Value)

		String=''   # Zero-length ("null") string variable.
		if [ -z "$String" ]; then
		    echo '$String is Null.'
		else
		    echo '$String is NOT Null.'
		fi  
		
		# Creating $VAR if not Exist
		if [ -z "$VAR" ]; then VAR=String; fi   <= Creating $VAR
		
		if [ ! -z "$HOME" ]; then echo "$HOME"; fi 


# -n	<=	No Zero Length - Not Null (Some String-value)

		String='BMW'   # String variable is BMW.
		if [ -n "$String" ]; then
		    echo '$String is Not Null.'
		else
		    echo '$String is Null(Empty.'
		fi    

# -d  <= To check if a directory exists

		if [ -d "$DIRECTORY" ]; then
			echo "$DIRECTORY" is Exist
		fi
	
# ! -d	
		if [ ! -d "$DIRECTORY" ]; then
			echo "$DIRECTORY" is Not Exist!
		fi
		
-------------------------------------------------------------------------------------
# Test [  ] [[  ]] satement
-------------------------------------------------------------------------------------
# [ expression ]  	<= [ is a Bash built-in statement for Comparison operation   
						0:TRUE  1:FALSE(Success)   
	e.g.
	$ [ A < B ]								<= echo $?  1 <- false, (B value is feeding into A command) 
	-bash: b: No such file or directory 	<= returns an error because Bash tries to 'redirect' 
					   						 the file B to the command [ A ].
	
	i.e. Bash interprets as commands
	$ [A] < B
	
	
# [[ expression ]] 	<= [[ is a Bash keyword - Extended Test statement for Comparison operation   
					 	0:TRUE  1:FALSE(Success)	 
	
	$ [[ a < b ]]					<= echo $?  0 <- true
								Alphabetical comparison. The character '<' no longer has its 
								typical meaning of a File 'Redirection operator' when 
								it's used with the  [[  ]]  
	
###	Keywords
		Keywords are like built-in, with the main difference being that 
		special parsing rules apply to them. 


-------------------------------------------------------------------------------------
# Comparing String Variables	  
------------------------------------------------------------------------------------- 
[[ $1 < $2 ]]		Less than			                            = (( $a < $B ))   , a=1, b=2
[[ $a > $b ]]		greater than			   
[[ $a <= $b ]]		less than or equal to 		
[[ $a >= $b ]]		greater than or equal to 	
[[ $a == $b ]]		equal(same)			        
[[ $a != $b ]]		not equal(same)		        
-------------------------------------------------------------------------------------		
$ [ 9 -lt 10 ] ; echo $?
$ [ "awesome" = "awesome" ]; echo $?
$ [ 10 == 10 ] ; echo $?
$ [[ 1 < 2 ]]  ; echo $?

$ (( 1 < 2 ))  ; echo $?
$ (( 1 == 2 )) ; echo $?

or use 'expr' for arithmatic 





------------------------------------------------
###  () vs. {}
------------------------------------------------
	https://askubuntu.com/questions/606378/when-to-use-vs-in-bash
{...} <= current shell
(...) <= subshell



() <- Subshell

( list )
	Placing a list of commands between parentheses causes a "SUBSHELL" environment to be created, 
	and each of the commands in list to be executed in that subshell. Since the list is executed 
	in a subshell, variable assignments do not remain in effect after the subshell completes.
$ ( a=A )
$ echo $a
A
### e.g.
$ cd ; unset files
$ count_tmp() (cd /tmp; files=(*); echo "${#files[@]}")
$ pwd; count_tmp; pwd
/home/jackman
11
/home/jackman
$ echo "${#files[@]}"
0
---------------------------------------------------------------------------------------------------
{}   <- Current Shell

{ list; }
	Placing a list of commands between curly braces causes the list to be executed in the "Current 
	shell" context. No subshell is created. The semicolon (or newline) following list is required.
$ { a=A; }
$ echo $a
A
### e.g.
$ count_tmp() { cd /tmp; files=(*); echo "${#files[@]}"; }
$ pwd; count_tmp; pwd
/home/jackman
11
/tmp
$ echo "${#files[@]}"
11  



---------------------------------------------------------------------------------------------------
		

The shell treats several parameters specially. These parameters may only be referenced; assignment to them is not allowed.

Table 3-3. Special bash variables

Character	Definition
$*	Expands to the positional parameters, starting from one. When the expansion 
	occurs within double quotes, it expands to a single word with the value of each 
	parameter separated by the first character of the IFS special variable.
$@	Expands to the positional parameters, starting from one. When the expansion occurs 
	within double quotes, each parameter expands to a separate word.
$#	Expands to the number of positional parameters in number(decimal).
$?	Expands to the "exit status" of the Last(most recently) executed foreground pipeline.
$-	A hyphen expands to the current option flags as specified upon invocation, by the 
	set built-in command, or those set by the shell itself (such as the -i).
$$	Expands to the process ID of the shell.
$!	Expands to the process ID of the most recently executed background (asynchronous)
	 command.
$0	Expands to the name of the shell or shell script.
$_	The underscore variable is set at shell startup and contains the absolute file name 
	of the shell or script being executed as passed in the argument list. Subsequently, 
	it expands to the last argument to the previous command, after expansion. It is also
	set to the full pathname of each command executed and placed in the environment 
	exported to that command. When checking mail, this parameter holds the name of the 
	mail file.


grep "echo" ./function1.sh
   	echo "Hi $1! what a nice $2!!"
	echo "And now, a greeting!"
	echo $_
	./function1.sh
	echo $$
	35810
	echo $!


	
### IFS   <-Internal Field Seperator

$ bash -c 'set w x y z; IFS=":-;"; echo "$*"'
w:x:y:z

Compare to:

$ bash -c 'set w x y z; IFS="-:;"; echo "$*"'
w-x-y-z	
	
	
######################## 
# Bash Shell Variables #
########################

varname=value                # defines a variable
varname=value command        # defines a variable to be in the environment of a particular subprocess
echo $varName                # checks a variable's value
echo $$                      # prints process ID of the current shell
echo $!                      # prints process ID of the most recently invoked background job
echo $?                      # displays the exit status of the last command
export varName=value         # defines an environment variable (will be available in subprocesses)
	e.g.  using 'export' to env variable for current SHELL to execute 
	$ HTTP_PROXY=192.168.2.2:3128
	$ export HTTP_PROXY
	
	$ echo A is $A
	$ export A=1
	$ echo A is $A
	  A is 1
#unset	  
	$ unset A					
		# Unset values and attributes of shell variables and functions.
		    -f        treat each NAME as a shell function
			-v        treat each NAME as a shell variable
		# Without options, unset first tries to unset a variable, and if that fails,
			tries to unset a function.


### White Sapce		
	whitespace (spaces or tabs).



$ my_var=This is my environment variable!	
$ echo foo${my_var}bar							<= must use { }
fooThis is my environment variable!bar



















----------------------------------------------------------------------------------
### IF statement ###### 
----------------------------------------------------------------------------------

$ test 100 -gt 99  && echo "Yes, that's true." || echo "No, that's false."
$ [ 100 -gt 99 ]   && echo "Yes, that's true." || echo "No, that's false."
$ [[ 100 -gt 99 ]] && echo "Yes, that's true." || echo "No, that's false."
	Yes, that's true.

$ test 90 -gt 99 && echo "Yes, that's true." || echo "No, that's false."
	No, that's false.
	
----------------------------------------------
#!/bin/bash
if [ $num -lt 10 -o $num -gt 100 ]				# -o  or
	then
    echo "Number $num is out of range"
elif [ ! -w $filename ]							# -w writeable <= No use of ';' for combine cmds
	then
    echo "Cannot write to $filename"
fi	
----------------------------------------------	
#!/bin/bash
if [ $num -lt 10 -o $num -gt 100 ]; then		 <= use ';' for two or more commands in same line
	echo "Number $num is out of range"
elif [ ! -w $filename ]; then					 <= ';' for two or more commands
    echo "Cannot write to $filename"
fi	
----------------------------------------------	
	
#!/bin/bash
if [ $id -u = 0 ];then				# if (id -u) 0 = 0 are True
    echo "You are root" >&2			# 	
    exit 0
fi

---------------------------
#!/bin/bash
if [ $id -u = 0 ];then				# if (id -u) 0 = 0 are True
    echo "You are root" 			# 	
else
	echo "You are not root"
fi

	
### ! -z $HOME 		<= If home is NOT empty, echo $HOME

	$ if [ ! -z $HOME ]; then echo $HOME; else echo "No Home"; fi
	$ if [[ -n $HOME]];  then echo $HOME; else echo "No Home"; fi       <= if home is exist
	/home/noza                                                          <= Same answer
           
### -z $HOME    	<= $HOME is empty which is False, echo "No Home"

	$ if [ -z $HOME ]; 	   then echo $HOME; else echo "no home"; fi		<= SAME answer
	$ if [[ ! -n $HOME ]]; then echo $HOME; else echo "no home"; fi		<= SAME answer
	no home  

	$ if [[ ! -z $HOME ]]; then echo $HOME; elif [[ -z $HOME ]]; then echo "No Home"; fi
	/home/noza
	
	---------------------------
	$vi homeCheck.sh
	---------------------------
	#!/bin/bash
	if [[ ! -z $HOME ]]; then 
		echo $HOME; 
	elif [[ -z $HOME ]]; then 
		echo "No Home"; 
	fi
	---------------------------



----------------------------------------------------------------------------------------------------
### RR server process check
#!/bin/bash
# Check and put ok status if the RRS game service is running for Lobby 7504 & 7505 services

if (( $(ps aux | grep ./RRServer_0402_7504 | grep -v grep | wc -l) > 0  &&  $(ps aux | grep ./RRServer_0617_7505 | grep -v grep | wc -l) > 0 )) ;
        then
        echo OK > /var/www/html/status/index.html;
else rm /var/www/html/status/index.html > /dev/null 2>&1;
fi
----------------------------------------------------------------------------------------------------


#!/bin/bash
# Detecting OS (CentOS or Ubuntu)
detect_os ()
{
    if [ -f /etc/redhat-release ]; then
        echo "Your OS is CentOS."

    elif [ -f /etc/lsb-release ]; then
        echo "Your OS is Ubuntu."

    else
        unknown_os

    fi
}
detect_os
----------------------------------------------------------------------------------------------------
	#!/bin/bash
	# Detecting OS using $OSTYPE variable
	
	if [[ "$OSTYPE" == "linux-gnu" ]]; then
        # ...
	elif [[ "$OSTYPE" == "darwin"* ]]; then
        # Mac OSX
	elif [[ "$OSTYPE" == "cygwin" ]]; then
        # POSIX compatibility layer and Linux environment emulation for Windows
	elif [[ "$OSTYPE" == "msys" ]]; then
        # Lightweight shell and GNU utilities compiled for Windows (part of MinGW)
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
        # ...
	else
----------------------------------------------------------------------------------------------------      










----------------------------------------------------------------------------------
### for_loop### 
----------------------------------------------------------------------------------
#!/bin/bash

for i in $(ls)
do
    echo $i
done
------------------------------------
### for_loop1.sh
------------------------------------		
#!/bin/bash
for i in *; do   # * is local directory
	echo “$i”
done
$./for_loop1.sh 
=> local files list
------------------------------------
### for_loop2.sh
------------------------------------
#!/bin/bash
for i in $#; do
	echo “$i”			# zip archive "$i"
done
$./for_loop1.sh 1 2 3 4	
=> 4   <= total number of argument 1,2,3,4 is 4 total!
------------------------------------
### for_loop2.sh
------------------------------------
#!/bin/bash
for i in $@; do
	echo “$i”			# zip archive "$i"
done
$./for_loop1.sh 1 2 3 4	
=> 1 2 3 4

------------------------------------
$ for i in {1..10..2}; do echo $i; done
$ for (( i=1; i<=10; i++));do echo $i; done
$ for (( i=1; i<=10; i++));do echo -n $i `sleep 1`" "; done




----------------------------------------------------------------------------------
### Array ###
----------------------------------------------------------------------------------
# Arrays and Associative Arrays
	BASH provides 3 types of parameters: Strings, Integers and Arrays
	
	Arrays 			   <= Stores a collection of data separate entities using indexes
	Associative Arrays <= Take a string as their array index (Bash V4 or higher)
	
ARRAY_NAME[index_number]=value
The Index_Number is treated as an arithmetic expression that must evaluate to a + positive number.

# Indexed Array
https://mywiki.wooledge.org/BashFAQ/005
Basic syntax summary (for bash, math indexed arrays):
----------------------------------------------------------------------------------
1. One-dimensional integer-indexed arrays are implemented by Bash
a=(word1 word2 "$word3" ...)	<= Initialize an array from a word list, indexed starting 
									with 0 unless otherwise specified.
a=(*.png *.jpg)					<= Initialize an array with filenames.
a[i]=word						<= Set one element to word, evaluating the value of i in a 
									math context to determine the index.
a[i+1]=word						<= Set one element, demonstrating that the index is also a math context.
a[i]+=suffix					<= Append suffix to the previous value of a[i] (bash 3.1).
a+=(word ...) # append			<= Modify an existing array without unsetting it, indexed 
								   starting at one greater than the highest indexed 
								   element unless otherwise specified (bash 3.1).
	e.g. a+=([3]=word3 word4 [i]+=word_i_suffix)	

unset 'a[i]'					<= Unset one element. 
								   Note the mandatory quotes (a[i] is a valid glob).
"${a[i]}"						<= Reference one element.
"$(( a[i] + 5 ))"				<= Reference one element, in a math context. 															
"${a[@]}"						<= Expand all elements as a list of words.
"${!a[@]}						<= Expand all indices as a list of words (bash 3.0)
"${a[*]}"						<= Expand all elements as a single word, with the first char of IFS as separator.
"${#a[@]}"						<= Number of elements (size, length).
"${a[@]:start:len}"				<= Expand a range of elements as a list of words, cf. string range.

"${a[@]#trimstart}" 			<= Expand all elements as a list of words, with modifications applied to each element separately.
"${a[@]%trimend}"
"${a[@]//search/repl}"		
					
declare -p a					<= Show/dump the array, in a bash-reusable form.
mapfile   -t a < stream			<= Initialize an array from a stream (bash 4.0).
readarray -t a < stream			<= Same as mapfile.
----------------------------------------------------------------------------------

#!/bin/bash
# Assign the values "mickey", "minnie", and "goofy" to sequential indexes starting with 0(zero).

host=(mickey minnie goofy)										<= Array	
# host="mickey minnie goofy"
# host='mickey minnie goofy'

# Iterate over the indexes of "host".
for i in "${!host[@]}"; do
    printf 'Host number %d is %s\n' "$i" "${host[i]}"			<= %s\n  <- A new Line
done

 


---------------------------------------------------------
# From Bash Shell

ex) Set array 1, 2, 3
	$ array_var=(1 2 3)
	$ array_var[0]="test1"
	$ array_var[1]="test2"
	$ array_var[2]="test3"

	$ echo ${array_var[0]}
	  test1
	$ echo ${array_var[$#]}
	  test1

    $ index=2
	$ echo ${array_var[$index]}
	  test3
	$ echo ${array_var[*]}
	  test1 test2 test3 m
	
	$ echo ${array_var[@]}
		test1 test2 test3
	$ echo ${#array_var[*]}
		3


	array[0] = val               # several ways to define an array
	array[1] = val
	array[2] = val
	array=([2]=val [0]=val [1]=val)
	array(val val val)

	
${array[i]}                  # displays array's value for this index. If no index is supplied, array element 0 is assumed
${#array[i]}                 # to find out the length of any element in the array
${#array[@]}                 # to find out how many values there are in the array


declare -A					 # Associative Array
declare -a                   # Indexed array variables
declare -f                   # uses function names only
declare -F                   # displays function names without definitions
declare -i                   # the variables are treaded as integers
declare -r                   # makes the variables read-only(Constant)
								ex) declare -r NUM1=5
declare -x                   # marks the variables for export via the environment

${varname:-word}             # if varname exists and isn't null, return its value; 
								otherwise return word
${varname:=word}             # if varname exists and isn't null, return its value; 
								otherwise set it word and then return its value
${varname:?message}          # if varname exists and isn't null, return its value; 
								otherwise print varname, followed by message and abort the current command or script
${varname:+word}             # if varname exists and isn't null, return word; 
								otherwise return null
${varname:offset:length}     # performs substring expansion. It returns the substring of $varname 
								starting at offset and up to length characters

${variable#pattern}          # if the pattern matches the beginning of the variable's value, 
								delete the shortest part that matches and return the rest
${variable##pattern}         # if the pattern matches the beginning of the variable's value, 
								delete the longest part that matches and return the rest
${variable%pattern}          # if the pattern matches the end of the variable's value, 
								delete the shortest part that matches and return the rest
${variable%%pattern}         # if the pattern matches the end of the variable's value, 
								delete the longest part that matches and return the rest
${variable/pattern/string}   # the longest match to pattern in variable is replaced by string. 
								Only the first match is replaced
${variable//pattern/string}  # the longest match to pattern in variable is replaced by string. 
								All matches are replaced
${#varname}                  # returns the length of the value of the variable as a character string

*(pattern list)               # matches zero or more occurences of the given patterns
+(pattern list)               # matches one or more occurences of the given patterns
?(pattern list)               # matches zero or one occurence of the given patterns
@(pattern list)               # matches exactly one of the given patterns
!(pattern list)               # matches anything except one of the given patterns

$(Linux command)              # command substitution: runs the command and returns standard output		
		
------------------------------------------------------------------------
2. Loading values into an array

Assigning one element at a time is simple, and portable:
#!/bin/bash
arr[0]=0
arr[42]='the answer'
array=(zero one two three four)  <= When initializing in this way, the first index will be 0

	2.1. Loading lines from a file or stream
	$ mapfile -t lines <myfile
	$ mapfile -t lines < <(some command)	
		
$help mapfile 	<= Read lines from the standard input into an indexed array variable.	
		
		
------------------------------------
#!/bin/bash
array_name=("apple" "banaba" "cherry")
for i in ${array_name[@]}             # @ or * <- both works 
do
    echo -n `sleep 1` $i " "
done

------------------------------------
#!/bin/bash
declare -a array_name
array_name["0"]="Albert"
array_name["1"]="1234"

for i in "${!array_name[@]}"  				### ! <-access keys in array  ""<- if space is in array
do
    echo "$i \= ${array_name[$i]}"
done

"declare -a" declares an array and all the elements in the parentheses are the elements of an array.
 
$ declare -a array_name=('Debian' 'Red hat' 'Red hat' 'Suse' 'Fedora');
$ echo ${array_name[@]}
  Debian Red hat Red hat Suse Fedora

------------------------------------
#!/bin/bash
# Declaring an Array and Assigning values
#	-a     Each name is an indexed     array variable (see Arrays above).
#   -A     Each name is an associative array variable (see Arrays above).

declare -a Linux

Linux[0]="Debian"
Linux[1]="Redhat"
Linux[2]="Ubuntu"
Linux[3]="Suse"

for i in "${!Linux[@]}"   # listing elements of the array
do
  echo "$i: ${Linux[$i]}"
done
==>> Output
0: Debian
1: Redhat
2: Ubuntu
3: Suse

----------------------------------------------------------------------------------
###  Length of the Bash Array ###

get the length of an array using the special parameter called $#.

${#array_name[@]} gives you the length of the array.

e.g.
$ declare -a Linux=('Debian' 'Red hat' 'Suse' 'Fedora');
# Number of elements in the array
$ echo ${#Linux[@]} 
  4
# Number of "characters" in the first element of the array.i.e Debian
$ echo ${#Linux}  		<- same as 0
  6
$ declare -a Linux=('Debian' 'Red hat' 'Suse' 'Fedora');
$ echo ${#Linux[3]}
  7  <- counting SPACE, too

------------------------------------
$ declare -a num=(1 22 333 4444 55555 666666)
$ echo ${#num[2]}
	3
$ echo ${num[4]}
	4  
 ------------------------------------ 
$ declare -a name=(albert sujin sumin)
$ echo ${name}
	albert
$ echo ${name[1]}
	sujin
$ echo ${#name}
	6
$ echo ${name[@]}
	albert sujin sumin

	
  
----------------------------------------------------------------------------------  
### Replace ###
$ Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
$ echo ${Unix[@]/Debian/Linux}
Linux
----------------------------------------------------------------------------------
### Add more elements into array
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
Unix=("${Unix[@]}" "AIX" "HP-UX")
echo ${Unix[7]}
->AIX
----------------------------------------------------------------------------------
### Remove elements from array
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
unset Unix[3]
echo ${Unix[@]}

----------------------------------------------------------------------------------
### * wild including current directory files
#!/bin/sh
for i in hello 1 * 2 goodbye 
do
  echo "Looping ... i is set to $i"
done

----------------------------------------------------------------------------------
https://mywiki.wooledge.org/BashFAQ/006
### How can I use variable variables (indirect variables, pointers, references) or associative arrays?
three parts: associative arrays, evaluating indirect variables, and assigning indirect variables. 
----------------------------------------------------------------------------------
### Associative Array  (bash 4 higher)
	Python: Dictionary {Key:Value} Pair

#!/bin/bash
typeset -A nickName    		# Declare associative array
nickName=(             		# Compound assignment
    [jonathan]=jon			# name=nickName
    [james]=jim
    [alexander]=alex
    [william]=will
    [rebecca]=becky
    [tommy]=tom
    [jack]=john
    [robert]=bob
	
)

nickName[candace]=candy 	# Ordinary assignment adds another single element

for user in "${!nickName[@]}"; do   # Enumerate all indices (user names)
    printf 'Shorten name of user %s is: %q\n' "$user" "${nickName[$user]}"
done

































----------------------------------------------------------------------------------
### Test statement ###
test, [  ], [[  ]]
----------------------------------------------------------------------------------
When writing Bash scripts, do not use the [ command. Bash has a far better alternative: 
[[. Bash's [[ is more reliable in many ways and there are no advantages whatsoever to 
sticking with the old relic. You'll also miss out on a lot of features provided by [[ 
that [ does not have (like pattern matching).
----------------------------------------------------------------------------------
if test  == if [ ]
[ expression ] 
[[ expression ]]  						<= [[ ]] extended e.g. grep, egrep
if (( integer comparison )); then		<= arithmatic

###
if expression
then
	echo "True"
#elif
else
	echo "False"
fi
###
------------------------------------
#!/bin/bash
# Integer comparison
a=5
b=4
if [ $a -gt $b ]; then
	echo "$a is greater than $b."
else
    echo "$a is less than $b."
fi
------------------------------------	
#!/bin/bash
# String matches using REGEX   =~ [0-9]+
a="This is my 1st string!"
if [[ $a =~ [0-9]+ ]]; then
    echo "There are Numbers in the string: $a"
else
    echo "There are no numbers in the string: $a"
fi
------------------------------------
#!/bin/bash
# empty variable or not
if [ -z "$my_var" ]
then
    echo "my_var is an Empty variable!!"
fi







17. if [ $id -u != "0" ] ;then
	echo "You must be the supper user" >&2  						<= user id -u is 0
	exit 1															<= exit status sets to 1(failure)
    fi

	
19. Arithmetic
	echo $(( 1+2 ))
	+, -, *, /, %, **,

------------------------------------	
#!/bin/bash
number=0
echo -n "Enter a number >"
read number
echo "The number is $number"

if [ $(( number %2 )) -eq 0 ]; then
    echo "The number is even"
else
    echo "The number is odd"
fi

-----------------------------------------
# Read : within time to input or expires
-----------------------------------------
# -t timing
# -s security hidden
# -p prompt
-----------------------------------




-----------------------------------
#!/bin/bash
echo -n  "Enter your number before expire within 3sec: "
echo seq 3
	
if read -t 3  -s response; then
    echo "Great, you made it in time"
else
   	echo "Sorry, you are too slow"
fi

----------------------------------------------------------------------------------
### 5 mins (Time counting  ( count down | counting 300 sec ) 
----------------------------------------------------------------------------------
$ for i in $(seq 1 30); do echo -ne "$i" '\r'; sleep 1; done;
$ for i in  `seq 1 30`; do echo -ne "$i" '\r'; sleep 1; done;
$ for i in    {0..300}; do echo -ne "$i" '\r'; sleep 1; done; 
$ for i in    {0..300}; do echo -ne "$i" '\r'; sleep 1; done; echo 

	# \r 	<= returning to begin of line (without new line - \n)
	# -n 	<= new line(do not output the trailing newline)
	# -e 	<= escape (enable interpretation of backslash escapes)


------------------------------------
### Directory or file name

#!/usr/bin/env bash
for myfile in /etc/r*
do
    if [ -d "$myfile" ]
    then
      echo "$myfile is a directory!"
    else
      echo "$myfile is a file name"
    fi
done

----------------------------------------------------------------------------------
# email - IP update script
----------------------------------------------------------------------------------
#!/bin/bash
# If IP Address had been changed, it would send out an email for update.
#set -xeu

current_IP="$(/usr/sbin/ifconfig | grep 'inet'| awk '{print $2}' | head -1)"
TIMESTAMP="$(date +%F)"

# Check if old_IP.txt file is exist or create a file
if [ ! -f "$old_IP_file" ]; then
    touch /home/apark/ipAddress/old_IP.txt
fi

old_IP_file='/home/apark/ipAddress/old_IP.txt'
old_IP=$(cat "${old_IP_file}")

# Actual program
if [[ ${current_IP} != ${old_IP} ]]; then    # != Strings are Not Same
        echo "You have a NEW IP Address = ${current_IP}"
    echo "IP has been changed and need to send an update email...."

    echo -e "Hello\nTime of IP change = ${TIMESTAMP}\nIP = ${current_IP}\nBye"\
                         | /usr/bin/mail -s \
                        "[INFO] IP has been changed to ${current_IP}" \
                        albertpark5@gmail.com

    # Update current_IP to old_Ip_file
    echo ${current_IP}  >  ${old_IP_file}
else
        echo "You have same IP!"
   fi

----------------------------------------------------------------------------------

----------------------------------------------------------------------------------

----------------------------------------------------------------------------------	
# Test statement for Comparison operation [[ expression ]]     0:TRUE  1:FALSE 
----------------------------------------------------------------------------------
	-----------------------------------------------------
	A. Comparing variables(Integer <= Numbers)
	-----------------------------------------------------
		Less than			        [[ $a < $b ]]             = (( $a < $B )) 
		greater than			    [[ $a > $b ]]
		less than or equal to 		[[ $a <= $b ]]
		greater than or equal to 	[[ $a >= $b ]]
		equal(same)			        [[ $a == $b ]]
		not equal(same)		        [[ $a != $b ]]
	-----------------------------------------------------
	B. String comparison
	-----------------------------------------------------
	[[ "cat" == "cat" ]]
	
	a=cat
		b=dog
		[[ $a == $b ]]
		echo $?			<= 1:FALSE 0:TRUE
		
	-----------------------------------------------------
	B. Logical Operations
	-----------------------------------------------------
		AND     [[ $a && $b ]]
		OR   	[[ $a || $b ]] 
		NOT     [[ ! $a ]]
	
	-----------------------------------------------------
	C. Integer Number comparison operations
	-----------------------------------------------------
		less than			         [[ $a -lt $b ]]
		greater than			     [[ $a -gt $b ]]
		less than or equal to 		 [[ $a -le $b ]]
		greater than or equal to	 [[ $a -ge $b ]]
		equal				         [[ $a -eq $b ]]
		not equal			         [[ $a -ne $b ]]
		
	Eg)	[[ 20 -gt 100 ]]
		echo $?
	-----------------------------------------------------
	D. String null value
	-----------------------------------------------------
		is null(EMPTY)?			    [[ -z $a ]]   <= [[ !-z $a ]]
		is not null(EMPTY)?			[[ -n $a ]]   <= [[ !-n $a ]]

		
	Ex)	a=""
		b="cat"
		[[ -z $a && -n $b ]]
		echo $?

		if [ $? == 0 ]; then
			echo "TRUE"
		else
			echo "FALSE"
		fi


-----------------------------------------------------
# Array (can do from prompt)
-----------------------------------------------------
	
	a=()
	b=("apple" "banana" "cherry" "$today" "$time")
	echo ${b[2]}
	b[5]="kiwi"
	b+=("mango")
	echo ${b[@]}            # @ <= whole array
	echo ${b[@]: -1}        # -1 <= last item in array
	
	
	
	
-----------------------------------------------------	
#  cmp vs diff 			
-----------------------------------------------------
	cmp -  compare files byte by byte
	cmp -s $file1 $file2
    
    comm <= Compare two sorted files line by line   

    diff - compare files line by line
	diff $file1 $file2 > /dev/null

	sdiff  <= side by side comparison
	
----------------------------------------------------------------------------------	
# if Condition statement
----------------------------------------------------------------------------------

	a. if condition ; then			<= if condition is true, commands run
		commands
   	   fi							<= if condition is false, do nothing!

	b. if condition ; then  		<= if condition is true, 1st commands run otherwise 
	   	commands   
	   else							<= if condition is false, 2nd commands run
		commands
	   fi

	c. if condition ; then   		<= if condition is true, 1st commands run
	   	commands
	   elif conditions; then 		<= if condition is false, and if the 2nd command is true
	   	commands	 				<= then 2nd set of commands run  	
	   if
	   
	#!/bin/bash
	if [ -f /etc/passwd ]; then     		# -f for file exit?
        	cp /etc/passed .
       		echo "copy done!"
	else
        	echo "Passwd file does not exist"
        	exit 1								<= Failed Exit code
	fi
--------------------------------------------------

	if cmp -s "$file1" "$file2"
		then
			echo "The files match"
	else
	    echo "The files are different"
	fi


----------------------------------------------------------------------------------
# Exit code
----------------------------------------------------------------------------------
	-------------------------------------------
	#!/bin/bash

	touch /root/test 2> /dev/null

	if [ $? -eq 0 ]
	then
  	  echo "Successfully created file"
	  exit 0
	else
	  echo "Could not create file" >&2
	  exit 1
	fi
	-------------------------------------------

	## With the exit command in this script, we will exit with a successful message 
	and 0 exit code if the touch command is successful. If the touch command fails 
	however, we will print a failure message to stderr and exit with a 1 value 
	which indicates failure. ##

	


	
	
	
	
----------------------------------------------------------------------------------
# While loop 
----------------------------------------------------------------------------------
#!/bin/bash
x=1
while
    ((x<10))
do
    echo loop $x; date > data.$x
    ((x=x+1))
done
--------------------------------------------
#!/bin/bash
ls -l /etc | while
        read a b c d
do
        echo "The owner name is  $c."
done
--------------------------------------------
$ ls -l /etc/ | head -n 2
total 1364
-rw-r--r--.  1(No of link to file)  'root'   root       16 Dec  5  2016 adjtime
     $a     $b   					 $c       $d

--------------------------------------------
$while read i; do echo $i; done < while1.sh
--------------------------------------------
#!/bin/bash
i=1
while read file; do
echo "Line $i: $file"
((i++))
done < echo.txt

------------------------------------
#!/bin/bash
i=1
while read file; do
    echo "Line $1: $file"
    (i++))
done < file.txt

Line 1: apple
Line 2: banaba
.......
------------------------------------
#!/bin/bash
# WHILE LOOP - i 가 10보다 적거나 같을때 까지
i=0
while [ $i -le 10 ]; do
    echo i is $i
#   ((i++))
    ((i+=1))
#   ((i=$i+1))
done

### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### 
### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ######

- J 가 10보다 크거나 같을때 가지.
j=0
until [ $j -ge 10 ]; do
    echo j is $j
    ((j++))
done
------------------------------------


#!/bin/bash

INPUT_STRING=hello

while [ "$INPUT_STRING" != "bye" ]
do
  echo "Please type something or type 'bye' to quit!"
  read INPUT_STRING
  echo "You typed '$INPUT_STRING' to exit."
done







33. while and until statement                   <= while & until true statement
	i=0
	while [ $i -le 10 ]; do
        	echo i = $i
        	((i++))
	done			<= 0 ~ 10
-------------------------------------------------
    j=0
    until [$j -ge 10 ]; do
        echo j = $j
       ((j++))
    done			<= 0 ~ 9
--------------------------------------------------

	#!/bin/bash
	x=0			<= initializing to 0
	while [ $x -le 10 ] ; do 
        echo "Current value of X is $x."
        ((x++))
		# x=$(($x + 1 ))
		# x=$(expr $x + 1 )  <= ((x++)                   
        sleep 1
	done
	prints 0 ~ 10
--------------------------------------------------
	x=0;

	while [ $x -gt -10 ] ; do
        echo "X value is $x"
	    ((x--))
	done

--------------------------------------------------
#!/bin/sh
INPUT_STRING=hello
#INPUT_STRING=  		                <= works too
while [ "$INPUT_STRING" != "bye" ]
do
  echo "Please type something in (bye to quit)"
  read INPUT_STRING
  echo "You typed: $INPUT_STRING"
done
--------------------------------------------------	
	
	
--------------------------------------------------		
34. for loops
# goes over per word, not line
--------------------------------------------------	
for i in $(<dataFile.txt)
for i in *.txt
for i in $(find . -name *.txt)

--------------------------------------------------
#!/bin/bash
export a=first
export b=second
export c=thrid
echo a is '['$a']' b is '['$b']' c is '['$c']'
read a b < dataFile.txt
echo a is '['$a']' b is '['$b']' c is '['$c']'
--------------------------------------------------
$ cat dataFile.txt
dog cat rooster
--------------------------------------------------
x="nozatech"
for i in /home/*; do
	echo $x is exist in home directory
done

--------------------------------------------------
#!/bin/bash
for i in dog cat hotdog
do
    echo i is $i
done
#--------------------------------------------------
for i in `seq 3 5`
do
    echo i in seq is $i
done
#--------------------------------------------------
for i in {A..z}
do
    echo i in letter list is $i
done
#--------------------------------------------------
for i in $(<dataFile.txt)					# Per word
do
    echo i in the dataFile.txt is $i
done
#--------------------------------------------------
for i in $(find /etc 2> /dev/null | grep grub)
do
    echo The Grub named things are $i
done
--------------------------------------------------

	
	
35. file
	i=1
	while read f; do
		echo "Line $i: $f"
		((i++))
	done < file.txt	


e.g.
	if [ -f .bashrc ]; then	
	    echo "you have the .bashrc."
	else
		echo "No .bashrc found!"
	fi	

	if [ $(id -u) = "0" ]; then
		echo "supersuser"
	fi


37. read -p "What year?[nnnn] " a
   while [[ ! $a =~ [0-9]{4} ]]; do
       read -p "A year, pelase! [nnnn] " a
   done
   echo "Selected year: $a"

	
	
	
	


----------------------------------------------------------------------------------
38. && ( AND )   

#T&&R    true  && echo runs		<= if cmd1 runs then cmd2 runs also 

#F&&N    false && echo runs		<= if cmd2 fails then cmd2 No runs
	
e.g.	cd $directory && rm -rf *

# Both run in cmd line and bash script
	    *TRUE*	   *RUN!*
	[ ! -d ~/tmp ] && mkdir ~/tmp
	echo $? <= 0  Success

	    *FALSE*	   *NO RUN*
	[ ! -d ~/tmp ] && mkdir ~/tmp
	echo $? <= 1  fail  Did not created!

----------------------------------------------------------------------------------
###  Coding Practice ###
----------------------------------------------------------------------------------
### FIZZBUZZ  ###	

	Prints out when there is a number divied by 3 == 0, then fizz
	Prints out when there is a number divied by 5 == 0, then buzz
	Prints out when there is a number divied by 3 == 0 && 5 == 0, then FizzBuzz

	
	#!/bin/bash  
	for i in {1..100}; do
        if (( i % 3 == 0 )) && (( i % 5 == 0)); then echo "fizzbuzz"
                elif (( i % 3 == 0 )); then echo "fizz"
                elif (( i % 5 == 0 )); then echo "buzz"
        else
                echo $i;
        fi
	done

	
	#!/bin/bash
	for i in {1..100}; do
		if (! ((i % 3)) ) && (! ((i % 5)) ); then echo "FizzBuzz"
			elif (! ((i % 3)) ); then echo "fizz"
			elif (! ((i % 5)) ); then echo "buzz"
		else
			echo $i;
		fi
	done

	### check modulo value from terminal ###
	# m=$(( 1 % 5 ))
	# echo $m
	# 1
	# m=$(( 55 % 5 ))
	# echo $m
	# 0

39. || ( OR )

#T||N    true  || echo runs		<= if cmd1 runs then cmd2 NO runs

#F||R    false || echo runs		<= if cmd1 fails then cmd2 RUNS!

   	     *TRUE*	   *NO RUN*
	[ -d ~/tmp ] || mkdir ~/tmp
	echo $? <= 1  False

	    *FALSE*	   *YES RUN*
	[ -d ~/tmp ] || mkdir ~/tmp
	echo $? <= 0  Created folder!





e.g.    cd $directory || error_exit "No such dir and aborting!"

----------------------------------------------------------------------------------
$ false && echo howdy!
							<= No exit code
$ true && echo howdy!
howdy!
----------------------------------------------------------------------------------
$ true || echo howdy!
							<= No exit code
$ false || echo howdy!
howdy!
----------------------------------------------------------------------------------
"A ; B" Run A and then B, regardless of success of A
"A && B" Run B if A succeeded
"A || B" Run B if A failed
"A &" Run A in background.
----------------------------------------------------------------------------------

if [ -f /root/Sample.txt ]
then
    echo "file found"
else
    echo "file not found"
fi
These 6 lines can be reduced to a single line:

[[ -f /root/Sample.txt ]] && echo "file found" || echo "file not found"



----------------------------------------------------------------------------------
### Function ###
----------------------------------------------------------------------------------
Shell memorizeds the function like it's a new command
$ function helloworld {
	echo "Hello World!"
  }
$ helloworld
	Hello World!
	
------------------------------------------------------
# Single input multiple outputs using function
------------------------------------------------------
#!/bin/bash
string_test() {									# use () instead of 'function' key word
    echo "Print out fomr function string test"
}

function string_test2 {
        echo "1. string test2"
        echo "2. list of arguments is ${@}"			#use double quote for parameters "..."
        echo "3. Nunmber of toal arguments is ${#}"
        echo '4. Exit code with Single quote "$?" <-should be 0'  #Don't use ' ' for $var
        echo "5. All of positional parameters  $*"
}
echo "Running functions 1 & 2"
string_test
echo "-------Func without arguments--------"
string_test2
echo "------Func with 'Hello' 'world' arguments--------"
string_test2 "hello" "world"


------------------------------------------------------

# 'return'  <= functions return when there are no more statements
				or when a return statement is executed.
------------------------------------------------------				
$ function helloworld {
	echo "Hello World!"
	return
	echo "This will not be executed!"
  }

$ helloworld
	Hello World!	
------------------------------------------------------ 	


# Functions produce results by writing 'output' like commands do.
	resultVar=$(printhello)
	
# 'Exit'	
	- exit <VALUE> sets the exit status, represented by '$?' to <VALUE>
		0 - success, 1 - failed, 2 - custom error ...
	- Exit terminates the shell process
	- Exit in a function terminates the whole shell program, not just the function.
	
------------------------------------------------------
# function that exports to a new shell
------------------------------------------
	$ function helloWorld {
	> echo "Hello World!"
	echo "Hello World"
	> return
	> }
------------------------------------------	
	$helloWorld						<= execute function 'helloWorld'
	Hello World
------------------------------------------	
	$export -f helloWorld			<= 'export -f' helloWorld function to new SHELL
	$bash							<= a new Shell
------------------------------------------	
	$ps								<= Check number of shells
	PID TTY          TIME CMD
	10233 pts/3    00:00:00 bash	<= exiting shell
	26462 pts/3    00:00:00 bash	<= New Shell
	26477 pts/3    00:00:00 ps
------------------------------------------	
	$ ps -p $$						<= Checking which shell I am on
	 PID TTY          TIME CMD
	 26462 pts/3    00:00:00 bash
------------------------------------------	
	$helloWorld						<= Execute a new 'helloWorld' from new shell
	Hello World
------------------------------------------
#!/bin/bash
function myFunc {
	echo "Starting myFunc"
	return
	echo "This will not be exectured!"
}

myFunc
n=$(myFunc)								<= put myFunc to 'n' variable
echo "n is $n"

------------------------------------------
#!/bin/bash
# func2.sh

function f2 {
	echo "in f2"
	exit 2						<= TERMINATE Program after exit code 2
	echo "more in f2"
}

echo "Starting"					<= Just echo "Starting"
f2								<= execute f2 function will stop the program!!!!
echo "after f2"					<= After f2 with exit code 2, it will not execute 

------------------------------------------
$ bash func2.sh
Starting
in f2
$ echo $?						<= checking exit code
2


	
	
------------------------------------------------------
# function - hidden file listing  that runs from shell
------------------------------------------------------
$ hidden() { ls -a "$@" | grep '^\.'; }			<= $@  
$ hidden() ( ls -a "$@" | grep '^\.' )			<= using () works too without ; and a space { ls

$ hidden .	 or hidden /home/apark				<= run  and . is current directory	


------------------------------------------------------
#!/bin/bash
function numberthings {		<= Declaring function name
    i=1			<= 
    for f in $@; do		<= $@ special array variable that represents all 
								of the arguments pass to a function
        echo $i: $f
        ((i+=1))			<= incrementing ((i++)) or ((i=i+1))
    done
}
------------------------------------------------------
numberthings $(ls)
numberthings pine birch maple spruce




40. Arguments
------------------
#!/bin/bash
echo $1 $2

$./my.sh "apple Apple" "banana Banana"   <=use " " for when a space in arguments

###
# Don't have to define the variables to saves a lot of time
###

	#!/bin/bash
	for i in $@							<= array arugment $@
	do
		echo $i
	done
	echo "There were $# arugments."     <= $# total number of arguments

$./my.sh apple orange kiwi lemon



---------------------------------------------------------------------------------  
### CASE statement ###
--------------------------------------------------------------------------------

#!/bin/bash
a="dog"
case $a in
    cat)       echo "It is a cat_name";;
    dog|puppy) echo "It is a dog_name";;   				# | <- pipe to match dog or puppy
    *)         echo "No match!";;
esac

------------------------------------
#!/bin/bash
while read i
do
  case $i in
        hello)  echo 1;;
        howdy)  echo 2;;
  esac
done < myfile.txt 
	myfile.txt
	hello
	howdy
------------------------------------
# CASE with Function
------------------------------------
#!/bin/bash
function1()
{
    echo "I am function 1"
} 
function2()
{
    echo "I am function 2"
}
opt=$1
case $opt
in
    u) function1 ;;
    g) function2 ;;
    *) echo "Nothing to do"
       exit ;;
esac	
	
	
	
	
---------------------------------------------------------------------------------
### Function statement ###
---------------------------------------------------------------------------------

#!/bin/bash
function greeting {
	echo "Hello There!"
}
echo "And now, a greeting!"
greeting
------------------------------------
#!/bin/bash
#A function to print "Hello World"
hello()
    {
      echo "Hello World"
    }
hello;
------------------------------------
#!/bin/bash
#function quit {
#    exit
#}
quit() {
	exit
}
function hello {
    echo Hello!
}
hello
quit
------------------------------------
#!/bin/bash
function quit { exit}
function input { echo $1 }    # $1 <-first argument pass to the function, but $@ <- works too.      
input hello
input world
quit  						  # exit
------------------------------------
#!/bin/bash
#numberthings (){
function numberthings {
    i=1
    for f in $@; do
        echo $i: $f
        ((i++))
    done
}

echo "First function"
numberthings $(ls)

echo "Second function"
numberthings pine birch maple spruce
------------------------------------

#!/bin/bash
#function to display commands
display() { echo "\$ $@" ; "$@" ; }
#display() { echo "\$ $@" 
			 echo "$@"  }
display echo hello world

------------------------------------
#!/bin/bash
function greet {
	echo "Hi, $1! What a nice $2!"
}
echo "And now, a greeting!"
greet Albert Morning
greet Everyone Evening






















	
###############################################
# Bash Scripting
###############################################
These are positional arguments of the script. 
position of arguments passed to the script on the command line, not line numbers
#!/bin/sh
echo "$1"
echo "$2"

./script.sh Hello World
$0 = script.sh             <- File name of the current script
$1 = Hello
$2 = World	
	
The $@ variable expands to all the parameters used when calling the function

function foo()
{
    echo "$@"
}
foo 1 2 3


It would display 1 2 3. If not used inside a function, it specifies all parameters 
used when calling the script. See the bash manual page for more info.	
	

 
 
------------------------------------
#!/bin/bash
echo "Hello, World. Calls $# of parameters"	
echo "argument 0 is '$0'"
.....	
echo "argument 9 is '$9'"
echo "argument 10 is '{$10}'"	 # from 10, use {} 

./argument.sh a b ... y z
		Hello, World. Calls 24 of parameters
		argument 0 is './argument.sh'
		argument 1 is 'a'
		.....
		argument 10 is 'j'
	
	
79.Special parameters


  
###############
# FUNCTIONS   #
###############
http://wiki.bash-hackers.org/commands/builtin/local
declare, local, typeset


The function refers to passed arguments by position (as if they were positional parameters), 
that is, $1, $2, and so forth. $@ is equal to "$1" "$2"... "$N", where N is the number of 
positional parameters. $# holds the number of positional parameters.

functname() {
  shell commands
}

unset -f functname  # deletes a function definition
declare -f          # displays all defined functions in your login session

---------------------------------------------------------------
# 2.3. FLOW CONTROL.
---------------------------------------------------------------

statement1 && statement2  # 'and' operator
statement1 || statement2  # 'or' operator

-a                        # and operator inside a test conditional expression
-o                        # or operator inside a test conditional expression

str1=str2                 # str1 matches str2
str1!=str2                # str1 does not match str2
str1<str2                 # str1 is less than str2
str1>str2                 # str1 is greater than str2
-n str1                   # str1 is not null (has length greater than 0)
-z str1                   # str1 is null (has length 0)

-a file                   # file exists
-d file                   # file exists and is a directory
-e file                   # file exists; same -a
-f file                   # file exists and is a regular file (i.e., not a directory or other special type of file)
-r file                   # you have read permission
-r file                   # file exists and is not empty
-w file                   # your have write permission
-x file                   # you have execute permission on file, or directory search permission if it is a directory
-N file                   # file was modified since it was last read
-O file                   # you own file
-G file                   # file's group ID matches yours (or one of yours, if you are in multiple groups)
file1 -nt file2           # file1 is newer than file2
file1 -ot file2           # file1 is older than file2

-lt                       # less than
-le                       # less than or equal
-eq                       # equal
-ge                       # greater than or equal
-gt                       # greater than
-ne                       # not equal
---------------------------------------------------------------

if condition
then
  statements
[elif condition
  then statements...]
[else
  statements]
fi
---------------------------------------------------------------
for x := 1 to 10 do
begin
  statements
end
---------------------------------------------------------------
for name [in list]
do
  statements that can use $name
done
---------------------------------------------------------------
for (( initialisation ; ending condition ; update ))
do
  statements...
done
---------------------------------------------------------------
case expression in
  pattern1 )
    statements ;;
  pattern2 )
    statements ;;
  ...
esac
---------------------------------------------------------------
select name [in list]
do
  statements that can use $name
done
---------------------------------------------------------------
while condition; do
  statements
done
---------------------------------------------------------------
until condition; do
  statements
done

##################################
# 4. INPUT/OUTPUT REDIRECTORS.   #
##################################
cmd1 | cmd2  # pipe; takes standard output of cmd1 as standard input to cmd2
> file       # directs standard output to file
< file       # takes standard input from file
>> file      # directs standard output to file; append to file if it already exists
>|file       #   forces standard output to file even if noclobber is set
n>|file      # forces output to file from file descriptor n even if noclobber is set
<> file      # uses file as both standard input and standard output
n<>file      # uses file as both input and output for file descriptor n
<<label      # here-document
n>file       # directs file descriptor n to file
n<file       # takes file descriptor n from file
n>>file      # directs file description n to file; append to file if it already exists
n>&          # duplicates standard output to file descriptor n
n<&          # duplicates standard input from file descriptor n
n>&m         # file descriptor n is made to be a copy of the output file descriptor
n<&m         # file descriptor n is made to be a copy of the input file descriptor
&>file       # directs standard output and standard error to file
<&-          # closes the standard input
>&-          # closes the standard output
n>&-         # closes the ouput from file descriptor n
n<&-         # closes the input from file descriptor n



##############################
### 5. Regular Expression  ###
##############################
Basic Regular Expression
<Operator>	<Effect>
.			Matches any single character.
?			The preceding item is optional and will be matched, at most, once.
*			The preceding item will be matched zero or more times.
^			Start with(Matches the empty string at the beginning of a line; 
					  also represents the characters not in the range of a list.)
$			Matches the empty string at the end of a line.
+			The preceding item will be matched one or more times.
{N}			The preceding item is matched exactly N times.
{N,}		The preceding item is matched N or more times.
{N,M}		The preceding item is matched at least N times, but not more than M times.
-			represents the range if it's not first or last in a list or the ending point of a range in a list.
\b			Matches the empty string at the edge of a word.
\B			Matches the empty string provided it's not at the edge of a word.
\<			Match the empty string at the beginning of word.
\>			Match the empty string at the end of word.

### Extended regular expressions
	In basic regular expressions the metacharacters "?", "+", "{", "|", "(", and ")" lose their special meaning; 
	instead use the backslashed versions "\?", "\+", "\{", "\|", "\(", and "\)".


e.g.
$ grep ^root /etc/passwd
	root:x:0:0:root:/root:/bin/bash
	
https://regexone.com/problem/matching_decimal_numbers	
Lesson Notes
abc…	Letters
123…	Digits
\d	Any Digit
\D	Any Non-digit character
.	Any Character
\.	Period
[abc]	Only a, b, or c
[^abc]	Not a, b, nor c
[a-z]	Characters a to z
[0-9]	Numbers 0 to 9
\w	Any Alphanumeric character
\W	Any Non-alphanumeric character
{m}	m Repetitions
{m,n}	m to n Repetitions
*	Zero or more repetitions
+	One or more repetitions
?	Optional character
\s	Any Whitespace
\S	Any Non-whitespace character
^…$	Starts and ends
(…)	Capture Group
(a(bc))	Capture Sub-group
(.*)	Capture all
(abc|def)	Matches abc or def

Exercise 1: Matching Characters
Task	Text	 
Match	abcdefg	Success
Match	abcde	Success
Match	abc
=> ^abc

Exercise 1½: Matching Digits
Task	Text	 
Match	abc123xyz	
Match	define "123"	
Match	var g = 123;

=>123 


Exercise 2: Matching With Wildcards
Task	Text	 
Match	cat.	Success
Match	896.	Success
Match	?=+.	Success
Skip	abc1

=> ...\.

Exercise 3: Matching Characters
Task	Text	 
Match	can	Success
Match	man	Success
Match	fan	Success
Skip	dan	To be completed
Skip	ran	To be completed
Skip	pan

=> [cmf]an   or [^drp]an

Exercise 4: Excluding Characters
Task	Text	 
Match	hog	Success
Match	dog	Success
Skip	bog

=> [^b]og   <= not

Exercise 5: Matching Character Ranges
Task	Text	 
Match	Ana	Success
Match	Bob	Success
Match	Cpc	Success
Skip	aax	To be completed
Skip	bby	To be completed
Skip	ccz

=> [A-C][n-p][a-c]


Exercise 6: Matching Repeated Characters
Task	Text	 
Match	wazzzzzup	Success
Match	wazzzup	Success
Skip	wazup

=> waz{3,5}up

Exercise 7: Matching Repeated Characters
Task	Text	 
Match	aaaabcc	Success
Match	aabbbbc	Success
Match	aacc	Success
Skip	a

=> ^aa  || aa+b*c+  || a{2,4}b{0,4,}c{1,2}


Exercise 8: Matching Optional Characters
Task	Text	 
Match	1 file found?	Success
Match	2 files found?	Success
Match	24 files found?	Success
Skip	No files found.

=> \d+ files? found\?

Exercise 9: Matching Whitespaces  '\s' any whitespace
Task	Text	 
Match	1.   abc	Success
Match	2.	abc	Success
Match	3.           abc	Success
Skip	4.abc

=> \d\.\s+abc			. any char

Exercise 10: Matching Lines
Task	Text	 
Match	Mission: successful	To be completed
Skip	Last Mission: unsuccessful	To be completed
Skip	Next Mission: successful upon capture of target

=> ^M  ||    ^Mission: successful$


Exercise 11: Matching Groups
Task	Text	Capture Groups	 
Capture	file_record_transcript.pdf	
Capture	file_07241999.pdf	
Skip	testfile_fake.pdf.tmp

=>  ^(file.+)\.pdf$


Exercise 12: Matching Nested Groups
Task	Text	Capture Groups	 
Capture	Jan 1987	
Capture	May 1969	
Capture	Aug 2011

=> (\w+ (\d+))


Exercise 13: Matching Nested Groups
Task	Text	
Capture	1280x720	
Capture	1920x1600	
Capture	1024x768

=> (\d+)x(\d+)


Exercise 14: Matching Conditional Text
Task	Text	 
Match	I love cats	Success
Match	I love dogs	Success
Skip	I love logs	To be completed
Skip	I love cogs

=> I love (cats|dogs)

























################################
# 7. DEBUGGING SHELL PROGRAMS. #
################################

bash -n scriptname   # don't run commands; check for syntax errors only
set  -o noexec       # alternative (set option in script file)

bash -v scriptname   # echo commands before running them
set  -o verbose      # alternative (set option in script file)

bash -x scriptname   # echo commands after command-line processing
set  -o xtrace       # alternative (set option in script file)


### Trap : using signals
		to catch the listed SIGNALS, which may be signal names with or without 
		the SIG prefix, or signal numbers
http://redsymbol.net/articles/bash-exit-traps/
	The Bash 'trap' command is for signal handling
		- Change behavior of signals within a script
		- Ignore signals during critical sections in a script
		- Allow the script to die gracefully
		- Perform some operations when a signal is received

# List of Singals
	$ kill -l		
# Number	SIG	Meaning
0	0	On exit from shell
1	SIGHUP	Clean tidyup
2	SIGINT	Interrupt  		<= CTRL+C
3	SIGQUIT	Quit
6	SIGABRT	Abort
9	SIGKILL	Die Now (cannot be trap'ped)
14	SIGALRM	Alarm Clock
15	SIGTERM	Terminate
		
---------------------------------------		
Trap is a simple, but very useful utility. If your script creates temporary files, such as 
this simple script which replaces FOO for BAR in all files in the current directory, /tmp is 
clean when the script exits. If it gets interrupted partway through, though, there could be 
a file lying around in /tmp:
---------------------------------------	
#!/bin/bash
trap cleanup 1 2 3 6
### Function ###
cleanup()
{
	echo "Caught Signal ... cleaning up."
	rm -rf /tmp/tmp_*.$$
	echo "Done cleaningup ... quitting."
	exit 1
}
### Main Script ###
for i in *
do
	sed 's/FOO/BAR/g' $i > /tmp/temp_${i}/$$ && mv /tmp/temp_${i}.$$   $i
done
		
		
		
http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html
---------------------------------------
#!/bin/bash
# traptest.sh
trap "echo Booh!' SIGINT SIGTERM
echo "pid is $$"
while :					# This is the same as "while true"
do
	for i in {1..5}; do echo -ne $i '\r'; sleep 1; done; echo
done
---------------------------------------		
CTRL+C 
	^CBooh!				<= out put
	
		
		
		
		
		
		
		
		
		
		
		
		

trap 'echo $varName' EXIT  # useful when you want to print out the values of variables 
			     at the point that your script exits
			 
				 
function errtrap {
  es=$?
  echo "ERROR line $1: Command exited with status $es."
}

trap 'errtrap $LINENO' ERR  # is run whenever a command in the surrounding script or function exists with non-zero status 

function dbgtrap {
  echo "badvar is $badvar"
}

trap dbgtrap DEBUG  # causes the trap code to be executed before every statement in a function or script
# ...section of code in which the problem occurs...
trap - DEBUG  # turn off the DEBUG trap

function returntrap {
  echo "A return occured"
}

trap returntrap RETURN  # is executed each time a shell function or a script executed with the . or source commands finishes executing



















#-----------------------------------------------------------
# Fibonacci Script	
#-----------------------------------------------------------
Write a script to print the first 10 elements of Fibonacci series.
http://www.bashguru.com/2010/12/shell-script-to-generate-fibonacci.html

#-----------------------------------------------------------
$ a=1;b=1;for i in `seq 8`;do echo $((x=b,b=a+b,a=x));done
#-----------------------------------------------------------
$ echo $((b=1,a=0));for i in `seq 8`;do echo $((x=b,b=a+b,a=x));done
#-----------------------------------------------------------

-----------------------------------------
#!/bin/bash -x
a=1
b=1
echo $a
echo $b
for i in 1 2 3 4 5 6 7 8
do

c=`expr $b + $a`
b=$a
a=$c

echo $c
done
-----------------------------------------
### 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
-----------------------------------------

------------------------------------------------------
# Copy file to remote servers
------------------------------------------------------
#!/bin/bash
# Copy file to remote servers, Chmod +x, Run script

ids=noza  							#Source ID
idd=noza  							#destination ID

kcks="/home/$ids/rkchk.sh"      	# Source sh
kckd="/home/$idd/rkchk.sh"      	# destin sh

# list=$(cat "/home/$ids/slist")    #list of servers
list='192.168.232.158'

echo ------------------------------------
echo SCP is copying over to remote server
echo ------------------------------------
# bash -c  

for i in $list; do
	echo ------------------------------------
    echo $i >> log
	echo ------------------------------------

	scp $kcks $idd@$i:/home/$idd/

		echo "changing perm to running mode"

	ssh -t $idd@$i chmod +x $kckd

		echo "kernel ver check and report to logs file"

	ssh -t $idd@$i bash -c $kckd 2>&1 >> log

		echo ------------------------------------
		echo ------------------------------------
done

#------------------------------------------------------
#
#------------------------------------------------------
#!/bin/bash

hosts='host1 host2 host3'
sup='sup!123'

for i in $hosts; do
   echo "***** We are: $i *******"

    ssh -t $i <<EOCommand
        for d in $hosts
        do
            echo "******** Logging in from $i to: \$d *********"
            ssh \$d exit

            if [ $? = 0 ]; then
                echo "SSH login successful!"
            else
                echo "SSH login failed!"
            fi
        done
EOCommand
    echo "Finished block for $i"
done
#------------------------------------------------------

#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/rr")

echo ------------------------------------
echo SCP is copying over to remote server
echo ------------------------------------

for i in $list; do

     echo $i >> logs

 scp $kcks $idd@$i:/home/$idd/

     echo $kcks is copied.

     echo changing perm to running mode

 ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

     echo kernel ver check and report to logs file
     echo ---------------------------------------

done


#------------------------------------------------------

#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/rr")

for i in $list; do

    echo $i >> logs

    scp $kcks $idd@$i:/home/$idd/

    if ssh $idd@$i stat $kckd; then

        echo $kcks is copied.

    else

        echo $kcks is NOT copied!!!

    fi

    echo changing perm to runing mode

    ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

        echo kernel ver check and report to logs file

        echo ---------------------------------------

done

#------------------------------------------------------
#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"							<= file pointing
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/rr")							<= invoke file

for i in $list; do											

    echo $i >> logs

    ssh -q $idd@$i "test -e $kckd"		

        if [ $? -eq 0 ]; then

        echo $kcks is already existed.

        ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

    else

        scp $kcks $idd@$i:/home/$idd/

        ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

    fi

done


#------------------------------------------------------





#------------------------------------------------------


###   ###
RED="\033[1;31m"
YELLOW="\033[1;33m"
GREEN="\033[1;32m"
BOLD="\033[1m"
RESET="\033[0m"

echo -e "\033[1;31m" vulnerable kernels CentOS 5, 6 and 7.  "\033[0"
echo -e "${RED}      vulnerable kernels CentOS 5, 6 and 7. ${RESET}"
		# -e     enable interpretation of backslash escapes

### Without "-e" 
$echo "\033[1;31m" vulnerable kernels CentOS 5, 6 and 7. "\033[0"
	   
	   \033[1;31m vulnerable kernels CentOS 5, 6 and 7. \033[0			<=have to use "-e"


#--------------------------------------------------------------------------------
#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/i7")

for i in $list; do
    echo "------------------------------------------------" | tee -a logs
    echo $i | tee -a logs
    echo "------------------------------------------------" | tee -a logs
    ssh -q $idd@$i "test -e $kckd"
        if [ $? -eq 0 ]; then
            echo "$kckd is already exit" | tee -a logs
        else
            echo "$kckd is copying and running"
            scp $kcks $idd@$i:/home/$idd
            ssh -t $idd@$i "bash -c $kckd" 2>&1 | tee -a logs
        fi
    echo "------------------------------------------------" | tee -a logs
done
#--------------------------------------------------------------------------------

Count down 5 mins from SHELL
--------------------------------------
ct=$((5 * 60))           # 5 mins
while [ $ct -gt 0 ]; do
   echo -ne "$ct\033[0K\r"
   sleep 1
   : $((ct--))
done
------------------------------------------------------------------------------------------
"\033[0K" represents an end of line which cleans the rest of line if there are 
any characters left from previous output and \r is a carriage return which moves the cursor to the 
beginning of the line. There is a nice thread about this feature at stackoverflow.com.
http://stackoverflow.com/questions/12628327/how-to-show-and-update-echo-on-same-line
#--------------------------------------------------------------------------------




#--------------------------------------------------------------------------------
# Alternative using find and git diff 
https://stackoverflow.com/questions/16787916/difference-between-two-directories-in-linux
find /dir1/ -type f -exec md5sum {} \;    >    dir1.txt
find /dir2/ -type f -exec md5sum {} \;    >    dir2.txt
diff dir1.txt dir2.txt

git diff --no-index dir1/ dir2/

#--------------------------------------------------------------------------------
### 5 mins count down from Shell ###
$ for i in {1..300}; do echo -ne $i '\r'; sleep 1; done; echo
#--------------------------------------------------------------------------------


Function 


------------------------------------------------------
# PID 
------------------------------------------------------
get_ntopng_pid() {
if [ -f "/etc/ntopng/ntopng.conf" ]; then
PID_FILE=$(cat /etc/ntopng/ntopng.conf | grep -E '-G=|--pid'|cut -d '=' -f 2)
else
PID_FILE="/var/tmp/ntopng.pid"
fi

------------------------------------------------------
# fork bomb 
------------------------------------------------------
https://www.cyberciti.biz/faq/understanding-bash-fork-bomb/
$ :(){ :|:& };:
denial-of-service (DoS) attack against a Linux based system
is nothing but a bash function. This function get executed recursively. It is often used 
by sys admin to test user process limitations. Linux process limits can be configured via 
/etc/security/limits.conf and PAM

:(){
 :|:&
};:
#--------------------------------------------------------------------------------


	
----------------------------------------------------------------------------------------	
### High memory usage 	
*/30 * * * * /home/apark/checkMemUsage.sh > /dev/null 2>&1
--------------------------------------------------------------------------
#!/bin/bash
# Purpose: If memory usage over 80%, restart HTTPD #

# Check top % memory usage app value
memUsage=`top -o %MEM -bn 1 | awk '8 <=NR && NR <=8' | awk '{print $10}'`
memUsage=$( printf "%.0f" $memUsage )

if (( $memUsage > 80));
then
    apachectl restart
fi
--------------------------------------------------------------------------	
#or#	??  
if [ $memUsage -gt 80 ];
    apachectl restart
fi
	
###---------------------------------------
### 116 Bash Scripts  ###
### https://mywiki.wooledge.org/BashFAQ/
###---------------------------------------
1. How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
https://mywiki.wooledge.org/BashFAQ/001
----------------------------------------------
#!/bin/bash
while IFS= read -r line; do			# -r option to read prevents backslash interpretation
	printf '%s\n' "$line"			# %s string, \n new line
	#echo $line
done < "$file"
----------------------------------------------

### Get GECOS 
/etc/passwd
user  :pw:uid:gid:gecos : home             : shell
icinga:x :992:987:icinga:/var/spool/icinga2:/sbin/nologin

https://superuser.com/questions/1031615/the-other-finger-gecos-fields-at-etc-passwd
$ awk -F ":" '{print $5}' /etc/passwd

### Grep User & Shell from /etc/passwd file ##
--------------------------------------------------------------
#!/bin/bash
while IFS=: read -r user pass uid pid gecos home shell; do
        printf '%s: %s\n' "$user" "$shell"
done < /etc/passwd
--------------------------------------------------------------
# This reads one filename at a time from the find command and renames the file, 
# replacing spaces with underscores.
--------------------------------------------------------------
#!/bin/bash
find . -type f -print0 | while IFS= read -r -d '' file; do
	mv "$file" "${file// /_}"									#??? Not Working
done
--------------------------------------------------------------

----------------------------------------------------------------------------------------
2. How can I store the return value and/or output of a command in a variable?
https://mywiki.wooledge.org/BashFAQ/002
----------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------
3. How can I sort or compare files based on some metadata attribute (newest / oldest 
	modification time, size, etc)?
https://mywiki.wooledge.org/BashFAQ/003
----------------------------------------------------------------------------------------
#!/bin/bash
# Newest(Latest) files in a directory
# same as $ls -lt | head -n 2 | tail -n 1 
unset -v lastest
for f in "$dir"/*; do
	[[ $f -nt $lastest ]] && lastest=$f  		# -nt First file is newer than second one	
done												# &&  If 1st ok, then run 2nd
printf '%s\n' $lastest
-------------------------------------------------------------
#!/bin/bash
# Oldest
unset -v oldest
for file in "$dir"/*; do
	[[ -z $oldest || $file -ot $oldest ]] && oldest=$file  # -ot Older than
done
-------------------------------------------------------------
#Using find & sort
#!/bin/bash
IFS= read -r -d '' lastest \
	< <(find "$dir" -type f -printf '%T@ %p\0' | sort -znr)
lastest=${lastest#* }

#!/bin/bash
while IFS= read -rd '' time; do
	IFS= read -rd '' 'lastest[time]'
done < < (find "$dir" -type f -printf '%Ts\0%p\)'
lastest=[{latest[-1]}
-------------------------------------------------------------
#Using find & sort
#!/bin/bash
unset -v latest time
while IFS= read -r -d '' line; do
  t=${line%% *} t=${t%.*}   # truncate fractional seconds
  ((t > time)) && { latest=${line#* } time=$t; }
done < <(find "$dir" -type f -printf '%T@ %p\0')
-------------------------------------------------------------
$ find "$dir" -type f -printf '%T@ %p\0\n'


----------------------------------------------------------------------------------------
4. How can I check whether a directory is empty or not? 
   How do I check for any *.mpg files, or count how many there are?
https://mywiki.wooledge.org/BashFAQ/004
----------------------------------------------------------------------------------------
$ mkdir ../004 && cd ../004
In Bash, you can do this safely and easily with the nullglob and dotglob options 
(which change the behaviour of globbing), and an array:
----------------------------------------------
#!/bin/bash
shopt -s nullglob dotglob		# -s set(on)		
file=(*)
(( ${#file[*]} )) || echo "Dictory is empty"
shopt -u nullglob dotglob		# -s unset(off)
----------------------------------------------

#!/bin/bash
if (shopt -s nullglob dotglob; f=(*); ((! ${#f[@]}))); then
    echo "The current directory is empty!"
fi

----------------------------------------------
#!/bin/bash
# -L FILE exists and is a symbolic link (same as -h)
shopt -s dotglob
file=(*)
if [[ -e ${files[0]} || -L ${files[0]} ]]; then
	echo "Not empty. It contains: "
	printf '%s\n' "${files[@]}"
fi

----------------------------------------------------------------------------------------
5. 


















# ---------------------------------------------------------------------------
### Usage of an infinite loop and the break statement: ### 
# ---------------------------------------------------------------------------
#!/bin/bash
# Purpose: Display various options to operator using menus
# Author: Vivek Gite < vivek @ nixcraft . com > under GPL v2.0+
# https://www.cyberciti.biz/faq/bash-infinite-loop/
# ---------------------------------------------------------------------------
# Usage: Capture CTRL+C, CTRL+Z and QUIT singles using the trap
# ---------------------------------------------------------------------------

trap '' SIGINT   #2  Signal Interupt as CTRL+C
trap '' SIGQUIT  #3  
trap '' SIGTSTP  #20 Signal Stop as CTRL+Z
 
# display message and pause 
pause(){									# pause() function
	local mesg="$@"							# local makes within function variable
	echo "$mesg"				 		
	read -p "Press [Enter] key to continue..."   key			# key <-input value 
			# -p prompt output the string PROMPT without a trailing 
			#    newline before attempting to read
}
 
# set an 
while :   # same as 'while true'
do
	# show menu
	clear
	echo "---------------------------------"
	echo "	     M A I N - M E N U"
	echo "---------------------------------"
	echo "1. Show current date/time"
	echo "2. Show what users are doing"
	echo "3. Show top memory & cpu eating process"
	echo "4. Show network stats"
	echo "5. Exit"
	echo "---------------------------------"
	read -r -p "Enter your choice [1-5] : " c
	# take actions
	case $c in
		1) pause "$(date)";;
		2) w| less;;
		3) echo       '*** Top 10 Memory eating process:'; ps -auxf | sort -nr -k 4 | head -10; 
		   echo; echo '*** Top 10 CPU eating process:';    ps -auxf | sort -nr -k 3 | head -10; 
		   echo;  pause;;
		4) netstat -s | less;;
		5) break;;
		*) Pause "Select between 1 to 5 only"
	esac
done

#---------------------------------------------------------------------------

$ while :; do clear; your_command; sleep 2; done  	<= : is TRUE or while true or while []

# ---------------------------------------------------------------------------
#!/bin/bash
# usage: watch.sh <your_command> <sleep_duration>

while :; 			### : <= is true
  do 
  clear
  date
  $1
  sleep $2
done

#---------------------------------------------------------------------------



### Calculator Script ###
---------------------------------------------------------------------------
#!/bin/bash
# Calculator
#set -xeu  					#debug, error exit, check undefined Vars

clear

#if [ $(id -u) != 0 ]; then
#  echo "Only root may run this program." ; exit 1
#fi

if [ $# != 3 ]; then
  echo "You did not run the program correctly"
  echo "Example:  calculator 4 + 5"
  exit 1
fi

# Now do the math (note quotes)
if   [ "$2" = "+" ]; then echo "Answer is `expr $1 + $3`"
elif [ "$2" = "-" ]; then echo `expr $1 - $3`
elif [ "$2" = "*" ]; then echo `expr $1 \* $3`
elif [ "$2" = "/" ]; then echo `expr $1 / $3`
fi
exit 0      #Successful
---------------------------------------------------------------------------





# Arithmatic (산수 계산)
---------------------------------------------------
(( ... )) 			Arithmatic
[1+2]				Deprecated Arithmatic
let a=1+1			Arithmatic

---------------------------------------------------
# Test Statement
---------------------------------------------------
[ $a -eq $ ]	Test statement old style
[[ ... ]] 		Test statement extended




---------------------------------------------------------------------------
# Script - Guessing Number
---------------------------------------------------------------------------
#!/bin/bash
random=$RANDOM
secret=${random:0:1}

function game
{
	read -p "Guess a random one-digit number!" guess
	while [[ $guess != $secret ]]; do
		read -p "Nope, try gain!" guess
	done
	echo "Good job, the $secret is it! You are great at guessing!"
}
	
function generate
{
	echo "A random number is: $random"
	echo -e "Hint: type \033[1m$0 game\033[0m for a fun diversion!"
}

if [[ $1 =~ game|Game|GAME ]]; then
	game
else
	generate
fi
---------------------------------------------------------------------------





---------------------------------------------------------------------------
# Script - Network Status Report
---------------------------------------------------------------------------
#!/bin/bash

# Network status report script
#
# ping localhost | tail -2 result
# 3 packets transmitted, 3 received, 0% packet loss, time 1999ms
# rtt min/avg/max/mdev = 0.055/0.061/0.067/0.010 ms
#
ping='ping -c3 localhost | tail -2'

lost='echo $ping | cut -d"," -f3 | cut -d" " -f2'
#
# 0%
# min/avg/max/mde

delay='echo $ping | cut -d"=" -f2 | cut -d"." -f1'
#
# 3 packets transmitted, 3 received, 0% packet loss, time 2000ms
# 0


if [ "$loss" = "100%" ] ; then
        echo localhost is NOT repsponding at all

elif [ "$loss" != "0%" ] ; then
        echo localhost is responding with packget loss

else
# else for between 100% and 0%

        if [ "$delay" -lt 100 ] ; then
                echo localhost is responging normally
        else
                echo localhost is responding slow
        fi
fi

---------------------------------------------------------------------------





























