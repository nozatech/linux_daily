"한 줄의 코딩을 하더라도 실제로 사용할 수 있는 것을 만들자!"

######################
### 1. Run Scripts ###
######################

https://explainshell.com/
https://www.shellcheck.net/
$ apt-get | yum install shellcheck	-y

---------------------------------------------------
# Overview of set debugging options
---------------------------------------------------
	set -f	(set -o noglob)		Disable file name generation using metacharacters(globbing).
	set -v	(set -o verbose)	Prints shell input lines as they are read.
	set -x	(set -o xtrace)		Print command traces before executing command.
	set -e          # Exit as soon as any line in the bash script fails
	set -x          # Prints each command executed (prefix with ++)
	set -ex         # Do both (for good practice)	

	e.g. in script, add 'set -x' line
	#!/bin/bash
	set -x			<= debug mode
	
---------------------------------------------------
# How to run a script
---------------------------------------------------
	$ ./script.sh					 <= run in seperate shell
	$ . ./script.sh   			     <= current login shell to run

    $ sh ./script.sh  				 <= same as 'sh script.sh')
    $ sh +x script.sh   			 <= +x for debuging mode
    $ sh -x script.sh   			 <= +x for debuging mode
    $ sh -v script.sh   			 <= -v for debuging mode
    $ sh +v script.sh   			 <= +v for debuging mode

    $ exec ./script   				 <= after run, the login shell exit 

	$ bash script.sh
	$ bash ./script.sh
	$ bash -x  script.sh			 <= debug mode
	$ bash -v 
	
	$ source script.sh
	

	*** $ source .bashrc						<= reload .bashrc

	# run script as a different user from root
	$ wget http://tecmint.com/wp-content/scripts/tecmint_monitor.sh
	$ su -c "/home/apark/tecmint_monitor.sh" - root
	$ ./tecmint_monitor.sh -i    <- install
	$ monitor

---------------------------------------------------	
# VI: Run script WITHIN vim or vi
---------------------------------------------------
    :w   	      					<= write first
    :!sh %   (# :! sh %)     		<= : <-cmd ! <-run, sh <-shell, % =currently open file
	:!!         					<= run same script again 
    :!./script_name.sh
    :! python %
    :! perl %

---------------------------------------------------
# VI: Save in read only file ###
---------------------------------------------------
	:w !sudo tee %                  	<= save as sudo privilege.  type (L) load at the prompt to reload.
	:w !chmod 777 %    then    :wq!
	
	:h									<= vi, vim help 			
	:q 									<= quit help page
	
	$ vi +101 file.txt					<= go to 101 line in filename
	:12									<= Go to particular line number in vi editor 
	
# Move	
	:15 <- go to 15th line
	$ vi +15 script.sh
	G 					<= go to bottom of page
	
	o					<= insert underneath line
	
---------------------------------------------------	
# VI: Search and replace 	( http://vim.wikia.com/wiki/Search_and_replace )
---------------------------------------------------
    :s/foo/bar/g					<= current line only
	:%s/foo/bar/gc					<= % all, c to confirm first but also INSENSITVE
	#:%s/foo/bar/gci				<= i insensitive(save as above cmd)
	
	:%s/\<foo\>/bar/gc				<= Change only whole words exactly matching 'foo' to 'bar'
	
	# blank line delete
	:g/^$/d							<= :g will execute a command on lines which match a regex. 
										The regex is 'blank line'  
										:d (delete)
										
---------------------------------------------------								
# Debug mode	
---------------------------------------------------
    #!/bin/bash -x 					<= add " -x " for debugging mode in #!/bin/bash script
    $ bash -x ./script.sh  			( same as 'bash script.sh') 
    $ bash -vx script.sh			<= add -xv from shell -v <-verbose -x <-debug
	:! sh -x %						<= -x is for DEBUG(verbose) mode
    set -x              			<= End of file +x for TURN OFF
	$ bash -n ./script.sh 			<= checking syntax error
	
 # Stop and Exit running program
	$ vi 1.sh
      crtl + z 						<= exit to shell
	$ vi 2.sh
	$ jobs
	[1] Stopped  vim
	[2] Stopped  vim
	$ fg %1							<= go back to 1.sh
	ctrl + z
	$ kill %2
	$ kill -9 %2

---------------------------------------------------
# Run from background
---------------------------------------------------
    $ ls -alR > /tmp/result.txt 2> /tmp/error.txt &
	$ jobs
	[1]+  Stopped                 vim
	[2]-  Stopped                 vim
	[3]   Done                    ls --color=auto -alR > /tmp/result.txt 2> /tmp/error.txt

	
---------------------------------------------------
### Environment Variable  ####
---------------------------------------------------
$ var	        	   #Value of shell variable var.
$ var=value		       #Assign the string value to shell variable var.
	$var=5222
	$ echo $var
	$ echo ${var}
	  52222
	$ echo ${var}5    # appending '2' to $var.
	  522225  				
	$ length=${#var}	<- length of variable
	$ echo $length
	  5
	  
---------------------------------------------------
### Local Variable  ####
---------------------------------------------------	  
	- variables can be created in a function that will not be available outside of it
	- variables only set within a function
	  
	- The typeset cmd makes variables local, can provide a type, or can provide formatting.
	$ typeset -i x		<= x must be an integer
		-Arithmatic is faster
		- Let allows for convenient arithmetic:
		  let x++; let y=x**2; let x=x*3; let x*=5, ...
--------------------------	  
#!/bin/bash
function f1 {
	typeset x
	x=7
	x=8
}
x=1
y=2
echo x is $x
echo y is $y
f1
echo x is $x
echo y is $y
--------------------------
x is 1
y is 2
x is 1
y is 8		  
		  
		  
---------------------------------------------------
### Declare  ####
---------------------------------------------------	
https://unix.stackexchange.com/questions/254367
When used in a function, declare makes NAMEs local, as with the local command. 
The -g option suppresses this behavior.

abc=ok assigns a value to the variable abc. declare abc declares a variable called abc. 
The two can be combined as declare abc=ok.

In bash, like other shells, string and array variables don't need to be declared, so declare 
isn't necessary unless you want to pass options, e.g. declare -A abc to make abc an associative 
array or declare -r to make a variable read-only. However, inside a function, declare does 
make a difference: it causes the variable to be local to the function, meaning that the value 
of the variable outside the function (if any) is preserved. (Unless you use declare -g, which 
makes the variable not local; this is useful when combined with other options, e.g. declare -gA 
to create a global associative array in a function.) 

Example:
---------------------------------------------------	
f () {
  declare a
  a='a in f'
  b='b in f'
  echo "From f: a is $a"
  echo "From f: b is $b"
}
a='Initial a'
b='Initial b'
f
echo "After f: a is $a"
echo "After f: b is $b"

Output=>
From f: a is a in f
From f: b is b in f
After f: a is Initial a
After f: b is b in f


The declare builtin is unique to bash. It's strongly inspired and very close to ksh's 
typeset builtin, and bash provides typeset as a synonym of declare for compatibility. 
There's a third synonym, local. 
There's also export, which is the same as declare -x, again for compatibility 
(with every Bourne-style shell).

----------------------------------------------------	  
	 $ declare -l uppercase values in the variable are converted to lowercase
	 $ declare -u lowercase values in the variable are converted to uppercase
	 $ declare -r variable is made read-only
	 $ declare -a MyArray will make MyArray an indexed array.
	 $ declare -A MyArray2 will make MyArray2 an Associative array.
----------------------------------------------------
#!/bin/bash
declare -l lowerString="ABCdef"
declare -u upperString="ABCdef"
declare -r readOnly="A Value"
declare -a MyArray
declare -A MyArray2

echo lowerString = $lowerString
echo upperString = $upperString
echo readOnly = $readOnly

readOnly="New Value"

MyArray[2]="Second Vlaue"
echo 'MyArray[2] = '${MyArray[2]}

MyArray2["hotdog"]="baseball"
echo 'MyArray2[hotdog]= ' ${MyArray2["hotdog"]}
----------------------------------------------------

 	 
	 
	 
	 
	 
	 

---------------------------------------------------
# Combines 2 or more commands
---------------------------------------------------
cmd1; cmd2     #Do cmd1 and then cmd2.
cmd1 & cmd2    #Do cmd1, start cmd2 without waiting for cmd1 to finis

cmd1 && cmd2   		  #Run cmd1, then if cmd1 successful run cmd2, otherwise skip.
cmd1 && cmd2 && cmd3  #Run cmd1, then if cmd1 successful run cmd2, otherwise skip.
cmd1 || cmd2   		  #Run cmd1, then if cmd1 not successful run cmd2, otherwise skip.
cmd1 || cmd2 || cmd3  #Run cmd1, then if cmd1 not successful run cmd2, not cmd2 runs cmd3 otherwise skip.



	
!     # not
-a    # and
-o    # or	

	
---------------------------------
# File Descriptor,  Redirection, Pipes
---------------------------------
https://en.wikipedia.org/wiki/File_descriptor
File Desciptor 0, 1, and 2 reservered as:
	0 - stdin  (Standard input)
	1 - stdout (Standard output)
	2 - stderr (Standard Error)

Command > stdout-here 2> stderr-here < stdin-from-here

command 2>&1| command2		<= same
command |&    command2		<= same(variable by different shell

command &> file			

command <<  				<= Here is a document
$ sort << EOF
	orange
	apple
	banana
	EOF
	
# Open and Close File Descriptors ????????????????
- exec N< myfile  <= opens file descriptor N for 'reading' from file 'myfile'
- exec N> myfile  <= opens file descriptor N for 'writing' from file 'myfile'
- exec N<> myfile  <= opens file descriptor N for 'reading & writing' from file 'myfile'
- exec N<> myfile  <= opens file descriptor N for 'writing' from file 'myfile'
	
	
	
	
- lsof	<= use 'lsof' to what fil desriptors for a proces are open
	$ lsof -p $$		<= $$ Processor ID
	
	
	
	
	
	
	
	
	
	
----------------------------------------------
# I/O Redirection:
----------------------------------------------	

pgm > file     #Output of pgm is redirected to file.
pgm < file     #Program pgm reads its input from file.
pgm >> file    #Output of pgm is appended to file.
pgm1 | pgm2    #Output of pgm1 is piped into pgm2 as the input to pgm2.
n > file       #Output from stream with descriptor n redirected to file.
n >> file      #Output from stream with descriptor n appended to file.
n >& m         #Merge output from stream n with stream m.
n <& m         #Merge input from stream n with stream m.
<< tag         #Standard input comes from here through next tag at start of line.	
cmd << 		   # here document

	# stderr
		$ ls +
		  ls: cannot access +: No such file or directory			<= stderr
		$ ls +   2>  error.txt
		
	$ cmd 2> stderr.txt 1> stdout.txt
	$ cmd 2&>1	> output.txt 
	$ cmd &> 	> output.txt ( &> is same as 2&>1 )
	$ cmd > /dev/null
	$ cmd > /dev/null 2&>1
	
	$ cmd | tee file1 file2
	$ cmd | tee -a file1 		
	
	$ cmd < file.txt
	$ cmd &>> output.txt
	
---------------------------------------------------	
#!/bin/bash
echo Redirect the out put to grub.out using '>'
find /etc -name grub > grub.out
echo "The result of grub.out file"
cat grub.out
echo ------------------------------------------

echo Sending error to errs.out using '2>'
find /etc   -name grub 2> errs.out
cat errs.out
echo ------------------------------------------

echo "Redirect both STDOUT & STDERR using '&>'"
find /etc -name grub &> both.out
cat both.out
	
---------------------------------------------------	
# Shell Built-in Variables:
----------------------------------------------	
$0             # Name of this shell script itself.
$1             # Value of first command line parameter (similarly $2, $3, etc)
$@			   # 
$#             # In a shell script, the number of command line parameters.
$*             # All of the command line parameters.
$-             # Options given to the shell.
$?             # Return the exit status of the last command. 0 - Successful, 1 -fail
$$             # Process id of script (id of the shell running the script)	

The shell treats several parameters specially. These parameters may only be referenced; assignment to them is not allowed.

*
($*) Print all the parameter.
	 Expands to the positional parameters, starting from one. When the expansion is not within double quotes, 
     each positional parameter expands to a separate word. In contexts where it is performed, those words are 
	 subject to further word splitting and pathname expansion. When the expansion occurs within double quotes, 
	 it expands to a single word with the value of each parameter separated by the first character of the IFS 
	 special variable. That is, "$*" is equivalent to "$1c$2c…", where c is the first character of the value 
	 of the IFS variable. If IFS is unset, the parameters are separated by spaces. If IFS is null, the parameters 
	 are joined without intervening separators.

@
($@) Individually double quoted 
	Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, 
	each parameter expands to a separate word. That is, "$@" is equivalent to "$1" "$2" …. If the double-quoted 
	expansion occurs within a word, the expansion of the first parameter is joined with the beginning part of the 
	original word, and the expansion of the last parameter is joined with the last part of the original word. 
	When there are no positional parameters, "$@" and $@ expand to nothing (i.e., they are removed).

#
($#) Expands to the number of positional parameters in decimal(Counts number of parameters).	
 
($?) Exit status of the last command
	0 - successful
	1 - fail
	e.g. echo $?
($$) Process ID under which order getting executed

(?!) Process ID of the last background command

---------------------------------------------------  	
# Pattern Matching:
----------------------------------------------	

*              #Matches 0 or more characters.
?              #Matches 1 character.
[AaBbCc]       #Example: matches any 1 char from the list.
[^RGB]         #Example: matches any 1 char not in the list.
[a-g]          #Example: matches any 1 char from this range.	
	
Quoting:

\c             #Take character c literally.
`cmd`          #Run cmd and replace it in the line of code with its output.
"whatever"     #Take whatever literally, after first interpreting $, `...`, \
'whatever'     #Take whatever absolutely literally.	

Example:
match=`ls *.bak`        #Puts names of .bak files into shell variable match.
echo \*                 #Echos * to screen, not all filename as in:  echo *
echo '$1$2hello'        #Writes literally $1$2hello on screen.
echo "$1$2hello"        #Writes value of parameters 1 and 2 and string hello.
	
-------------------------------------------------------------------
# Arithmetic: BASH arithmetic is done using the expr command as in:
-------------------------------------------------------------------			
result=`expr $1 + 2`   				<= ` back tic
result=`expr $2 + $1 / 2`
result=`expr $2 \* 5`               #note the \ on the * symbol

brace expansion         (see a reference book)
~ expansion             (for login ids)
parameters              (such as $1)
variables               (such as $var)
command substitution    (Example:  match=`grep DNS *` )
arithmetic              (from left to right)
word splitting
pathname expansion      (using *, ?, and [abc] )



---------------------------------------------------	
### Script running remotely
---------------------------------------------------
# Run a script on remote and out to local file

$ ssh-copy-id id@remote_ip             <= copy id_rsa.pub file into remote first

$ ssh id@remote_ip 'bash -s' < /home/scrhipt.sh >> output.log   <= run as sudo mode

BASH ( https://linux.die.net/man/1/bash )
	-c  <= read from string
	-i  <= shell is interactive
	-s  <= read from the standard input
	
---------------------------------------------------
### Single line command script from SHELL ###
---------------------------------------------------
$ for i in $(cat ~/list); do ssh apark@$i [[ -f /home/apark/rkchk.sh ]] && echo "File exist" || echo "Not Exist";done                      
$ for i in $(cat "/home/apark/nu"); do ssh apark@$i "hostname && ls -l"; done
$ for i in $(cat "/home/apark/nu"); do ssh apark@$i "rm -f rkchk.sh"; done
$ for i in $(cat "/home/apark/nu"); do ssh -t apark@$i "sudo yum update kernel -y"; done

$ for i in us eu as; do echo sg-$i; ssh sg-$i "uptime"; done
$ for i in sg-us sg-eu sg-as ; do echo $i; date; done
$ for i in sg-eu sg-as ; do rsync -av authorized_keys $i:.ssh; done


$ for i in $(cat pmtip); do echo $i && ssh -t apark@$i "cat /var/log/newrelic/nrsysmond.log" | tail; done  2>&1 > log

$ while true; do dmesg -c ; sleep 1 ; done

$ while [ 1 ] ; do echo "ssh to 45.55.5.69...";ssh apark@45.55.5.69 'date; hostname'; sleep 10; done
$ while false ; do echo "ssh to 45.55.5.69...";ssh apark@45.55.5.69 'date; hostname'; sleep 10; done

$ while true; do tail -n0 -f /var/log/apache2/access.log > /tmp/tmp.log & sleep 2; kill $! ; wc -l /tmp/tmp.log | cut -c-2; done 2> /dev/null
	
	
---------------------------------------------------	
Grouping Commands	
https://www.gnu.org/software/bash/manual/bashref.html#Command-Grouping

### ()   	<=  ( list )
	Placing a list of commands between parentheses causes a subshell environment to be created, and each of 
	the commands in list to be executed in that subshell. Since the list is executed in a subshell, variable 
	assignments do not remain in effect after the subshell completes.
### {} 		<=	{ list; }
	Placing a list of commands between curly braces causes the list to be executed in the current shell context. 
	No subshell is created. The semicolon (or newline) following list is required.	
	
	
	
----------------------------------------------------------------------------------------	
### High memory usage 	
*/30 * * * * /home/apark/checkMemUsage.sh > /dev/null 2>&1
----------------------------------------------------------------------------------------
#!/bin/bash
### If memory usage over 80%, restart HTTPD ###

# Check top % memory usage app value
memUsage=`top -o %MEM -bn 1 | awk '8 <=NR && NR <=8' | awk '{print $10}'`
memUsage=$( printf "%.0f" $memUsage )

if (( $memUsage > 80));
then
    apachectl restart
fi
----------------------------------------------------------------------------------------	
#or#	??  
if [ $memUsage -gt 80 ];
    apachectl restart
fi
	
	
	
	
---------------------------------------------------	
### Within script Code
	#!/bin/bash
	### turn on debug mode
	set -x           <- Turn on/ Off " +x " debug mode
	for i in $(ls)
	do
		file $i
	done
------------------------------------
### /dev/null
	> /dev/null 2>&1     <= redirect the output of your program to /dev/null. 
							Include both the Standard Error and Standard Out	
						&  indicates a file descriptor. There are usually 3 file descriptors 
						   - standard input, output, and error
						   
	e.g. in crontab
	* * * * * /home/apark/check.sh /dev/null 2>&1					   

# more commands
	set -x : Display commands and their arguments as they are executed.
	set -v : Display shell input lines as they are read. 
	

 
 # Move cursor to all the way down
	shift+G		<= All the way down the page
	
 # Check bash 
	$ echo $SHELL
	$ env | grep SHELL
	$ ps					 
	  1453 pts/1    00:00:00 bash  <= BASH
	$ ps | grep `echo $$` | awk '{ print $4 }'


---------------------------------------------------
### Special Shell Variables ###
---------------------------------------------------
https://coderwall.com/p/85jnpq/bash-built-in-variables

	$0 		file name of script
	$1		positional parameter #1
	$2-9	positional parameter #2-9
	${10}	positional parameter #10 and up e.g. 11, 12, 13....
	$#		number of positional parameters(Total Numbers)
	$@		what parameters were passed
	"$*"	all the positional parameters(as separate word)*
	"$@"	all the positional parameters(as separate strings)
	${#*}	number of positional parameters
	${#@}	number of positional parameters
	$?		return value
	$$	 	process ID(PID) of script
	$-		flags passed to script(using set)
	$_		last argument of previous command
	$!		process ID(PID) of last job run in background
	* Must be quoted, otherwise it defaults to $@
	
echo $$ <= the PID of the current process.
echo $? <= the return code of the last executed command.	
echo $# <= the number of arguments in $*
echo $* <= the list of arguments passed to the current process
echo $@ <= 
	
--------------------------------------------------------------------------------------------------
$* - Expands to the positional parameters, starting from one. When the expansion occurs within 
	double quotes, it expands to a single word with the value of each parameter separated by 
	the first character of the IFS special variable.

$@ - Expands to the positional parameters, starting from one. When the expansion occurs within 
	" "(double quotes), each parameter expands to a separate word.

------------------------------------------
#!/bin/bash
echo "With *:"
for arg in "$*"; do echo "< $arg >"; done
echo
echo "With @:"
for arg in "$@"; do echo "< $arg >"; done
------------------------------------------
$ /tmp/test.sh 1  2 "3 4"
With *:
<1 2 3 4>

With @:				<= per line
<1>
<2>
<3 4>

https://coderwall.com/p/85jnpq/bash-built-in-variables
$ vi test.sh

#! /bin/sh
echo '$#' $#
echo '$@' $@
echo '$?' $?

$ bash test.sh 1 2 3
output:
$#  3
$@  1 2 3			<= single line
$?  0

*You passed 3 parameters to your script.*

$# = number of arguments. Answer is 3
$@ = what parameters were passed. Answer is 1 2 3
$? = was last command successful. Answer is 0 which means 'yes'
	
$ echo -n     do not output the trailing newline
       -e     enable interpretation of backslash escapes
       -E     disable interpretation of backslash escapes (default)
	   
---------------------------------------------------
### Quote in shell script ###

	$greeting="hello"
	### NO Quote	
	echo $greeting, world \(planet\)!
	   => hello, world (planet)!
	
	### Single Quote
	echo '$greeting, world (planet)!'
	   => $greeting, world (planet)!

	### Double Quote
	echo "$greeting, world (planet)!"
	    => hello, world (planet)!

	$ awk '/lemon/ && /rice/'					<= search two words
---------------------------------------------------
### "2>&1" command:
	Using "2>&1" , redirect the standard error(2) to standard output(1). The string "2>&1" indicates that any errors 
	should be sent to the standard output(1), that is, the Linux/Linux file id of 2 for standard error, and the file 
	id of 1 for standard output.  If you do not use this string, then you will be capturing only the good messages, 
	and the error messages will not be captured.
	
	cmd 1>&2
		stdout to same place as stderr
	cmd 2>&1
		stderr to same place as stdout
	cmd &> file
	./script.sh  &>  ~/log/log_file
		Every output of cmd to file


Note: You must separate the square brackets from other text by a space.
e.g. [ ! -z $HOME ] 
      ^ ^space   ^space 
	  
### Common Bash comparisons
Operator	       Meaning									Example
-------------------------------------------------------------------------------------
-z			Length of String is (zero)EMPTY 					[ -z "$my_var" ]      		my_var=""
-n			Length of String is NOT (zero)EMPTY					[ -n "$my_var" ]            my_var="num"
-f			File is Exists & normal,regular 					[ -f "$myfile" ]
-d			Directory is Exists  								[ -d "$mydir" ]
-e 			file exist
-w			Writeable
=			Strings are same									[ "abc" = "$my_var" ]
!=			Strings are Not Same   								[ "abc" != "$my_var" ]


-eq	  		Equal (Numeric equality)							[ 3 -eq 3 ("$my_integer") ]
-ne			Not Equal(Numeric inequality)						[ 3 -ne 4 ("$my_integer") ]
-lt			Less than (Numeric strict less than)				[ 3 -lt 4 ("$my_integer") ]
-le			Less than or equals	(Numeric less than or equals)	[ 3 -le 4 ("$my_integer") ]
-gt			Greater than (Numeric strict greater than)			[ 3 -gt 2 ("$my_integer") ]
-ge			Greater than or equals(Numeric) 					[ 3 -ge 3 ("$my_integer") ]

-nt			First file is newer than second one					[ "$myfile" -nt ~/.bashrc ]
-ot			First file is older than second one					[ "$myfile" -ot ~/.bashrc ]


### Test [ expression ] statement for Comparison operation [[ expression ]]     
	0:TRUE  1:FALSE 
A. Comparing variables									           For Arithmatic with Integer
 	Less than			        [[ $1 < $2 ]]                    = (( $a < $B )) 
	greater than			    [[ $a > $b ]]
	less than or equal to 		[[ $a <= $b ]]
	greater than or equal to 	[[ $a >= $b ]]
	equal(same)			        [[ $a == $b ]]
	not equal(same)		        [[ $a != $b ]]
		
$ [ 9 -lt 10 ]; echo $?
$ [ "awesome" = "awesome" ]; echo $?
$ [ 10 == 10 ]; echo $?
$ [[ 1 < 2 ]] ; echo $?
$ (( 1 < 2 )) ; echo $?
$ (( 1 == 2 )) ; echo $?

or use 'expr'


------------------------------------------------
###  () vs. {}
------------------------------------------------
	https://askubuntu.com/questions/606378/when-to-use-vs-in-bash
{...} <= current shell
(...) <= subshell



() <- Subshell

( list )
	Placing a list of commands between parentheses causes a "SUBSHELL" environment to be created, 
	and each of the commands in list to be executed in that subshell. Since the list is executed 
	in a subshell, variable assignments do not remain in effect after the subshell completes.
$ ( a=A )
$ echo $a
A
### e.g.
$ cd ; unset files
$ count_tmp() (cd /tmp; files=(*); echo "${#files[@]}")
$ pwd; count_tmp; pwd
/home/jackman
11
/home/jackman
$ echo "${#files[@]}"
0
---------------------------------------------------------------------------------------------------
{}   <- Current Shell

{ list; }
	Placing a list of commands between curly braces causes the list to be executed in the "Current 
	shell" context. No subshell is created. The semicolon (or newline) following list is required.
$ { a=A; }
$ echo $a
A
### e.g.
$ count_tmp() { cd /tmp; files=(*); echo "${#files[@]}"; }
$ pwd; count_tmp; pwd
/home/jackman
11
/tmp
$ echo "${#files[@]}"
11  



---------------------------------------------------------------------------------------------------
		

The shell treats several parameters specially. These parameters may only be referenced; assignment to them is not allowed.

Table 3-3. Special bash variables

Character	Definition
$*	Expands to the positional parameters, starting from one. When the expansion 
	occurs within double quotes, it expands to a single word with the value of each 
	parameter separated by the first character of the IFS special variable.
$@	Expands to the positional parameters, starting from one. When the expansion occurs 
	within double quotes, each parameter expands to a separate word.
$#	Expands to the number of positional parameters in number(decimal).
$?	Expands to the "exit status" of the Last(most recently) executed foreground pipeline.
$-	A hyphen expands to the current option flags as specified upon invocation, by the 
	set built-in command, or those set by the shell itself (such as the -i).
$$	Expands to the process ID of the shell.
$!	Expands to the process ID of the most recently executed background (asynchronous)
	 command.
$0	Expands to the name of the shell or shell script.
$_	The underscore variable is set at shell startup and contains the absolute file name 
	of the shell or script being executed as passed in the argument list. Subsequently, 
	it expands to the last argument to the previous command, after expansion. It is also
	set to the full pathname of each command executed and placed in the environment 
	exported to that command. When checking mail, this parameter holds the name of the 
	mail file.


grep "echo" ./function1.sh
   	echo "Hi $1! what a nice $2!!"
	echo "And now, a greeting!"
	echo $_
	./function1.sh
	echo $$
	35810
	echo $!


	
$IFS   <-Internal Field Seperator

$ bash -c 'set w x y z; IFS=":-;"; echo "$*"'
w:x:y:z

Compare to:

$ bash -c 'set w x y z; IFS="-:;"; echo "$*"'
w-x-y-z	
	
	
######################## 
# Bash Shell Variables #
########################

varname=value                # defines a variable
varname=value command        # defines a variable to be in the environment of a particular subprocess
echo $varName                # checks a variable's value
echo $$                      # prints process ID of the current shell
echo $!                      # prints process ID of the most recently invoked background job
echo $?                      # displays the exit status of the last command
export varName=value         # defines an environment variable (will be available in subprocesses)
	e.g.  using 'export' to env variable for current SHELL to execute 
	$ HTTP_PROXY=192.168.2.2:3128
	$ export HTTP_PROXY
	
	$ echo A is $A
	$ export A=1
	$ echo A is $A
	  A is 1
	$ unset A
	


# Arrays adn Associative Arrays
	Arrays 			   <= Stores a collection of data separate entities using indexes
	Associative Arrays <= Take a string as their array index (Bash V4 or higher)
	
array[0] = val               # several ways to define an array
array[1] = val
array[2] = val
array=([2]=val [0]=val [1]=val)
array(val val val)

${array[i]}                  # displays array's value for this index. If no index is supplied, array element 0 is assumed
${#array[i]}                 # to find out the length of any element in the array
${#array[@]}                 # to find out how many values there are in the array


declare -A					 # Associative Array
declare -a                   # Indexed array variables
declare -f                   # uses function names only
declare -F                   # displays function names without definitions
declare -i                   # the variables are treaded as integers
declare -r                   # makes the variables read-only(Constant)
								ex) declare -r NUM1=5
declare -x                   # marks the variables for export via the environment

${varname:-word}             # if varname exists and isn't null, return its value; otherwise return word
${varname:=word}             # if varname exists and isn't null, return its value; otherwise set it word and then return its value
${varname:?message}          # if varname exists and isn't null, return its value; otherwise print varname, followed by message and abort the current command or script
${varname:+word}             # if varname exists and isn't null, return word; otherwise return null
${varname:offset:length}     # performs substring expansion. It returns the substring of $varname starting at offset and up to length characters

${variable#pattern}          # if the pattern matches the beginning of the variable's value, delete the shortest part that matches and return the rest
${variable##pattern}         # if the pattern matches the beginning of the variable's value, delete the longest part that matches and return the rest
${variable%pattern}          # if the pattern matches the end of the variable's value, delete the shortest part that matches and return the rest
${variable%%pattern}         # if the pattern matches the end of the variable's value, delete the longest part that matches and return the rest
${variable/pattern/string}   # the longest match to pattern in variable is replaced by string. Only the first match is replaced
${variable//pattern/string}  # the longest match to pattern in variable is replaced by string. All matches are replaced

${#varname}                  # returns the length of the value of the variable as a character string

*(pattern list)               # matches zero or more occurences of the given patterns
+(pattern list)               # matches one or more occurences of the given patterns
?(pattern list)               # matches zero or one occurence of the given patterns
@(pattern list)               # matches exactly one of the given patterns
!(pattern list)               # matches anything except one of the given patterns

$(Linux command)              # command substitution: runs the command and returns standard output		
		
---------------------------------------------------
### White Sapce		
	whitespace (spaces or tabs).



$ my_var=This is my environment variable!	
$ echo foo${my_var}bar							<= must use { }
fooThis is my environment variable!bar


----------------------------------------------------------------------------------
### IF statement ###### 
----------------------------------------------------------------------------------

$ test 100 -gt 99 && echo "Yes, that's true." || echo "No, that's false."
	Yes, that's true.

$ test 90 -gt 99 && echo "Yes, that's true." || echo "No, that's false."
	No, that's false.
	
----------------------------------------------
if [ $num -lt 10 -o $num -gt 100 ]
	then
    echo "Number $num is out of range"
elif [ ! -w $filename ]
	then
    echo "Cannot write to $filename"
fi	
----------------------------------------------	
	
#!/bin/bash
if [ $id -u = 0 ];then				# if (id -u) 0 = 0 are True
    echo "You are root" >&2			# 	
    exit 0
fi

---------------------------
#!/bin/bash
if [ $id -u = 0 ];then				# if (id -u) 0 = 0 are True
    echo "You are root" 			# 	
else
	echo "You are not root"
fi

	
### ! -z $HOME <= If home is NOT empty, echo $HOME
$ if [ ! -z $HOME ]; then echo $HOME; else echo "No Home"; fi
$ if [[ -n $HOME]]; then echo $HOME; else echo "No Home"; fi                     <= home is exist
/home/noza                                                                     <= Same answer
           
### -z $HOME    <= $HOME is empty which is False, echo "No Home"
$ if [ -z $HOME ]; then echo $HOME; else echo "no home"; fi
$ if [[ ! -n $HOME ]]; then echo $HOME; else echo "no home"; fi
no home  


$ if [[ ! -z $HOME ]]; then echo $HOME; elif [[ -z $HOME ]]; then echo "No Home"; fi
/home/noza



----------------------------------------------------------------------------------------------------
### RR server process check
#!/bin/bash
# Check and put ok status if the RRS game service is running for Lobby 7504 & 7505 services

if (( $(ps aux | grep ./RRServer_0402_7504 | grep -v grep | wc -l) > 0  &&  $(ps aux | grep ./RRServer_0617_7505 | grep -v grep | wc -l) > 0 )) ;
        then
        echo OK > /var/www/html/status/index.html;
else rm /var/www/html/status/index.html > /dev/null 2>&1;
fi
----------------------------------------------------------------------------------------------------













----------------------------------------------------------------------------------
### for_loop### 
----------------------------------------------------------------------------------

#!/bin/bash

for i in $(ls)
do
    echo $i
done
------------------------------------

### for_loop1.sh		
#!/bin/bash
for i in *; do   # * is local directory
	echo “$i”
done
$./for_loop1.sh 
=> local files list
------------------------------------
### for_loop2.sh
#!/bin/bash
for i in $#; do
	echo “$i”			# zip archive "$i"
done
$./for_loop1.sh 1 2 3 4	
=> 4   <= total number of argument 1,2,3,4 is 4 total!
------------------------------------
### for_loop2.sh
#!/bin/bash
for i in $@; do
	echo “$i”			# zip archive "$i"
done
$./for_loop1.sh 1 2 3 4	
=> 1 2 3 4

------------------------------------
$ for i in {1..100..2};do echo $i; done
$ for (( i=1; i<=10; i++));do echo $i; done
$ for (( i=1; i<=10; i++));do echo -n $i `sleep 1`" "; done

----------------------------------------------------------------------------------
### Array ###
----------------------------------------------------------------------------------
ARRAY_NAME[index_number]=value
The Index_Number is treated as an arithmetic expression that must evaluate to a + positive number.
### Associate Array only works on BASH 4 or higher 

	$ array_var=(1 2 3)
	$ array_var[0]="test1"
	$ array_var[1]="test2"
	$ array_var[2]="test3"
	$ echo ${array_var[0]}
	  test1
	$ echo ${array_var[$#]}
	  test1
	$ index=2
	$ echo ${array_var[$index]}
	  test3
	$ echo ${array_var[*]}
	  test1 test2 test3 m
	$ echo ${array_var[@]}
		test1 test2 test3
	$ echo ${#array_var[*]}
		3




------------------------------------
#!/bin/bash
array_name=("apple" "banaba" "cherry")
for i in ${array_name[@]}             # @ or * <- both works 
do
    echo -n `sleep 1` $i " "
done

------------------------------------
#!/bin/bash
declare -a array_name
array_name["0"]="Albert"
array_name["1"]="1234"

for i in "${!array_name[@]}"  				### ! <-access keys in array  ""<- if space is in array
do
    echo "$i \= ${array_name[$i]}"
done

"declare -a" declares an array and all the elements in the parentheses are the elements of an array.
 
$ declare -a array_name=('Debian' 'Red hat' 'Red hat' 'Suse' 'Fedora');
$ echo ${array_name[@]}
  Debian Red hat Red hat Suse Fedora

------------------------------------
#!/bin/bash
# Declaring an Array and Assigning values
	-a     Each name is an indexed     array variable (see Arrays above).
    -A     Each name is an associative array variable (see Arrays above).

declare -a Linux

Linux[0]="Debian"
Linux[1]="Redhat"
Linux[2]="Ubuntu"
Linux[3]="Suse"

for i in "${!Linux[@]}"   # whole elements of the array
do
  echo "$i: ${Linux[$i]}"
done
==>> Output
0: Debian
1: Redhat
2: Ubuntu
3: Suse

----------------------------------------------------------------------------------
###  Length of the Bash Array ###
get the length of an array using the special parameter called $#.

${#array_name[@]} gives you the length of the array.

e.g.
$ declare -a Linux=('Debian' 'Red hat' 'Suse' 'Fedora');
# Number of elements in the array
$ echo ${#Linux[@]} 
  4
# Number of "characters" in the first element of the array.i.e Debian
$ echo ${#Linux}  		<- same as 0
  6
$ declare -a Linux=('Debian' 'Red hat' 'Suse' 'Fedora');
$ echo ${#Linux[3]}
  7  <- counting SPACE, too

------------------------------------
$ declare -a num=(1 22 333 4444 55555 666666)
$ echo ${#num[2]}
	3
$ echo ${num[4]}
	4  
 ------------------------------------ 
$ declare -a name=(albert sujin sumin)
$ echo ${name}
	albert
$ echo ${name[1]}
	sujin
$ echo ${#name}
	6
$ echo ${name[@]}
	albert sujin sumin

	
  
----------------------------------------------------------------------------------  
### Replace ###
$ Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
$ echo ${Unix[@]/Debian/Linux}
Linux
----------------------------------------------------------------------------------
### Add more elements into array
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
Unix=("${Unix[@]}" "AIX" "HP-UX")
echo ${Unix[7]}
->AIX
----------------------------------------------------------------------------------
### Remove elements from array
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
unset Unix[3]
echo ${Unix[@]}

----------------------------------------------------------------------------------
### * wild including current directory files
#!/bin/sh
for i in hello 1 * 2 goodbye 
do
  echo "Looping ... i is set to $i"
done


----------------------------------------------------------------------------------
### Test statement ###
----------------------------------------------------------------------------------


if test  == if [ ]
[ expression ] 
[[ expression ]]  		<= extended e.g. grep, egrep
if (( integer comparison )); then

###
if expression
then
	echo "True"
#elif
else
	echo "False"
fi
###
------------------------------------
#!/bin/bash
# Integer comparison
a=5
b=4
if [ $a -gt $b ]; then
	echo "$a is greater than $b."
else
    echo "$a is less than $b."
fi
------------------------------------	
#!/bin/bash
# String matches using REGEX   =~ [0-9]+
a="This is my 1st string!"
if [[ $a =~ [0-9]+ ]]; then
    echo "There are Numbers in the string: $a"
else
    echo "There are no numbers in the string: $a"
fi
------------------------------------
#!/bin/bash
# empty variable or not
if [ -z "$my_var" ]
then
    echo "my_var is an Empty variable!!"
fi







17. if [ $id -u != "0" ] ;then
	echo "You must be the supper user" >&2  						<= user id -u is 0
	exit 1															<= exit status sets to 1(failure)
    fi

	
19. Arithmetic
	echo $(( 1+2 ))
	+, -, *, /, %, **,

------------------------------------	
#!/bin/bash
number=0
echo -n "Enter a number >"
read number
echo "The number is $number"
if [ $(( number %2 )) -eq 0 ]; then
    echo "The number is even"
else
    echo "The number is odd"
fi

------------------------------------
# Read : within min time to input
----------------------------------------------------------------------------------

# -t timing
# -s security hidden

	#!/bin/bash
	echo -n  "Enter your number before expire within 3sec: "
	echo seq 3
	
	if read -t 3  -s response; then
	        echo "Great, you made it in time"
	else
        	echo "Sorry, you are too slow"
	fi
----------------------------------------------------------------------------------
### 5 mins (Time counting  ( count down | counting 300 sec ) 
----------------------------------------------------------------------------------
$ for i in {0..300}; do echo -ne "$i" '\r'; sleep 1; done; echo 

	# \r 	<= returning to begin of line (without new line - \n)
	# -n 	<= new line(do not output the trailing newline)
	# -e 	<= escape (enable interpretation of backslash escapes)


------------------------------------
### Directory or file name

#!/usr/bin/env bash
for myfile in /etc/r*
do
    if [ -d "$myfile" ]
    then
      echo "$myfile is a directory!"
    else
      echo "$myfile is a file name"
    fi
done



	
24. Test statement for Comparison operation [[ expression ]]     0:TRUE  1:FALSE 
	A. Comparing variables									        For Integer
		Less than			        [[ $a < $b ]]             = (( $a < $B )) 
		greater than			    [[ $a > $b ]]
		less than or equal to 		[[ $a <= $b ]]
		greater than or equal to 	[[ $a >= $b ]]
		equal(same)			        [[ $a == $b ]]
		not equal(same)		        [[ $a != $b ]]
	
	### String comparison
	ex) [[ "cat" == "cat" ]]
		a=cat
		b=dog
		[[ $a == $b ]]
		echo $?			<= 1:FALSE 0:TRUE

	B. Logical Operations
		AND     [[ $a && $b ]]
		OR   	[[ $a || $b ]] 
		NOT     [[ ! $a ]]

	C. Integer Number comparison operations
		less than			         [[ $a -lt $b ]]
		greater than			     [[ $a -gt $b ]]
		less than or equal to 		 [[ $a -le $b ]]
		greater than or equal to	 [[ $a -ge $b ]]
		equal				         [[ $a -eq $b ]]
		not equal			         [[ $a -ne $b ]]
		
	Eg)	[[ 20 -gt 100 ]]
		echo $?
	
	D. String null value
		is null(EMPTY)?			    [[ -z $a ]]   <= [[ !-z $a ]]
		is not null(EMPTY)?			[[ -n $a ]]   <= [[ !-n $a ]]

		
	Ex)	a=""
		b="cat"
		[[ -z $a && -n $b ]]
		echo $?

		if [ $? == 0 ]; then
			echo "TRUE"
		else
			echo "FALSE"
		fi



28. Array (can do from prompt)
	
	a=()
	b=("apple" "banana" "cherry" "$today" "$time")
	echo ${b[2]}
	b[5]="kiwi"
	b+=("mango")
	echo ${b[@]}            # @ <= whole array
	echo ${b[@]: -1}        # -1 <= last item in array
	
	
	
	
	
1. Comparisons: cmp vs diff
	cmp -  compare files byte by byte
	cmp -s $file1 $file2
    
    comm <= Compare two sorted files line by line   

    diff - compare files line by line
	diff $file1 $file2 > /dev/null

	sdiff  <= side by side comparison
	
	
32. if Condition statement

	a. if condition ; then	<= if condition is true, commands run
		commands
   	   fi			<= if condition is false, do nothing!

	b. if condition ; then  <= if condition is true, 1st commands run otherwise 
	   	commands   
	   else			<= if condition is false, 2nd commands run
		commands
	   fi

	c. if condition ; then   <= if condition is true, 1st commands run
	   	commands
	   elif conditions; then <= if condition is false, and if the 2nd command is true
	   	commands	 <= then 2nd set of commands run  	
	   if
	   
	#!/bin/bash
	if [ -f /etc/foo ]; then     # -f for file exit?
        	cp /etc/foo .
       		echo "copy done!"
	else
        	echo "This file does not exist"
        	exit (1 ??)
	fi
--------------------------------------------------

	if cmp -s "$file1" "$file2"
		then
	   echo "The files match"
	else
	   echo "The files are different"
	fi



----------------------------------------------------------------------------------
# Exit code
----------------------------------------------------------------------------------
	#!/bin/bash

	touch /root/test 2> /dev/null

	if [ $? -eq 0 ]
	then
  	  echo "Successfully created file"
	  exit 0
	else
	  echo "Could not create file" >&2
	  exit 1
	fi
	

	## With the exit command in this script, we will exit with a successful message 
	and 0 exit code if the touch command is successful. If the touch command fails 
	however, we will print a failure message to stderr and exit with a 1 value 
	which indicates failure. ##

	
	# Move or rename file from CMD
	$ if [ -e .vimrc ]; then mv .vimrc .vimrc_bak; fi

	
	
	
	
----------------------------------------------------------------------------------
### While loop ###
----------------------------------------------------------------------------------
#!/bin/bash
x=1
while
    ((x<10))
do
    echo loop $x; date > data.$x
    ((x=x+1))
done
--------------------------------------------
#!/bin/bash
ls -l /etc | while
        read a b c d
do
        echo "The owner name is  $c."
done
--------------------------------------------
$ ls -l /etc/ | head -n 2
total 1364
-rw-r--r--.  1(No of link to file)  'root'   root       16 Dec  5  2016 adjtime
     $a     $b   					 $c       $d

--------------------------------------------
$while read i; do echo $i; done < while1.sh
--------------------------------------------
#!/bin/bash
i=1
while read file; do
echo "Line $i: $file"
((i++))
done < echo.txt

------------------------------------
#!/bin/bash
i=1
while read file; do
    echo "Line $1: $file"
    (i++))
done < file.txt

Line 1: apple
Line 2: banaba
.......
------------------------------------
#!/bin/bash
# WHILE LOOP - i 가 10보다 적거나 같을때 까지
i=0
while [ $i -le 10 ]; do
    echo i is $i
#   ((i++))
    ((i+=1))
#   ((i=$i+1))
done

### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### 
### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ######

- J 가 10보다 크거나 같을때 가지.
j=0
until [ $j -ge 10 ]; do
    echo j is $j
    ((j++))
done
------------------------------------


#!/bin/bash

INPUT_STRING=hello

while [ "$INPUT_STRING" != "bye" ]
do
  echo "Please type something or type 'bye' to quit!"
  read INPUT_STRING
  echo "You typed '$INPUT_STRING' to exit."
done







33. while and until statement                   <= while & until true statement
	i=0
	while [ $i -le 10 ]; do
        	echo i = $i
        	((i++))
	done			<= 0 ~ 10
-------------------------------------------------
    j=0
    until [$j -ge 10 ]; do
        echo j = $j
       ((j++))
    done			<= 0 ~ 9
--------------------------------------------------

	#!/bin/bash
	x=0			<= initializing to 0
	while [ $x -le 10 ] ; do 
        echo "Current value of X is $x."
        ((x++))
		# x=$(($x + 1 ))
		# x=$(expr $x + 1 )  <= ((x++)                   
        sleep 1
	done
	prints 0 ~ 10
--------------------------------------------------
	x=0;

	while [ $x -gt -10 ] ; do
        echo "X value is $x"
	    ((x--))
	done

--------------------------------------------------
#!/bin/sh
INPUT_STRING=hello
#INPUT_STRING=  		                <= works too
while [ "$INPUT_STRING" != "bye" ]
do
  echo "Please type something in (bye to quit)"
  read INPUT_STRING
  echo "You typed: $INPUT_STRING"
done
--------------------------------------------------	
	
	
--------------------------------------------------		
34. for loops
# goes over per word, not line
--------------------------------------------------	
for i in $(<dataFile.txt)
for i in *.txt
for i in $(find . -name *.txt)

--------------------------------------------------
#!/bin/bash
export a=first
export b=second
export c=thrid
echo a is '['$a']' b is '['$b']' c is '['$c']'
read a b < dataFile.txt
echo a is '['$a']' b is '['$b']' c is '['$c']'
--------------------------------------------------
$ cat dataFile.txt
dog cat rooster
--------------------------------------------------
x="nozatech"
for i in /home/*; do
	echo $x is exist in home directory
done

--------------------------------------------------
#!/bin/bash
for i in dog cat hotdog
do
    echo i is $i
done
#--------------------------------------------------
for i in `seq 3 5`
do
    echo i in seq is $i
done
#--------------------------------------------------
for i in {A..z}
do
    echo i in letter list is $i
done
#--------------------------------------------------
for i in $(<dataFile.txt)					# Per word
do
    echo i in the dataFile.txt is $i
done
#--------------------------------------------------
for i in $(find /etc 2> /dev/null | grep grub)
do
    echo The Grub named things are $i
done
--------------------------------------------------

	
	
35. file
	i=1
	while read f; do
		echo "Line $i: $f"
		((i++))
	done < file.txt	


e.g.
	if [ -f .bashrc ]; then	
	    echo "you have the .bashrc."
	else
		echo "No .bashrc found!"
	fi	

	if [ $(id -u) = "0" ]; then
		echo "supersuser"
	fi


37. read -p "What year?[nnnn] " a
   while [[ ! $a =~ [0-9]{4} ]]; do
       read -p "A year, pelase! [nnnn] " a
   done
   echo "Selected year: $a"

	
	
	
	


----------------------------------------------------------------------------------
38. && ( AND )   

#T&&R    true  && echo runs		<= if cmd1 runs then cmd2 runs also 

#F&&N    false && echo runs		<= if cmd2 fails then cmd2 No runs
	
e.g.	cd $directory && rm -rf *

# Both run in cmd line and bash script
	    *TRUE*	   *RUN!*
	[ ! -d ~/tmp ] && mkdir ~/tmp
	echo $? <= 0  Success

	    *FALSE*	   *NO RUN*
	[ ! -d ~/tmp ] && mkdir ~/tmp
	echo $? <= 1  fail  Did not created!

----------------------------------------------------------------------------------
###  Coding Practice ###
----------------------------------------------------------------------------------
### FIZZBUZZ  ###	

	Prints out when there is a number divied by 3 == 0, then fizz
	Prints out when there is a number divied by 5 == 0, then buzz
	Prints out when there is a number divied by 3 == 0 && 5 == 0, then FizzBuzz

	
	#!/bin/bash  
	for i in {1..100}; do
        if (( i % 3 == 0 )) && (( i % 5 == 0)); then echo "fizzbuzz"
                elif (( i % 3 == 0 )); then echo "fizz"
                elif (( i % 5 == 0 )); then echo "buzz"
        else
                echo $i;
        fi
	done

	
	#!/bin/bash
	for i in {1..100}; do
		if (! ((i % 3)) ) && (! ((i % 5)) ); then echo "FizzBuzz"
			elif (! ((i % 3)) ); then echo "fizz"
			elif (! ((i % 5)) ); then echo "buzz"
		else
			echo $i;
		fi
	done

	### check modulo value from terminal ###
	# m=$(( 1 % 5 ))
	# echo $m
	# 1
	# m=$(( 55 % 5 ))
	# echo $m
	# 0

39. || ( OR )

#T||N    true  || echo runs		<= if cmd1 runs then cmd2 NO runs

#F||R    false || echo runs		<= if cmd1 fails then cmd2 RUNS!

   	     *TRUE*	   *NO RUN*
	[ -d ~/tmp ] || mkdir ~/tmp
	echo $? <= 1  False

	    *FALSE*	   *YES RUN*
	[ -d ~/tmp ] || mkdir ~/tmp
	echo $? <= 0  Created folder!





e.g.    cd $directory || error_exit "No such dir and aborting!"



----------------------------------------------------------------------------------
### Function ###
----------------------------------------------------------------------------------
Shell memorizeds the function like it's a new command
$ function helloworld {
	echo "Hello World!"
  }
$ helloworld
	Hello World!
------------------------------------------------------
# 'return'  <= functions return when there are no more statements
				or when a return statement is executed.
$ function helloworld {
	echo "Hello World!"
	return
	echo "This will not be executed!"
  }
$ helloworld
	Hello World!	
# Functions produce results by writing 'output' like commands do.
	resultVar=$(printhello)
	
# 'Exit'	
	- exit <VALUE> sets the exit status, represented by '$?' to <VALUE>
		0 - success, 1 - failed, 2 - custom error ...
	- Exit terminates the shell process
	- Exit in a function terminates the whole shell program, not just the function.
------------------------------------------------------
# function that exports to a new shell
------------------------------------------
	$function helloWorld {
	> echo "Hello World!"
	echo "Hello World"
	> return
	> }
------------------------------------------	
	$helloWorld						<= execute function 'helloWorld'
	Hello World
------------------------------------------	
	$export -f helloWorld			<= 'export -f' helloWorld function to new SHELL
	$bash							<= a new Shell
------------------------------------------	
	$ps								<= Check number of shells
	PID TTY          TIME CMD
	10233 pts/3    00:00:00 bash	<= exiting shell
	26462 pts/3    00:00:00 bash	<= New Shell
	26477 pts/3    00:00:00 ps
------------------------------------------	
	$ps -p $$						<= Checking which shell I am on
	PID TTY          TIME CMD
	26462 pts/3    00:00:00 bash
------------------------------------------	
	$helloWorld						<= Execute a new 'helloWorld' from new shell
	Hello World
------------------------------------------
#!/bin/bash
function myFunc {
	echo "Starting myFunc"
	return
	echo "This will not be exectured!"
}

myFunc
n=$(myFunc)								<= put myFunc to 'n' variable
echo "n is $n"
------------------------------------------
#!/bin/bash
# func2.sh

function f2 {
	echo "in f2"
	exit 2						<= TERMINATE Program after exit code 2
	echo "more in f2"
}

echo "Starting"					<= Just echo "Starting"
f2								<= execute f2 function will stop the program!!!!
echo "after f2"					<= After f2 with exit code 2, it will not execute 
------------------------------------------
$ bash func2.sh
Starting
in f2
$ echo $?						<= checking exit code
2


	
	
------------------------------------------------------
# hidden file listing function from shell
$ hidden() { ls -a "$@" | grep '^\.'; }			<= $@  
$ hidden .



#!/bin/bash
function numberthings {		<= Declaring function name
    i=1			<= 
    for f in $@; do		<= $@ special array variable that represents all 
								of the arguments pass to a function
        echo $i: $f
        ((i+=1))			<= incrementing ((i++)) or ((i=i+1))
    done
}

numberthings $(ls)
numberthings pine birch maple spruce




40. Argument
	#!/bin/bash
	echo $1
	echo $2

    $./my.sh apple banana


	#!/bin/bash
	echo $1
	echo $2
    $./my.sh "apple Apple" "banana Banana"   <=use " " for when space in them

###
# Don't have to define the variables to saves a lot of time
###

	#!/bin/bash
	for i in $@							<= array arugment $@
	do
		echo $i
	done
	echo "There were $# arugments."     <= $# total number of arguments

$./my.sh apple orange kiwi lemon



---------------------------------------------------------------------------------  
### CASE statement ###
--------------------------------------------------------------------------------

#!/bin/bash
a="dog"
case $a in
    cat)       echo "It is a cat_name";;
    dog|puppy) echo "It is a dog_name";;   				# | <- pipe to match dog or puppy
    *)         echo "No match!";;
esac

------------------------------------
#!/bin/bash
while read i
do
  case $i in
        hello)  echo 1;;
        howdy)  echo 2;;
  esac
done < myfile.txt 
	myfile.txt
	hello
	howdy

	


---------------------------------------------------------------------------------
### Function statement ###
---------------------------------------------------------------------------------

#!/bin/bash
function greeting {
	echo "Hello There!"
}
echo "And now, a greeting!"
greeting
------------------------------------
#!/bin/bash
#A function to print "Hello World"
hello()
    {
      echo "Hello World"
    }
hello;
------------------------------------
#!/bin/bash
#function quit {
#    exit
#}
quit() {
	exit
}
function hello {
    echo Hello!
}
hello
quit
------------------------------------
#!/bin/bash
function quit { exit}
function input { echo $1 }    # $1 <-first argument pass to the function, but $@ <- works too.      
input hello
input world
quit  						  # exit
------------------------------------
#!/bin/bash
#numberthings (){
function numberthings {
    i=1
    for f in $@; do
        echo $i: $f
        ((i++))
    done
}

echo "First function"
numberthings $(ls)

echo "Second function"
numberthings pine birch maple spruce
------------------------------------

#!/bin/bash
#function to display commands
display() { echo "\$ $@" ; "$@" ; }
#display() { echo "\$ $@" 
			 echo "$@"  }
display echo hello world

------------------------------------
#!/bin/bash
function greet {
	echo "Hi, $1! What a nice $2!"
}
echo "And now, a greeting!"
greet Albert Morning
greet Everyone Evening






















	
######################################################################################################################################
# Bash Scripting
######################################################################################################################################
These are positional arguments of the script. 
position of arguments passed to the script on the command line, not line numbers
#!/bin/sh
echo "$1"
echo "$2"

./script.sh Hello World
$0 = script.sh             <- File name of the current script
$1 = Hello
$2 = World	
	
The $@ variable expands to all the parameters used when calling the function

function foo()
{
    echo "$@"
}
foo 1 2 3


It would display 1 2 3. If not used inside a function, it specifies all parameters 
used when calling the script. See the bash manual page for more info.	
	

 
 
------------------------------------
#!/bin/bash
echo "Hello, World. Calls $# of parameters"	
echo "argument 0 is '$0'"
.....	
echo "argument 9 is '$9'"
echo "argument 10 is '{$10}'"	 # from 10, use {} 

./argument.sh a b ... y z
		Hello, World. Calls 24 of parameters
		argument 0 is './argument.sh'
		argument 1 is 'a'
		.....
		argument 10 is 'j'
	
	
79.Special parameters


  
###############
# FUNCTIONS   #
###############
The function refers to passed arguments by position (as if they were positional parameters), that is, $1, $2, and so forth. $@ is equal to "$1" "$2"... "$N", where N is the number of positional parameters. $# holds the number of positional parameters.
functname() {
  shell commands
}

unset -f functname  # deletes a function definition
declare -f          # displays all defined functions in your login session
2.3. FLOW CONTROL.

statement1 && statement2  # 'and' operator
statement1 || statement2  # 'or' operator

-a                        # and operator inside a test conditional expression
-o                        # or operator inside a test conditional expression

str1=str2                 # str1 matches str2
str1!=str2                # str1 does not match str2
str1<str2                 # str1 is less than str2
str1>str2                 # str1 is greater than str2
-n str1                   # str1 is not null (has length greater than 0)
-z str1                   # str1 is null (has length 0)

-a file                   # file exists
-d file                   # file exists and is a directory
-e file                   # file exists; same -a
-f file                   # file exists and is a regular file (i.e., not a directory or other special type of file)
-r file                   # you have read permission
-r file                   # file exists and is not empty
-w file                   # your have write permission
-x file                   # you have execute permission on file, or directory search permission if it is a directory
-N file                   # file was modified since it was last read
-O file                   # you own file
-G file                   # file's group ID matches yours (or one of yours, if you are in multiple groups)
file1 -nt file2           # file1 is newer than file2
file1 -ot file2           # file1 is older than file2

-lt                       # less than
-le                       # less than or equal
-eq                       # equal
-ge                       # greater than or equal
-gt                       # greater than
-ne                       # not equal

if condition
then
  statements
[elif condition
  then statements...]
[else
  statements]
fi

for x := 1 to 10 do
begin
  statements
end

for name [in list]
do
  statements that can use $name
done

for (( initialisation ; ending condition ; update ))
do
  statements...
done

case expression in
  pattern1 )
    statements ;;
  pattern2 )
    statements ;;
  ...
esac

select name [in list]
do
  statements that can use $name
done

while condition; do
  statements
done

until condition; do
  statements
done

##################################
# 4. INPUT/OUTPUT REDIRECTORS.   #
##################################
cmd1 | cmd2  # pipe; takes standard output of cmd1 as standard input to cmd2
> file       # directs standard output to file
< file       # takes standard input from file
>> file      # directs standard output to file; append to file if it already exists
>|file       #   forces standard output to file even if noclobber is set
n>|file      # forces output to file from file descriptor n even if noclobber is set
<> file      # uses file as both standard input and standard output
n<>file      # uses file as both input and output for file descriptor n
<<label      # here-document
n>file       # directs file descriptor n to file
n<file       # takes file descriptor n from file
n>>file      # directs file description n to file; append to file if it already exists
n>&          # duplicates standard output to file descriptor n
n<&          # duplicates standard input from file descriptor n
n>&m         # file descriptor n is made to be a copy of the output file descriptor
n<&m         # file descriptor n is made to be a copy of the input file descriptor
&>file       # directs standard output and standard error to file
<&-          # closes the standard input
>&-          # closes the standard output
n>&-         # closes the ouput from file descriptor n
n<&-         # closes the input from file descriptor n



##############################
### 5. Regular Expression  ###
##############################
Basic Regular Expression
<Operator>	<Effect>
.			Matches any single character.
?			The preceding item is optional and will be matched, at most, once.
*			The preceding item will be matched zero or more times.
^			Start with(Matches the empty string at the beginning of a line; 
					  also represents the characters not in the range of a list.)
$			Matches the empty string at the end of a line.
+			The preceding item will be matched one or more times.
{N}			The preceding item is matched exactly N times.
{N,}		The preceding item is matched N or more times.
{N,M}		The preceding item is matched at least N times, but not more than M times.
-			represents the range if it's not first or last in a list or the ending point of a range in a list.
\b			Matches the empty string at the edge of a word.
\B			Matches the empty string provided it's not at the edge of a word.
\<			Match the empty string at the beginning of word.
\>			Match the empty string at the end of word.

### Extended regular expressions
	In basic regular expressions the metacharacters "?", "+", "{", "|", "(", and ")" lose their special meaning; 
	instead use the backslashed versions "\?", "\+", "\{", "\|", "\(", and "\)".


e.g.
$ grep ^root /etc/passwd
	root:x:0:0:root:/root:/bin/bash
	
https://regexone.com/problem/matching_decimal_numbers	
Lesson Notes
abc…	Letters
123…	Digits
\d	Any Digit
\D	Any Non-digit character
.	Any Character
\.	Period
[abc]	Only a, b, or c
[^abc]	Not a, b, nor c
[a-z]	Characters a to z
[0-9]	Numbers 0 to 9
\w	Any Alphanumeric character
\W	Any Non-alphanumeric character
{m}	m Repetitions
{m,n}	m to n Repetitions
*	Zero or more repetitions
+	One or more repetitions
?	Optional character
\s	Any Whitespace
\S	Any Non-whitespace character
^…$	Starts and ends
(…)	Capture Group
(a(bc))	Capture Sub-group
(.*)	Capture all
(abc|def)	Matches abc or def

Exercise 1: Matching Characters
Task	Text	 
Match	abcdefg	Success
Match	abcde	Success
Match	abc
=> ^abc

Exercise 1½: Matching Digits
Task	Text	 
Match	abc123xyz	
Match	define "123"	
Match	var g = 123;

=>123 


Exercise 2: Matching With Wildcards
Task	Text	 
Match	cat.	Success
Match	896.	Success
Match	?=+.	Success
Skip	abc1

=> ...\.

Exercise 3: Matching Characters
Task	Text	 
Match	can	Success
Match	man	Success
Match	fan	Success
Skip	dan	To be completed
Skip	ran	To be completed
Skip	pan

=> [cmf]an   or [^drp]an

Exercise 4: Excluding Characters
Task	Text	 
Match	hog	Success
Match	dog	Success
Skip	bog

=> [^b]og   <= not

Exercise 5: Matching Character Ranges
Task	Text	 
Match	Ana	Success
Match	Bob	Success
Match	Cpc	Success
Skip	aax	To be completed
Skip	bby	To be completed
Skip	ccz

=> [A-C][n-p][a-c]


Exercise 6: Matching Repeated Characters
Task	Text	 
Match	wazzzzzup	Success
Match	wazzzup	Success
Skip	wazup

=> waz{3,5}up

Exercise 7: Matching Repeated Characters
Task	Text	 
Match	aaaabcc	Success
Match	aabbbbc	Success
Match	aacc	Success
Skip	a

=> ^aa  || aa+b*c+  || a{2,4}b{0,4,}c{1,2}


Exercise 8: Matching Optional Characters
Task	Text	 
Match	1 file found?	Success
Match	2 files found?	Success
Match	24 files found?	Success
Skip	No files found.

=> \d+ files? found\?

Exercise 9: Matching Whitespaces  '\s' any whitespace
Task	Text	 
Match	1.   abc	Success
Match	2.	abc	Success
Match	3.           abc	Success
Skip	4.abc

=> \d\.\s+abc			. any char

Exercise 10: Matching Lines
Task	Text	 
Match	Mission: successful	To be completed
Skip	Last Mission: unsuccessful	To be completed
Skip	Next Mission: successful upon capture of target

=> ^M  ||    ^Mission: successful$


Exercise 11: Matching Groups
Task	Text	Capture Groups	 
Capture	file_record_transcript.pdf	
Capture	file_07241999.pdf	
Skip	testfile_fake.pdf.tmp

=>  ^(file.+)\.pdf$


Exercise 12: Matching Nested Groups
Task	Text	Capture Groups	 
Capture	Jan 1987	
Capture	May 1969	
Capture	Aug 2011

=> (\w+ (\d+))


Exercise 13: Matching Nested Groups
Task	Text	
Capture	1280x720	
Capture	1920x1600	
Capture	1024x768

=> (\d+)x(\d+)


Exercise 14: Matching Conditional Text
Task	Text	 
Match	I love cats	Success
Match	I love dogs	Success
Skip	I love logs	To be completed
Skip	I love cogs

=> I love (cats|dogs)

























################################
# 7. DEBUGGING SHELL PROGRAMS. #
################################

bash -n scriptname   # don't run commands; check for syntax errors only
set  -o noexec       # alternative (set option in script file)

bash -v scriptname   # echo commands before running them
set  -o verbose      # alternative (set option in script file)

bash -x scriptname   # echo commands after command-line processing
set  -o xtrace       # alternative (set option in script file)




trap 'echo $varname' EXIT  # useful when you want to print out the values of variables 
			     at the point that your script exits
			 
				 
function errtrap {
  es=$?
  echo "ERROR line $1: Command exited with status $es."
}

trap 'errtrap $LINENO' ERR  # is run whenever a command in the surrounding script or function exists with non-zero status 

function dbgtrap {
  echo "badvar is $badvar"
}

trap dbgtrap DEBUG  # causes the trap code to be executed before every statement in a function or script
# ...section of code in which the problem occurs...
trap - DEBUG  # turn off the DEBUG trap

function returntrap {
  echo "A return occured"
}

trap returntrap RETURN  # is executed each time a shell function or a script executed with the . or source commands finishes executing




















Fibonacci Script
Write a script to print the first 10 elements of Fibonacci series.
http://www.bashguru.com/2010/12/shell-script-to-generate-fibonacci.html

#-----------------------------------------------------------
$ a=1;b=1;for i in `seq 8`;do echo $((x=b,b=a+b,a=x));done
#-----------------------------------------------------------
$ echo $((b=1,a=0));for i in `seq 8`;do echo $((x=b,b=a+b,a=x));done
#-----------------------------------------------------------
#####################
#!/bin/bash -x
a=1
b=1
echo $a
echo $b
for i in 1 2 3 4 5 6 7 8
do

c=`expr $b + $a`
b=$a
a=$c

echo $c
done
### 1, 1, 2, 3, 5, 8, 13, 21, 34, 55


#------------------------------------------------------
#!/bin/bash
# Copy file to remote servers, Chmod +x, Run script

ids=noza  							#Source ID
idd=noza  							#destination ID

kcks="/home/$ids/rkchk.sh"      	# Source sh
kckd="/home/$idd/rkchk.sh"      	# destin sh

# list=$(cat "/home/$ids/slist")    #list of servers
list='192.168.232.158'

echo ------------------------------------
echo SCP is copying over to remote server
echo ------------------------------------
# bash -c  

for i in $list; do
	echo ------------------------------------
    echo $i >> log
	echo ------------------------------------

	scp $kcks $idd@$i:/home/$idd/

		echo "changing perm to running mode"

	ssh -t $idd@$i chmod +x $kckd

		echo "kernel ver check and report to logs file"

	ssh -t $idd@$i bash -c $kckd 2>&1 >> log

		echo ------------------------------------
		echo ------------------------------------
done

#------------------------------------------------------
#
#------------------------------------------------------
#!/bin/bash

hosts='host1 host2 host3'
sup='sup!123'

for i in $hosts; do
   echo "***** We are: $i *******"

    ssh -t $i <<EOCommand
        for d in $hosts
        do
            echo "******** Logging in from $i to: \$d *********"
            ssh \$d exit

            if [ $? = 0 ]; then
                echo "SSH login successful!"
            else
                echo "SSH login failed!"
            fi
        done
EOCommand
    echo "Finished block for $i"
done
#------------------------------------------------------

#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/rr")

echo ------------------------------------
echo SCP is copying over to remote server
echo ------------------------------------

for i in $list; do

     echo $i >> logs

 scp $kcks $idd@$i:/home/$idd/

     echo $kcks is copied.

     echo changing perm to running mode

 ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

     echo kernel ver check and report to logs file
     echo ---------------------------------------

done
#------------------------------------------------------

#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/rr")

for i in $list; do

    echo $i >> logs

    scp $kcks $idd@$i:/home/$idd/

    if ssh $idd@$i stat $kckd; then

        echo $kcks is copied.

    else

        echo $kcks is NOT copied!!!

    fi

    echo changing perm to runing mode

    ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

        echo kernel ver check and report to logs file

        echo ---------------------------------------

done

#------------------------------------------------------
#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"							<= file pointing
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/rr")							<= invoke file

for i in $list; do											

    echo $i >> logs

    ssh -q $idd@$i "test -e $kckd"		

        if [ $? -eq 0 ]; then

        echo $kcks is already existed.

        ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

    else

        scp $kcks $idd@$i:/home/$idd/

        ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

    fi

done


#------------------------------------------------------





#------------------------------------------------------


### Color ###
RED="\033[1;31m"
YELLOW="\033[1;33m"
GREEN="\033[1;32m"
BOLD="\033[1m"
RESET="\033[0m"

echo -e "${RED}vulnerable kernels CentOS 5, 6 and 7.${RESET}"



#--------------------------------------------------------------------------------
#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/i7")


for i in $list; do

    echo "------------------------------------------------" | tee -a logs
    echo $i | tee -a logs
    echo "------------------------------------------------" | tee -a logs


    ssh -q $idd@$i "test -e $kckd"

        if [ $? -eq 0 ]; then

            echo "$kckd is already exit" | tee -a logs


        else

            echo "$kckd is copying and running"

            scp $kcks $idd@$i:/home/$idd

            ssh -t $idd@$i "bash -c $kckd" 2>&1 | tee -a logs

        fi

    echo "------------------------------------------------" | tee -a logs

done
#--------------------------------------------------------------------------------

Count down 5 mins from SHELL
--------------------------------------
ct=$((5 * 60))           # 5 mins
while [ $ct -gt 0 ]; do
   echo -ne "$ct\033[0K\r"
   sleep 1
   : $((ct--))
done
------------------------------------------------------------------------------------------
"\033[0K" represents an end of line which cleans the rest of line if there are 
any characters left from previous output and \r is a carriage return which moves the cursor to the 
beginning of the line. There is a nice thread about this feature at stackoverflow.com.
http://stackoverflow.com/questions/12628327/how-to-show-and-update-echo-on-same-line
#--------------------------------------------------------------------------------


#--------------------------------------------------------------------------------
#!/bin/bash
### Comparing two directories ###
#set -x 		# Debug mode  +x is disable mode
#
# Usage: compare2dirs.sh DIR1_Name DIR2_Name #
usage="Usage: $0 DIR1_Name DIR2_Name"
 
#------------
if [ $# -gt 2 ]; then                   # number of command line parameters.
    echo $usage;						# if args are more than 2, echo $usage
    echo 1
fi

if [ $# -lt 2 ]; then                   # number of command line parameters.
    echo $usage;						# if args are less than 2, echo $usage
    echo 
fi

if [ -z "$1" ]; then                    # length of '$1' parameter is empty(zero string)
    echo $usage;
fi
#------------ Actual Code ------------#
if [ -d "$1" -a -d "$2" ]; then         # -d "$1" <= file exists and is a directory
                                        # -a      <= 'and' both dirs are exist
                                        # -d "$2" <= file exists and is a directory
    echo "Comparing $1 with $2 ....";
    diff -r $1 $2                       # -r <= recursively compare any subdirectories found
	
	### Where is the result output???
fi

#--------------------------------------------------------------------------------
# Alternative using find and git diff 
https://stackoverflow.com/questions/16787916/difference-between-two-directories-in-linux
find /dir1/ -type f -exec md5sum {} \; > dir1.txt
find /dir2/ -type f -exec md5sum {} \; > dir2.txt
diff dir1.txt dir2.txt

git diff --no-index dir1/ dir2/

#--------------------------------------------------------------------------------
### 5 mins count down from Shell ###

$ for i in {1..300}; do echo -ne $i '\r'; sleep 1; done; echo

#--------------------------------------------------------------------------------
Function 
## get pid ###

get_ntopng_pid() {
if [ -f "/etc/ntopng/ntopng.conf" ]; then
PID_FILE=$(cat /etc/ntopng/ntopng.conf | grep -E '-G=|--pid'|cut -d '=' -f 2)
else
PID_FILE="/var/tmp/ntopng.pid"
fi

#--------------------------------------------------------------------------------
### fork bomb ###
https://www.cyberciti.biz/faq/understanding-bash-fork-bomb/
$ :(){ :|:& };:
denial-of-service (DoS) attack against a Linux based system
is nothing but a bash function. This function get executed recursively. It is often used 
by sys admin to test user process limitations. Linux process limits can be configured via 
/etc/security/limits.conf and PAM

:(){
 :|:&
};:
#--------------------------------------------------------------------------------







#--------------------------------------------------------------------------------
### Object-oriented programming (OOP) ###
#--------------------------------------------------------------------------------
	is a programming paradigm that represents the concept of "objects" that have data fields 
	(attributes that describe the object) and associated procedures known as methods. Objects, 
	which are usually instances of classes, are used to interact with one another to design applications 
	and computer programs.[1][2] C++,Objective-C, Smalltalk, Java, C#, Perl, Python, Ruby and PHP are 
	examples of object-oriented programming languages.

	Object-oriented programming is an approach to designing modular, reusable software systems. Although 
	discussions of object-oriented technology often get mired in the details of one language vs. the other, 
	the real key to the object-oriented approach is that it is a modelling approach first.[3] Although often 
	hyped as a revolutionary way to develop software by zealous proponents, the object-oriented approach is 
	in reality a logical extension of good design practices that go back to the very beginning of computer 
	programming. Object-orientation is simply the logical extension of older techniques such as structured 
	programming andabstract data types. An object is an abstract data type with the addition 
	of polymorphism and inheritance.

	Rather than structure programs as code and data, an object-oriented system integrates the two using the 
	concept of an "object". An object has state (data) and behavior (code). Objects correspond to things 
	found in the real world. So for example, a graphics program will have objects such as circle, square, menu. 
	An online shopping system will have objects such as shopping cart, customer, product. The shopping system 
	will support behaviors such as place order, make payment, and offer discount. The objects are designed as 
	class hierarchies. So, for example, with the shopping system there might be high level classes such as 
	electronics product, kitchen product, and book. There may be further refinements for example under electronic 
	products: CD Player, DVD player, etc. These classes and subclasses correspond to sets and subsets 
	in mathematical logic.

	The goals of object-oriented programming are:
	•	Increased understanding.
	•	Ease of maintenance.
	•	Ease of evolution.

	The overall understanding of the system is increased because the semantic gap—the distance between the 
	language spoken by developers and that spoken by users—is lessened. Rather than talking about database 
	tables and programming subroutines, the developer talks about things the user is familiar with: 
	objects from their application domain.[4]
	
Object orientation eases maintenance by the use of encapsulation and information hiding. One of the 
most common sources of errors in programs is when one part of the system accidentally interferes with 
another part. For example, in the very earliest days of programming, it was common for developers to 
use "go to" statements to jump to arbitrary locations within only a few routines and functions. 
Critics called this "spaghetti code" because it is disorganized. Structured programming addresses 
this by encouraging the use of procedures and subroutines. Appropriate usage sections off 
responsibility for individual blocks to implement separate functionality. So, for example, one 
would know that the square root function was separate from the launch missiles function, and a 
change to one could not affect the other.[5]

Object-orientation takes this to the next step. It essentially merges abstract data types with 
structured programming and divides systems into modular objects which own their own data and are 
responsible for their own behavior. This feature is known as encapsulation. With encapsulation, 
not only can the "square root" and "launch missiles" functions not interfere with each other, 
but also the data for the two are divided up so that changes to one object cannot affect the other. 
Note that all this relies on the various languages being used appropriately, which, of course, 
is never certain. Object-orientation is not a software silver bullet, and it is not magic that 
makes all development problems go away.[6]

In addition to providing ease of maintenance, encapsulation and information hiding provide ease 
of evolution as well. Defining software as modular components that support inheritance makes it 
easy both to re-use existing components and to extend components as needed by defining new 
subclasses with specialized behaviors. This goal of being easy to both maintain and reuse is 
known in the object-oriented paradigm as the "open closed principle". A module is open if it 
supports extension (e.g. can easily modify behavior, add new properties, provide default values, etc.). 
A module is closed if it has a well defined stable interface that all other modules must use 
and that limits the interaction and potential errors that can be introduced into one module 
by changes in another.[7]

The object-oriented approach encourages the programmer to place data where it is not directly 
accessible by the rest of the system. Instead, the data is accessed by calling specially 
written functions, called methods, which are bundled with the data. These act as the 
intermediaries for retrieving or modifying the data they control. The programming construct 
that combines data with a set of methods for accessing and managing those data is called 
an object. The practice of using subroutines to examine or modify certain kinds of data 
was also used in non-OOP modular programming, well before the widespread use of object-oriented programming.
An object-oriented program usually contains different types of objects, each corresponding 
to a real-world object or concept such as a bank account, a hockey player, or a bulldozer. 
A program might contain multiple copies of each type of object, one for each of the real-world 
objects the program deals with. For instance, there could be one bank account object for 
each real-world account at a particular bank. Each copy of the bank account object would 
be alike in the methods it offers for manipulating or reading its data, but the data inside 
each object would differ, reflecting the different history of each account.
Objects can be thought of as encapsulating their data within a set of functions designed 
to ensure that the data are used appropriately, and to assist in that use. The object's 
methods typically include checks and safeguards specific to the data types the object 
contains. An object can also offer simple-to-use, standardized methods for performing 
particular operations on its data, while concealing the specifics of how those tasks 
are accomplished. In this way, alterations can be made to the internal structure or 
methods of an object without requiring that the rest of the program be modified. 
This approach can also be used to offer standardized methods across different types 
of objects. As an example, several different types of objects might offer print methods. 
Each type of object might implement that print method in a different way, reflecting 
the different kinds of data each contains, but all the different print methods might 
be called in the same standardized manner from elsewhere in the program. These features 
become especially useful when more than one programmer is contributing code to a project 
or when the goal is to reuse code between projects.

#--------------------------------------------------------------------------------
# 
#--------------------------------------------------------------------------------
