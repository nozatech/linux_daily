######################
### 1. Run Scripts ###
######################

https://www.shellcheck.net/
$ apt-get | yum install shellcheck	-y



# How to run a script
	$ ./script.sh
    $ sh ./script.sh  				 <= same as 'sh script.sh')
    $ sh +x script.sh   			 <= +x for debuging mode
	$ . script.sh   			     <= current login shell to run
    $ exec ./script   				 <= after run, the login shell exit 
	$ bash ./script.sh
	
	# run script as a different user from root
	$ wget http://tecmint.com/wp-content/scripts/tecmint_monitor.sh
	$ [apark@i7 ~]$ su -c "/home/apark/tecmint_monitor.sh" - root
	$ ./tecmint_monitor.sh -i    <- install
	$ monitor
	
# Run script WITHIN vim or vi
    :w   	      					<= write first
    :!sh %   (# :! sh %)     		<= : <-cmd ! <-run, sh <-shell, % =currently open file
	:!!         					<= run same script again 
    :!./script_name.sh
    :! python %
    :! perl %

### Save in read only file ###
	:w !sudo tee %                  	<= save as sudo privilege.  type (L) load at the prompt to reload.
	:w !chmod 777 %    then    :wq!
	
	:h									<= vi, vim help 			
	:q 									<= quit help page
	
	$ vi +101 file.txt					<= go to 101 line in filename
	:12									<= Go to particular line number in vi editor 
	
# Move	
	:15 <- go to 15th line
	$ vi +15 script.sh
	G 					<= go to bottom of page
	
	o					<= insert underneath line
	
	
 # VI Search and replace 	( http://vim.wikia.com/wiki/Search_and_replace )
	:s/foo/bar/g					<= current line only
	:%s/foo/bar/gc					<= % all, c to confirm first but also INSENSITVE
	#:%s/foo/bar/gci				<= i insensitive(save as above cmd)
	
	:%s/\<foo\>/bar/gc				<= Change only whole words exactly matching 'foo' to 'bar'
	
	# blank line delete
	:g/^$/d							<= :g will execute a command on lines which match a regex. 
										The regex is 'blank line'  
										:d (delete)
										
										
 # Debug mode	
    #!/bin/bash -x 					<= add " -x " for debugging mode in #!/bin/bash script
    $ bash -x ./script.sh  			( same as 'bash script.sh') 
    $ bash -vx script.sh			<= add -xv from shell -v <-verbose -x <-debug
	:! sh -x %						<= -x is for DEBUG(verbose) mode
    set -x              			<= End of file +x for TURN OFF
	$ bash -n ./script.sh 			<= checking syntax error
	
 # Stop and Exit running program
	$ vi 1.sh
	crtl + z 						<= exit to shell
	$ vi 2.sh
	$ jobs
	[1] Stopped  vim
	[2] Stopped  vim
	$ fg %1							<= go back to 1.sh
	ctrl + z
	
	$ kill %2
	$ kill -9 %2

 # Run from background
    $ ls -alR > /tmp/result.txt 2> /tmp/error.txt &
	$ jobs
	[1]+  Stopped                 vim
	[2]-  Stopped                 vim
	[3]   Done                    ls --color=auto -alR > /tmp/result.txt 2> /tmp/error.txt

	
### Script running remotely
--- Run a script on remote and out to local file

$ ssh-copy-id id@remote_ip             <= copy id_rsa.pub file into remote first

$ ssh id@remote_ip 'bash -s' < /home/scrhipt.sh >> output.log    		<= run as sudo mode

BASH ( https://linux.die.net/man/1/bash )
	-c  <= read from string
	-i  <= shell is interactive
	-s  <= read from the standard input
	

### Single line command script from SHELL ###

$ for i in $(cat ~/list); do ssh apark@$i [[ -f /home/apark/rkchk.sh ]] && echo "File exist" || echo "Not Exist";done                      
$ for i in $(cat "/home/apark/nu"); do ssh apark@$i "hostname && ls -l"; done
$ for i in $(cat "/home/apark/nu"); do ssh apark@$i "rm -f rkchk.sh"; done
$ for i in $(cat "/home/apark/nu"); do ssh -t apark@$i "sudo yum update kernel -y"; done

$ for i in us eu as; do echo sg-$i; ssh sg-$i "uptime"; done
$ for i in sg-us sg-eu sg-as ; do echo $i; date; done
$ for i in sg-eu sg-as ; do rsync -av authorized_keys $i:.ssh; done


$ for i in $(cat pmtip); do echo $i && ssh -t apark@$i cat /var/log/newrelic/nrsysmond.log | tail; done  2>&1 > log



$ while true; do dmesg -c ; sleep 1 ; done

$ while [ 1 ] ; do echo "ssh to 45.55.5.69...";ssh apark@45.55.5.69 'date; hostname'; sleep 10; done
$ while false ; do echo "ssh to 45.55.5.69...";ssh apark@45.55.5.69 'date; hostname'; sleep 10; done
while true; do tail -n0 -f /var/log/apache2/access.log > /tmp/tmp.log & sleep 2; kill $! ; wc -l /tmp/tmp.log | cut -c-2; done 2> /dev/null
	
	
	
Grouping Commands	
https://www.gnu.org/software/bash/manual/bashref.html#Command-Grouping

### ()   	<=  ( list )
	Placing a list of commands between parentheses causes a subshell environment to be created, and each of 
	the commands in list to be executed in that subshell. Since the list is executed in a subshell, variable 
	assignments do not remain in effect after the subshell completes.
### {} 		<=	{ list; }
	Placing a list of commands between curly braces causes the list to be executed in the current shell context. 
	No subshell is created. The semicolon (or newline) following list is required.	
	
	
	
	
	
	
	
	
	
	
	
	
	
### Within script Code
	#!/bin/bash
	### turn on debug mode
	set -x           <- Turn on/ Off " +x " debug mode
	for i in $(ls)
	do
		file $i
	done
------------------------------------
### /dev/null
	> /dev/null 2>&1     <= redirect the output of your program to /dev/null. 
							Include both the Standard Error and Standard Out	

# more commands
	set -x : Display commands and their arguments as they are executed.
	set -v : Display shell input lines as they are read. 
	

 
 # Move cursor to all the way down
	shift+G		<= All the way down the page
	
 # Check bash 
	$ echo $SHELL
	$ env | grep SHELL
	$ ps					 
	  1453 pts/1    00:00:00 bash  <= BASH
	$ ps | grep `echo $$` | awk '{ print $4 }'
	
### Quote in shell script ###

	$greeting="hello"
	### NO Quote	
	echo $greeting, world \(planet\)!
	   => hello, world (planet)!
	
	### Single Quote
	echo '$greeting, world (planet)!'
	   => $greeting, world (planet)!

	### Double Quote
	echo "$greeting, world (planet)!"
	    => hello, world (planet)!

	$ awk '/lemon/ && /rice/'					<= search two words


### Special Shell Variables ###
	$0 		file name of script
	$1		positional parameter #1
	$2-9	positional parameter #2-9
	${10}	positional parameter #10 and up e.g. 11, 12, 13....
	$#		number of positional parameter
	"$*"	all the positional parameters(as separate word)*
	"$@"	all the positional parameters(as separate strings)
	${#*}	number of positional parameters
	${#@}	number of positional parameters
	$?		return value
	$$	 	process ID(PID) of script
	$-		flags passed to script(using set)
	$_		last argument of previous command
	$!		process ID(PID) of last job run in background
	* Must be quoted, otherwise it defaults to $@


$ echo -n     do not output the trailing newline
       -e     enable interpretation of backslash escapes
       -E     disable interpretation of backslash escapes (default)

### "2>&1" command:
	Using "2>&1" , redirect the standard error(2) to standard output(1). The string "2>&1" indicates that any errors 
	should be sent to the standard output(1), that is, the Linux/Linux file id of 2 for standard error, and the file 
	id of 1 for standard output.  If you do not use this string, then you will be capturing only the good messages, 
	and the error messages will not be captured.
	
	cmd 1>&2
		stdout to same place as stderr
	cmd 2>&1
		stderr to same place as stdout
	cmd &> file
		Every output of cmd to file


Note: You must separate the square brackets from other text by a space.
e.g. [ ! -z $HOME ] 
      ^ ^space   ^space 
	  
### Common Bash comparisons
Operator	       Meaning									Example
-------------------------------------------------------------------------------------
-z			Length of String is (zero)EMPTY 					[ -z "$my_var" ]      		my_var=""
-n			Length of String is NOT (zero)EMPTY					[ -n "$my_var" ]            my_var="num"
-f			File is Exists & normal,regular 					[ -f "$myfile" ]
-d			Directory is Exists  								[ -d "$mydir" ]
-e 			file exist
-w			Writeable
=			Strings are same									[ "abc" = "$my_var" ]
!=			Strings are Not Same   								[ "abc" != "$my_var" ]


-eq	  		Equal (Numeric equality)							[ 3 -eq 3 ("$my_integer") ]
-ne			Not Equal(Numeric inequality)						[ 3 -ne 4 ("$my_integer") ]
-lt			Less than (Numeric strict less than)				[ 3 -lt 4 ("$my_integer") ]
-le			Less than or equals	(Numeric less than or equals)	[ 3 -le 4 ("$my_integer") ]
-gt			Greater than (Numeric strict greater than)			[ 3 -gt 2 ("$my_integer") ]
-ge			Greater than or equals(Numeric) 					[ 3 -ge 3 ("$my_integer") ]

-nt			First file is newer than second one					[ "$myfile" -nt ~/.bashrc ]
-ot			First file is older than second one					[ "$myfile" -ot ~/.bashrc ]


### Test [ expression ] statement for Comparison operation [[ expression ]]     0:TRUE  1:FALSE 
A. Comparing variables									           For Integer
	Less than			        [[ $1 < $2 ]]                    = (( $a < $B )) 
	greater than			    [[ $a > $b ]]
	less than or equal to 		[[ $a <= $b ]]
	greater than or equal to 	[[ $a >= $b ]]
	equal(same)			        [[ $a == $b ]]
	not equal(same)		        [[ $a != $b ]]
		
$ [ 9 -lt 10 ]; echo $?
$ [ "awesome" = "awesome" ]; echo $?
$ [ 10 == 10 ]; echo $?
$ [[ 1 < 2 ]] ; echo $?
$ (( 1 < 2 )) ; echo $?
$ (( 1 == 2 )) ; echo $?
1


---------------------------------------------------------------------------------------------------
() <- Subshell
( list )
	Placing a list of commands between parentheses causes a "SUBSHELL" environment to be created, 
	and each of the commands in list to be executed in that subshell. Since the list is executed 
	in a subshell, variable assignments do not remain in effect after the subshell completes.
$ ( a=A )
$ echo $a
A
### e.g.
$ cd ; unset files
$ count_tmp() (cd /tmp; files=(*); echo "${#files[@]}")
$ pwd; count_tmp; pwd
/home/jackman
11
/home/jackman
$ echo "${#files[@]}"
0
---------------------------------------------------------------------------------------------------
{}   <- Current Shell
{ list; }
	Placing a list of commands between curly braces causes the list to be executed in the "Current 
	shell" context. No subshell is created. The semicolon (or newline) following list is required.
$ { a=A; }
$ echo $a
A
### e.g.
$ count_tmp() { cd /tmp; files=(*); echo "${#files[@]}"; }
$ pwd; count_tmp; pwd
/home/jackman
11
/tmp
$ echo "${#files[@]}"
11  
---------------------------------------------------------------------------------------------------
		

The shell treats several parameters specially. These parameters may only be referenced; assignment to them is not allowed.

Table 3-3. Special bash variables

Character	Definition
$*	Expands to the positional parameters, starting from one. When the expansion 
	occurs within double quotes, it expands to a single word with the value of each 
	parameter separated by the first character of the IFS special variable.
$@	Expands to the positional parameters, starting from one. When the expansion occurs 
	within double quotes, each parameter expands to a separate word.
$#	Expands to the number of positional parameters in number(decimal).
$?	Expands to the "exit status" of the Last(most recently) executed foreground pipeline.
$-	A hyphen expands to the current option flags as specified upon invocation, by the 
	set built-in command, or those set by the shell itself (such as the -i).
$$	Expands to the process ID of the shell.
$!	Expands to the process ID of the most recently executed background (asynchronous)
	 command.
$0	Expands to the name of the shell or shell script.
$_	The underscore variable is set at shell startup and contains the absolute file name 
	of the shell or script being executed as passed in the argument list. Subsequently, 
	it expands to the last argument to the previous command, after expansion. It is also
	set to the full pathname of each command executed and placed in the environment 
	exported to that command. When checking mail, this parameter holds the name of the 
	mail file.


grep "echo" ./function1.sh
   	echo "Hi $1! what a nice $2!!"
	echo "And now, a greeting!"
	echo $_
	./function1.sh
	echo $$
	35810
	echo $!


	
$IFS   <-Internal Field Seperator

$ bash -c 'set w x y z; IFS=":-;"; echo "$*"'
w:x:y:z

Compare to:

$ bash -c 'set w x y z; IFS="-:;"; echo "$*"'
w-x-y-z	
	
	
######################## 
# Bash Shell Variables #
########################

varname=value                # defines a variable
varname=value command        # defines a variable to be in the environment of a particular subprocess
echo $varname                # checks a variable's value
echo $$                      # prints process ID of the current shell
echo $!                      # prints process ID of the most recently invoked background job
echo $?                      # displays the exit status of the last command
export VARNAME=value         # defines an environment variable (will be available in subprocesses)

array[0] = val               # several ways to define an array
array[1] = val
array[2] = val
array=([2]=val [0]=val [1]=val)
array(val val val)

${array[i]}                  # displays array's value for this index. If no index is supplied, array element 0 is assumed
${#array[i]}                 # to find out the length of any element in the array
${#array[@]}                 # to find out how many values there are in the array

declare -a                   # the variables are treated as arrays
declare -f                   # uses function names only
declare -F                   # displays function names without definitions
declare -i                   # the variables are treaded as integers
declare -r                   # makes the variables read-only(Constant)
	ex) declare -r NUM1=5
declare -x                   # marks the variables for export via the environment

${varname:-word}             # if varname exists and isn't null, return its value; otherwise return word
${varname:=word}             # if varname exists and isn't null, return its value; otherwise set it word and then return its value
${varname:?message}          # if varname exists and isn't null, return its value; otherwise print varname, followed by message and abort the current command or script
${varname:+word}             # if varname exists and isn't null, return word; otherwise return null
${varname:offset:length}     # performs substring expansion. It returns the substring of $varname starting at offset and up to length characters

${variable#pattern}          # if the pattern matches the beginning of the variable's value, delete the shortest part that matches and return the rest
${variable##pattern}         # if the pattern matches the beginning of the variable's value, delete the longest part that matches and return the rest
${variable%pattern}          # if the pattern matches the end of the variable's value, delete the shortest part that matches and return the rest
${variable%%pattern}         # if the pattern matches the end of the variable's value, delete the longest part that matches and return the rest
${variable/pattern/string}   # the longest match to pattern in variable is replaced by string. Only the first match is replaced
${variable//pattern/string}  # the longest match to pattern in variable is replaced by string. All matches are replaced

${#varname}                  # returns the length of the value of the variable as a character string

*(pattern list)               # matches zero or more occurences of the given patterns
+(pattern list)               # matches one or more occurences of the given patterns
?(pattern list)               # matches zero or one occurence of the given patterns
@(pattern list)               # matches exactly one of the given patterns
!(pattern list)               # matches anything except one of the given patterns

$(Linux command)              # command substitution: runs the command and returns standard output		
		
### White Sapce		
whitespace (spaces or tabs).



$ my_var=This is my environment variable!	
$ echo foo${my_var}bar							<= must use { }
fooThis is my environment variable!bar



### IF statement ###### IF statement ###### IF statement ###### IF statement ###
### IF statement ###### IF statement ###### IF statement ###### IF statement ###

$ test 100 -gt 99 && echo "Yes, that's true." || echo "No, that's false."
	Yes, that's true.
$ test 90 -gt 99 && echo "Yes, that's true." || echo "No, that's false."
	No, that's false.

	
#!/bin/bash
if [ $id -u = 0 ];then				# if (id -u) 0 = 0 are True
    echo "You are root" >&2			# 	
    exit 0
fi

---------------------------
#!/bin/bash
if [ $id -u = 0 ];then				# if (id -u) 0 = 0 are True
    echo "You are root" 			# 	
else
	echo "You are not root"
fi

	
### ! -z $HOME <= If home is NOT empty, echo $HOME
$ if [ ! -z $HOME ]; then echo $HOME; else echo "No Home"; fi
$ if [[ -n $HOME]]; then echo $HOME; else echo "No Home"; fi                     <= home is exist
/home/noza                                                                     <= Same answer
           
### -z $HOME    <= $HOME is empty which is False, echo "No Home"
$ if [ -z $HOME ]; then echo $HOME; else echo "no home"; fi
$ if [[ ! -n $HOME ]]; then echo $HOME; else echo "no home"; fi
no home  


$ if [[ ! -z $HOME ]]; then echo $HOME; elif [[ -z $HOME ]]; then echo "No Home"; fi
/home/noza



















### for_loop### for_loop### for_loop### for_loop### for_loop ###
### for_loop### for_loop### for_loop### for_loop### for_loop ###

#!/bin/bash

for i in $(ls)
do
    echo $i
done
------------------------------------

### for_loop1.sh		
#!/bin/bash
for i in *; do   # * is local directory
	echo “$i”
done
$./for_loop1.sh 
=> local files list
------------------------------------
### for_loop2.sh
#!/bin/bash
for i in $#; do
	echo “$i”			# zip archive "$i"
done
$./for_loop1.sh 1 2 3 4	
=> 4   <= total number of argument 1,2,3,4 is 4 total!
------------------------------------
### for_loop2.sh
#!/bin/bash
for i in $@; do
	echo “$i”			# zip archive "$i"
done
$./for_loop1.sh 1 2 3 4	
=> 1 2 3 4

------------------------------------
$ for i in {1..100..2};do echo $i; done
$ for (( i=1; i<=10; i++));do echo $i; done
$ for (( i=1; i<=10; i++));do echo -n $i `sleep 1`" "; done

### Array ###### Array ###### Array ###### Array ###### Array ###### Array ###### Array ###
### Array ###### Array ###### Array ###### Array ###### Array ###### Array ###### Array ###

ARRAY_NAME[index_number]=value
The Index_Number is treated as an arithmetic expression that must evaluate to a + positive number.

### Associate Array only works on BASH 4 &< 
------------------------------------
#!/bin/bash
array_name=("apple" "banaba" "cherry")
for i in ${array_name[@]}             # @ or * <- both works 
do
    echo -n `sleep 1` $i " "
done

------------------------------------
#!/bin/bash
declare -a array_name
array_name["0"]="Albert"
array_name["1"]="1234"

for i in "${!array_name[@]}"  				### ! <-access keys in array  ""<- if space is in array
do
    echo "$i \= ${array_name[$i]}"
done

"declare -a" declares an array and all the elements in the parentheses are the elements of an array.
 
$declare -a array_name=('Debian' 'Red hat' 'Red hat' 'Suse' 'Fedora');
$echo ${array_name[@]}
  Debian Red hat Red hat Suse Fedora

------------------------------------
#!/bin/bash
# Declaring an Array and Assigning values
declare -a Linux

Linux[0]="Debian"
Linux[1]="Redhat"
Linux[2]="Ubuntu"
Linux[3]="Suse"

for i in "${!Linux[@]}"   # whole elements of the array
do
  echo "$i: ${Linux[$i]}"
done
==>> Output
0: Debian
1: Redhat
2: Ubuntu
3: Suse

###  Length of the Bash Array ###
get the length of an array using the special parameter called $#.
${#array_name[@]} gives you the length of the array.

e.g.
$ declare -a Linux=('Debian' 'Red hat' 'Suse' 'Fedora');
# Number of elements in the array
$ echo ${#Linux[@]} 
  4
# Number of "characters" in the first element of the array.i.e Debian
$ echo ${#Linux}  		<- same as 0
  6
$ declare -a Linux=('Debian' 'Red hat' 'Suse' 'Fedora');
$ echo ${#Linux[3]}
  7  <- counting SPACE, too

------------------------------------
$ declare -a num=(1 22 333 4444 55555 666666)
$ echo ${#num[2]}
	3
$ echo ${num[4]}
	4  
 ------------------------------------ 
$ declare -a name=(albert sujin sumin)
$ echo ${name}
	albert
$ echo ${name[1]}
	sujin
$ echo ${#name}
	6
$ echo ${name[@]}
	albert sujin sumin

	
  
  
### Replace ###
$ Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
$ echo ${Unix[@]/Debian/Linux}
Linux

### Add more elements into array
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
Unix=("${Unix[@]}" "AIX" "HP-UX")
echo ${Unix[7]}
->AIX

### Remove elements from array
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
unset Unix[3]
echo ${Unix[@]}


### * wild including current directory files
#!/bin/sh
for i in hello 1 * 2 goodbye 
do
  echo "Looping ... i is set to $i"
done


### Test statement ###### Test statement ###### Test statement ###### Test statement ###
### Test statement ###### Test statement ###### Test statement ###### Test statement ###


if test  == if [ ]
[ expression ] 
[[ expression ]]  		<= extended e.g. grep, egrep
if (( integer comparison )); then

###
if expression
then
	echo "True"
#elif
else
	echo "False"
fi
###
------------------------------------
#!/bin/bash
# Integer comparison
a=5
b=4
if [ $a -gt $b ]; then
	echo "$a is greater than $b."
else
    echo "$a is less than $b."
fi
------------------------------------	
#!/bin/bash
# String matches using REGEX   =~ [0-9]+
a="This is my 1st string!"
if [[ $a =~ [0-9]+ ]]; then
    echo "There are Numbers in the string: $a"
else
    echo "There are no numbers in the string: $a"
fi
------------------------------------
#!/bin/bash
# empty variable or not
if [ -z "$my_var" ]
then
    echo "my_var is an Empty variable!!"
fi







17. if [ $id -u != "0" ] ;then
	echo "You must be the supper user" >&2  						<= user id -u is 0
	exit 1															<= exit status sets to 1(failure)
    fi

	
19. Arithmetic
	echo $(( 1+2 ))
	+, -, *, /, %, **,

------------------------------------	
#!/bin/bash
number=0
echo -n "Enter a number >"
read number
echo "The number is $number"
if [ $(( number %2 )) -eq 0 ]; then
    echo "The number is even"
else
    echo "The number is odd"
fi

------------------------------------
20. Read : within min time to input
# -t timing
# -s security hidden

	#!/bin/bash
	echo -n  "Enter your number before expire within 3sec: "
	echo seq 3
	
	if read -t 3  -s response; then
	        echo "Great, you made it in time"
	else
        	echo "Sorry, you are too slow"
	fi
------------------------------------
### 5 mins Time counting  (count down) 

$ for i in {0..300}; do echo -ne "$i" '\r'; sleep 1; done; echo 

	#\r is returning to begin of line (without new line - \n)
	# -n new line
	# -e escape

------------------------------------
### Directory or file name

#!/usr/bin/env bash
for myfile in /etc/r*
do
    if [ -d "$myfile" ]
    then
      echo "$myfile is a directory!"
    else
      echo "$myfile is a file name"
    fi
done



	
24. Test statement for Comparison operation [[ expression ]]     0:TRUE  1:FALSE 
	A. Comparing variables									        For Integer
		Less than			        [[ $a < $b ]]             = (( $a < $B )) 
		greater than			    [[ $a > $b ]]
		less than or equal to 		[[ $a <= $b ]]
		greater than or equal to 	[[ $a >= $b ]]
		equal(same)			        [[ $a == $b ]]
		not equal(same)		        [[ $a != $b ]]
	
	### String comparison
	ex) [[ "cat" == "cat" ]]
		a=cat
		b=dog
		[[ $a == $b ]]
		echo $?			<= 1:FALSE 0:TRUE

	B. Logical Operations
		AND     [[ $a && $b ]]
		OR   	[[ $a || $b ]] 
		NOT     [[ ! $a ]]

	C. Integer Number comparison operations
		less than			         [[ $a -lt $b ]]
		greater than			     [[ $a -gt $b ]]
		less than or equal to 		 [[ $a -le $b ]]
		greater than or equal to	 [[ $a -ge $b ]]
		equal				         [[ $a -eq $b ]]
		not equal			         [[ $a -ne $b ]]
		
	Eg)	[[ 20 -gt 100 ]]
		echo $?
	
	D. String null value
		is null(EMPTY)?			    [[ -z $a ]]   <= [[ !-z $a ]]
		is not null(EMPTY)?			[[ -n $a ]]   <= [[ !-n $a ]]

		
	Ex)	a=""
		b="cat"
		[[ -z $a && -n $b ]]
		echo $?

		if [ $? == 0 ]; then
			echo "TRUE"
		else
			echo "FALSE"
		fi



28. Array (can do from prompt)
	
	a=()
	b=("apple" "banana" "cherry" "$today" "$time")
	echo ${b[2]}
	b[5]="kiwi"
	b+=("mango")
	echo ${b[@]}            # @ <= whole array
	echo ${b[@]: -1}        # -1 <= last item in array
	
	
	
	
	
1. Comparisons: cmp vs diff
	cmp -  compare files byte by byte
	cmp -s $file1 $file2
    
    comm <= Compare two sorted files line by line   

    diff - compare files line by line
	diff $file1 $file2 > /dev/null

	sdiff  <= side by side comparison
	
	
32. if Condition statement

	a. if condition ; then	<= if condition is true, commands run
		commands
   	   fi			<= if condition is false, do nothing!

	b. if condition ; then  <= if condition is true, 1st commands run otherwise 
	   	commands   
	   else			<= if condition is false, 2nd commands run
		commands
	   fi

	c. if condition ; then   <= if condition is true, 1st commands run
	   	commands
	   elif conditions; then <= if condition is false, and if the 2nd command is true
	   	commands	 <= then 2nd set of commands run  	
	   if
	   
	#!/bin/bash
	if [ -f /etc/foo ]; then     # -f for file exit?
        	cp /etc/foo .
       		echo "copy done!"
	else
        	echo "This file does not exist"
        	exit (1 ??)
	fi
--------------------------------------------------

	if cmp -s "$file1" "$file2"
		then
	   echo "The files match"
	else
	   echo "The files are different"
	fi




# Exit code
	#!/bin/bash

	touch /root/test 2> /dev/null

	if [ $? -eq 0 ]
	then
  	  echo "Successfully created file"
	  exit 0
	else
	  echo "Could not create file" >&2
	  exit 1
	fi
	

	## With the exit command in this script, we will exit with a successful message 
	and 0 exit code if the touch command is successful. If the touch command fails 
	however, we will print a failure message to stderr and exit with a 1 value 
	which indicates failure. ##

	
	# Move or rename file from CMD
	$ if [ -e .vimrc ]; then mv .vimrc .vimrc_bak; fi

	
	
	
	
### While loop ###### While loop ###### While loop ###### While_loop ###### While_loop ###
### While loop ###### While loop ###### While loop ###### While_loop ###### While_loop ###

$while read i; do echo $i; done < while1.sh
#!/bin/bash
i=1
while read file; do
echo "Line $i: $file"
((i++))
done < echo.txt

------------------------------------
#!/bin/bash
i=1
while read file; do
    echo "Line $1: $file"
    (i++))
done < file.txt

Line 1: apple
Line 2: banaba
.......
------------------------------------
#!/bin/bash
# WHILE LOOP - i 가 10보다 적거나 같을때 까지
i=0
while [ $i -le 10 ]; do
    echo i is $i
#   ((i++))
    ((i+=1))
#   ((i=$i+1))
done

### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### 
### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ######

- J 가 10보다 크거나 같을때 가지.
j=0
until [ $j -ge 10 ]; do
    echo j is $j
    ((j++))
done
------------------------------------


#!/bin/bash

INPUT_STRING=hello

while [ "$INPUT_STRING" != "bye" ]
do
  echo "Please type something or type 'bye' to quit!"
  read INPUT_STRING
  echo "You typed '$INPUT_STRING' to exit."
done







33. while and until statement                   <= while & until true statement
	i=0
	while [ $i -le 10 ]; do
        	echo i = $i
        	((i++))
	done			<= 0 ~ 10
-------------------------------------------------
    j=0
    until [$j -ge 10 ]; do
        echo j = $j
       ((j++))
    done			<= 0 ~ 9
--------------------------------------------------

	#!/bin/bash
	x=0			<= initializing to 0
	while [ $x -le 10 ] ; do 
        echo "Current value of X is $x."
        ((x++))
		# x=$(($x + 1 ))
		# x=$(expr $x + 1 )  <= ((x++)                   
        sleep 1
	done
	prints 0 ~ 10
--------------------------------------------------
	x=0;

	while [ $x -gt -10 ] ; do
        echo "X value is $x"
	    ((x--))
	done


#!/bin/sh
INPUT_STRING=hello
#INPUT_STRING=  		                <= works too
while [ "$INPUT_STRING" != "bye" ]
do
  echo "Please type something in (bye to quit)"
  read INPUT_STRING
  echo "You typed: $INPUT_STRING"
done
	
	
	
	
34. for loop
	x="nozatech"
	for i in /home/*; do
		echo $x is exist in home directory
	done
	

35. file
	i=1
	while read f; do
		echo "Line $i: $f"
		((i++))
	done < ffile.txt	


e.g.
	if [ -f .bashrc ]; then	
	    echo "you have the .bashrc."
	else
		echo "No .bashrc found!"
	fi	

	if [ $(id -u) = "0" ]; then
		echo "supersuser"
	fi


37. read -p "What year?[nnnn] " a
   while [[ ! $a =~ [0-9]{4} ]]; do
       read -p "A year, pelase! [nnnn] " a
   done
   echo "Selected year: $a"

	
	
	
	
	mkdir
	$ mkdir -p production/{modules,manifests}  <= creating multi folders
	
	mkdir and cd into directory
	$ mkdir ~/docker-registry && cd $_


38. && ( AND )   

#T&&R    true  && echo runs		<= if cmd1 runs then cmd2 runs also 

#F&&N    false && echo runs		<= if cmd2 fails then cmd2 No runs
	
e.g.	cd $directory && rm -rf *

# Both run in cmd line and bash script
	    *TRUE*	   *RUN!*
	[ ! -d ~/tmp ] && mkdir ~/tmp
	echo $? <= 0  Success

	    *FALSE*	   *NO RUN*
	[ ! -d ~/tmp ] && mkdir ~/tmp
	echo $? <= 1  fail  Did not created!


Coding
### FIZZBUZZ  ###	
	Prints out when there is a number divied by 3 == 0, then fizz
	Prints out when there is a number divied by 5 == 0, then buzz
	Prints out when there is a number divied by 3 == 0 && 5 == 0, then FizzBuzz

	
	#!/bin/bash  
	for i in {1..100}; do
        if (( i % 3 == 0 )) && (( i % 5 == 0)); then echo "fizzbuzz"
                elif (( i % 3 == 0 )); then echo "fizz"
                elif (( i % 5 == 0 )); then echo "buzz"
        else
                echo $i;
        fi
	done

	
	#!/bin/bash
	for i in {1..100}; do
		if (! ((i % 3)) ) && (! ((i % 5)) ); then echo "FizzBuzz"
			elif (! ((i % 3)) ); then echo "fizz"
			elif (! ((i % 5)) ); then echo "buzz"
		else
			echo $i;
		fi
	done

	### check modulo value from terminal ###
	# m=$(( 1 % 5 ))
	# echo $m
	# 1
	# m=$(( 55 % 5 ))
	# echo $m
	# 0

39. || ( OR )

#T||N    true  || echo runs		<= if cmd1 runs then cmd2 NO runs

#F||R    false || echo runs		<= if cmd1 fails then cmd2 RUNS!

   	     *TRUE*	   *NO RUN*
	[ -d ~/tmp ] || mkdir ~/tmp
	echo $? <= 1  False

	    *FALSE*	   *YES RUN*
	[ -d ~/tmp ] || mkdir ~/tmp
	echo $? <= 0  Created folder!





e.g.    cd $directory || error_exit "No such dir and aborting!"




39. Function

#!/bin/bash
function numberthings {		<= Declaring function name
    i=1			<= 
    for f in $@; do		<= $@ special array variable that represents all 
								of the arguments pass to a function
        echo $i: $f
        ((i+=1))			<= incrementing ((i++)) or ((i=i+1))
    done
}

numberthings $(ls)
numberthings pine birch maple spruce




40. Argument
	#!/bin/bash
	echo $1
	echo $2

    $./my.sh apple banana


	#!/bin/bash
	echo $1
	echo $2
    $./my.sh "apple Apple" "banana Banana"   <=use " " for when space in them

###
# Don't have to define the variables to saves a lot of time
###

	#!/bin/bash
	for i in $@			<= array arugment $@
	do
		echo $i
	done
	echo "There were $# arugments." <= $# contains number of argument

$./my.sh apple orange kiwi lemon



### CASE statement ###### CASE statement ###### CASE statement ###### CASE statement ###### CASE statement ###
### CASE statement ###### CASE statement ###### CASE statement ###### CASE statement ###### CASE statement ###

#!/bin/bash
a="dog"
case $a in
    cat)       echo "It is a cat_name";;
    dog|puppy) echo "It is a dog_name";;   				# | <- pipe to match dog or puppy
    *)         echo "No match!";;
esac

------------------------------------
#!/bin/bash
while read i
do
  case $i in
        hello)  echo 1;;
        howdy)  echo 2;;
  esac
done < myfile.txt 
	myfile.txt
	hello
	howdy

	


### Function statement ###### Function statement ###### Function statement ###### Function statement ###
### Function statement ###### Function statement ###### Function statement ###### Function statement ###

#!/bin/bash
function greeting {
	echo "Hello There!"
}
echo "And now, a greeting!"
greeting
------------------------------------
#!/bin/bash
#A function to print "Hello World"
hello()
    {
      echo "Hello World"
    }
hello;
------------------------------------
#!/bin/bash
#function quit {
#    exit
#}
quit() {
	exit
}
function hello {
    echo Hello!
}
hello
quit
------------------------------------
#!/bin/bash
function quit { exit}
function input { echo $1 }    # $1 <-first argument pass to the function, but $@ <- works too.      
input hello
input world
quit  						  # exit
------------------------------------
#!/bin/bash
#numberthings (){
function numberthings {
        i=1
        for f in $@; do
                echo $i: $f
                ((i++))
        done
}

echo "First function"
numberthings $(ls)

echo "Second function"
numberthings pine birch maple spruce
------------------------------------

#!/bin/bash
#function to display commands
display() { echo "\$ $@" ; "$@" ; }
#display() { echo "\$ $@" 
			 echo "$@"  }
display echo hello world

------------------------------------
#!/bin/bash
function greet {
	echo "Hi, $1! What a nice $2!"
}
echo "And now, a greeting!"
greet Albert Morning
greet Everyone Evening






















	
######################################################################################################################################
# Bash Scripting
######################################################################################################################################
These are positional arguments of the script. 
position of arguments passed to the script on the command line, not line numbers
#!/bin/sh
echo "$1"
echo "$2"

./script.sh Hello World
$0 = script.sh             <- File name of the current script
$1 = Hello
$2 = World	
	
The $@ variable expands to all the parameters used when calling the function

function foo()
{
    echo "$@"
}
foo 1 2 3


It would display 1 2 3. If not used inside a function, it specifies all parameters 
used when calling the script. See the bash manual page for more info.	
	
The shell treats several parameters specially. These parameters may only be referenced; assignment to them is not allowed.

*
($*) Print all the parameter.
	 Expands to the positional parameters, starting from one. When the expansion is not within double quotes, 
     each positional parameter expands to a separate word. In contexts where it is performed, those words are 
	 subject to further word splitting and pathname expansion. When the expansion occurs within double quotes, 
	 it expands to a single word with the value of each parameter separated by the first character of the IFS 
	 special variable. That is, "$*" is equivalent to "$1c$2c…", where c is the first character of the value 
	 of the IFS variable. If IFS is unset, the parameters are separated by spaces. If IFS is null, the parameters 
	 are joined without intervening separators.

@
($@) Individually double quoted 
	Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, 
	each parameter expands to a separate word. That is, "$@" is equivalent to "$1" "$2" …. If the double-quoted 
	expansion occurs within a word, the expansion of the first parameter is joined with the beginning part of the 
	original word, and the expansion of the last parameter is joined with the last part of the original word. 
	When there are no positional parameters, "$@" and $@ expand to nothing (i.e., they are removed).

#
($#) Expands to the number of positional parameters in decimal(Counts number of parameters).	
 
($?) Exit status of the last command
	0 - successful
	1 - fail
	e.g. echo $?
($$) Process ID under which order getting executed

(?!) Process number of the last background command
 
 
------------------------------------
#!/bin/bash
echo "Hello, World. Calls $# of parameters"	
echo "argument 0 is '$0'"
.....	
echo "argument 9 is '$9'"
echo "argument 10 is '{$10}'"	 # from 10, use {} 

./argument.sh a b ... y z
		Hello, World. Calls 24 of parameters
		argument 0 is './argument.sh'
		argument 1 is 'a'
		.....
		argument 10 is 'j'
	
	
79.Special parameters


  
###############
# FUNCTIONS   #
###############
The function refers to passed arguments by position (as if they were positional parameters), that is, $1, $2, and so forth. $@ is equal to "$1" "$2"... "$N", where N is the number of positional parameters. $# holds the number of positional parameters.
functname() {
  shell commands
}

unset -f functname  # deletes a function definition
declare -f          # displays all defined functions in your login session
2.3. FLOW CONTROL.

statement1 && statement2  # and operator
statement1 || statement2  # or operator

-a                        # and operator inside a test conditional expression
-o                        # or operator inside a test conditional expression

str1=str2                 # str1 matches str2
str1!=str2                # str1 does not match str2
str1<str2                 # str1 is less than str2
str1>str2                 # str1 is greater than str2
-n str1                   # str1 is not null (has length greater than 0)
-z str1                   # str1 is null (has length 0)

-a file                   # file exists
-d file                   # file exists and is a directory
-e file                   # file exists; same -a
-f file                   # file exists and is a regular file (i.e., not a directory or other special type of file)
-r file                   # you have read permission
-r file                   # file exists and is not empty
-w file                   # your have write permission
-x file                   # you have execute permission on file, or directory search permission if it is a directory
-N file                   # file was modified since it was last read
-O file                   # you own file
-G file                   # file's group ID matches yours (or one of yours, if you are in multiple groups)
file1 -nt file2           # file1 is newer than file2
file1 -ot file2           # file1 is older than file2

-lt                       # less than
-le                       # less than or equal
-eq                       # equal
-ge                       # greater than or equal
-gt                       # greater than
-ne                       # not equal

if condition
then
  statements
[elif condition
  then statements...]
[else
  statements]
fi

for x := 1 to 10 do
begin
  statements
end

for name [in list]
do
  statements that can use $name
done

for (( initialisation ; ending condition ; update ))
do
  statements...
done

case expression in
  pattern1 )
    statements ;;
  pattern2 )
    statements ;;
  ...
esac

select name [in list]
do
  statements that can use $name
done

while condition; do
  statements
done

until condition; do
  statements
done

##################################
# 4. INPUT/OUTPUT REDIRECTORS.   #
##################################
cmd1 | cmd2  # pipe; takes standard output of cmd1 as standard input to cmd2
> file       # directs standard output to file
< file       # takes standard input from file
>> file      # directs standard output to file; append to file if it already exists
>|file       #   forces standard output to file even if noclobber is set
n>|file      # forces output to file from file descriptor n even if noclobber is set
<> file      # uses file as both standard input and standard output
n<>file      # uses file as both input and output for file descriptor n
<<label      # here-document
n>file       # directs file descriptor n to file
n<file       # takes file descriptor n from file
n>>file      # directs file description n to file; append to file if it already exists
n>&          # duplicates standard output to file descriptor n
n<&          # duplicates standard input from file descriptor n
n>&m         # file descriptor n is made to be a copy of the output file descriptor
n<&m         # file descriptor n is made to be a copy of the input file descriptor
&>file       # directs standard output and standard error to file
<&-          # closes the standard input
>&-          # closes the standard output
n>&-         # closes the ouput from file descriptor n
n<&-         # closes the input from file descriptor n



##############################
### 5. Regular Expression  ###
##############################
Basic Regular Expression
Operator	Effect
.			Matches any single character.
?			The preceding item is optional and will be matched, at most, once.
*			The preceding item will be matched zero or more times.
^			Start with(Matches the empty string at the beginning of a line; 
					  also represents the characters not in the range of a list.)
$			Matches the empty string at the end of a line.
+			The preceding item will be matched one or more times.
{N}			The preceding item is matched exactly N times.
{N,}		The preceding item is matched N or more times.
{N,M}		The preceding item is matched at least N times, but not more than M times.
-			represents the range if it's not first or last in a list or the ending point of a range in a list.
\b			Matches the empty string at the edge of a word.
\B			Matches the empty string provided it's not at the edge of a word.
\<			Match the empty string at the beginning of word.
\>			Match the empty string at the end of word.

### Extended regular expressions
	In basic regular expressions the metacharacters "?", "+", "{", "|", "(", and ")" lose their special meaning; 
	instead use the backslashed versions "\?", "\+", "\{", "\|", "\(", and "\)".


e.g.
$ grep ^root /etc/passwd
	root:x:0:0:root:/root:/bin/bash

$







################################
# 7. DEBUGGING SHELL PROGRAMS. #
################################

bash -n scriptname   # don't run commands; check for syntax errors only
set  -o noexec       # alternative (set option in script file)

bash -v scriptname   # echo commands before running them
set  -o verbose      # alternative (set option in script file)

bash -x scriptname   # echo commands after command-line processing
set  -o xtrace       # alternative (set option in script file)




trap 'echo $varname' EXIT  # useful when you want to print out the values of variables 
			     at the point that your script exits
			 
				 
function errtrap {
  es=$?
  echo "ERROR line $1: Command exited with status $es."
}

trap 'errtrap $LINENO' ERR  # is run whenever a command in the surrounding script or function exists with non-zero status 

function dbgtrap {
  echo "badvar is $badvar"
}

trap dbgtrap DEBUG  # causes the trap code to be executed before every statement in a function or script
# ...section of code in which the problem occurs...
trap - DEBUG  # turn off the DEBUG trap

function returntrap {
  echo "A return occured"
}

trap returntrap RETURN  # is executed each time a shell function or a script executed with the . or source commands finishes executing




















Fibonacci Script
Write a script to print the first 10 elements of Fibonacci series.
http://www.bashguru.com/2010/12/shell-script-to-generate-fibonacci.html

#-----------------------------------------------------------
$ a=1;b=1;for i in `seq 8`;do echo $((x=b,b=a+b,a=x));done
#-----------------------------------------------------------
$ echo $((b=1,a=0));for i in `seq 8`;do echo $((x=b,b=a+b,a=x));done
#-----------------------------------------------------------
#####################
#!/bin/bash -x
a=1
b=1
echo $a
echo $b
for i in 1 2 3 4 5 6 7 8
do

c=`expr $b + $a`
b=$a
a=$c

echo $c
done
### 1, 1, 2, 3, 5, 8, 13, 21, 34, 55


#------------------------------------------------------
#!/bin/bash
# Copy file to remote servers, Chmod +x, Run script

ids=noza  							#Source ID
idd=noza  							#destination ID

kcks="/home/$ids/rkchk.sh"      	# Source sh
kckd="/home/$idd/rkchk.sh"      	# destin sh

# list=$(cat "/home/$ids/slist")    #list of servers
list='192.168.232.158'

echo ------------------------------------
echo SCP is copying over to remote server
echo ------------------------------------

for i in $list; do
	echo ------------------------------------
    echo $i >> log
	echo ------------------------------------

	scp $kcks $idd@$i:/home/$idd/

		echo "changing perm to running mode"

	ssh -t $idd@$i chmod +x $kckd

		echo "kernel ver check and report to logs file"

	ssh -t $idd@$i bash -c $kckd 2>&1 >> log

		echo ------------------------------------
		echo ------------------------------------
done

#------------------------------------------------------
#
#------------------------------------------------------
#!/bin/bash

hosts='host1 host2 host3'
sup='sup!123'

for i in $hosts; do
   echo "***** We are: $i *******"

    ssh -t $i <<EOCommand
        for d in $hosts
        do
            echo "******** Logging in from $i to: \$d *********"
            ssh \$d exit

            if [ $? = 0 ]; then
                echo "SSH login successful!"
            else
                echo "SSH login failed!"
            fi
        done
EOCommand
    echo "Finished block for $i"
done
#------------------------------------------------------

#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/rr")

echo ------------------------------------
echo SCP is copying over to remote server
echo ------------------------------------

for i in $list; do

     echo $i >> logs

 scp $kcks $idd@$i:/home/$idd/

     echo $kcks is copied.

     echo changing perm to running mode

 ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

     echo kernel ver check and report to logs file
     echo ---------------------------------------

done
#------------------------------------------------------

#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/rr")

for i in $list; do

    echo $i >> logs

    scp $kcks $idd@$i:/home/$idd/

    if ssh $idd@$i stat $kckd; then

        echo $kcks is copied.

    else

        echo $kcks is NOT copied!!!

    fi

    echo changing perm to runing mode

    ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

        echo kernel ver check and report to logs file

        echo ---------------------------------------

done

#------------------------------------------------------
#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"							<= file pointing
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/rr")							<= invoke file

for i in $list; do											

    echo $i >> logs

    ssh -q $idd@$i "test -e $kckd"		

        if [ $? -eq 0 ]; then

        echo $kcks is already existed.

        ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

    else

        scp $kcks $idd@$i:/home/$idd/

        ssh -t $idd@$i "chmod +x $kckd && $kckd 2>&1" >> logs

    fi

done


#------------------------------------------------------





#------------------------------------------------------


### Color ###
RED="\033[1;31m"
YELLOW="\033[1;33m"
GREEN="\033[1;32m"
BOLD="\033[1m"
RESET="\033[0m"

echo -e "${RED}vulnerable kernels CentOS 5, 6 and 7.${RESET}"



#--------------------------------------------------------------------------------
#!/bin/bash

ids=noza
idd=apark

kcks="/home/$ids/rkchk.sh"
kckd="/home/$idd/rkchk.sh"

list=$(cat "/home/$ids/i7")


for i in $list; do

    echo "------------------------------------------------" | tee -a logs
    echo $i | tee -a logs
    echo "------------------------------------------------" | tee -a logs


    ssh -q $idd@$i "test -e $kckd"

        if [ $? -eq 0 ]; then

            echo "$kckd is already exit" | tee -a logs


        else

            echo "$kckd is copying and running"

            scp $kcks $idd@$i:/home/$idd

            ssh -t $idd@$i "bash -c $kckd" 2>&1 | tee -a logs

        fi

    echo "------------------------------------------------" | tee -a logs

done
#--------------------------------------------------------------------------------

Count down 5 mins from SHELL
--------------------------------------
ct=$((5 * 60))           # 5 mins
while [ $ct -gt 0 ]; do
   echo -ne "$ct\033[0K\r"
   sleep 1
   : $((ct--))
done
------------------------------------------------------------------------------------------
"\033[0K" represents an end of line which cleans the rest of line if there are 
any characters left from previous output and \r is a carriage return which moves the cursor to the 
beginning of the line. There is a nice thread about this feature at stackoverflow.com.
http://stackoverflow.com/questions/12628327/how-to-show-and-update-echo-on-same-line
#--------------------------------------------------------------------------------






















