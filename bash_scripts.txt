######################
### 1. Run Scripts ###
######################

# How to run a script
	$ ./script.sh
    $ sh ./script.sh  				 <= same as 'sh script.sh')
    $ sh +x script.sh   			 <= +x for debuging mode
	$ . script.sh   			     <= current login shell to run
    $ exec ./script   				 <= after run, the login shell exit 
	
# Run script WITHIN vim or vi
    :w   	      					<= write first
    :!sh %   (# :! sh %)     		<= : <-cmd ! <-run, sh <-shell, % =currently open file
	:!!         					<= run same script again 
    :!./script_name.sh
    :! python %
    :! perl %
	
 # VI Search and replace
	:%s/foo/bar/g
	:%s/foo/bar/gc					<= to confirm first
	
 # Debug mode	
    #!/bin/bash -x 					<= add " -x " for debugging mode in #!/bin/bash script
    $ bash -x ./script.sh  			( same as 'bash script.sh') 
    $ bash -vx script.sh			<= add -xv from shell -v <-verbose -x <-debug
	:! sh -x %						<= -x is for DEBUG(verbose) mode
    set -x              			<= End of file +x for TURN OFF

	
### Within script Code
	#!/bin/bash
	### turn on debug mode
	set -x           <- Turn on/ Off " +x " debug mode
	for i in $(ls)
	do
		file $i
	done
------------------------------------
### /dev/null
	> /dev/null 2>&1     <= redirect the output of your program to /dev/null. 
							Include both the Standard Error and Standard Out	

# more commands
	set -x : Display commands and their arguments as they are executed.
	set -v : Display shell input lines as they are read. 
	
 ### Save in read only file ###
	:w !sudo tee %                  	<= save as sudo privilege.  type (L) load at the prompt to reload.
	:w !chmod 777 %    then    :wq!
	
	:h									<= vi, vim help 			
	:q 									<= quit help page
	
	$ vi +101 file.txt					<= go to 101 line in filename
	:12									<= Go to particular line number in vi editor 
 
 # Move cursor to all the way down
	shift+G		<= All the way down the page
	
 # Check bash 
	$ echo $SHELL
	$ env | grep SHELL
	$ ps					 
	  1453 pts/1    00:00:00 bash  <= BASH
	$ ps | grep `echo $$` | awk '{ print $4 }'
	
### Quote in shell script ###

	$greeting="hello"
	### NO Quote	
	echo $greeting, world \(planet\)!
	   => hello, world (planet)!
	
	### Single Quote
	echo '$greeting, world (planet)!'
	   => $greeting, world (planet)!

	### Double Quote
	echo "$greeting, world (planet)!"
	    => hello, world (planet)!

	$ awk '/lemon/ && /rice/'					<= search two words


### Special Shell Variables ###
	$0 		file name of script
	$1		positional parameter #1
	$2-9	positional parameter #2-9
	${10}	positional parameter #10 and up e.g. 11, 12, 13....
	$#		number of positional parameter
	"$*"	all the positional parameters(as separate word)*
	"$@"	all the positional parameters(as separate strings)
	${#*}	number of positional parameters
	${#@}	number of positional parameters
	$?		return value
	$$	 	process ID(PID) of script
	$-		flags passed to script(using set)
	$_		last argument of previous command
	$!		process ID(PID) of last job run in background
	* Must be quoted, otherwise it defaults to $@


$ echo -n     do not output the trailing newline
       -e     enable interpretation of backslash escapes
       -E     disable interpretation of backslash escapes (default)

### "2>&1" command:
	Using "2>&1" , redirect the standard error(2) to standard output(1). The string "2>&1" indicates that any errors 
	should be sent to the standard output(1), that is, the Linux/Linux file id of 2 for standard error, and the file 
	id of 1 for standard output.  If you do not use this string, then you will be capturing only the good messages, 
	and the error messages will not be captured.
	
	cmd 1>&2
		stdout to same place as stderr
	cmd 2>&1
		stderr to same place as stdout
	cmd &> file
		Every output of cmd to file


Note: You must separate the square brackets from other text by a space.
e.g. [ ! -z $HOME ] 
      ^ ^space   ^space 
	  
### Common Bash comparisons
Operator	       Meaning									Example
-------------------------------------------------------------------------------------
-z			Length of String is (zero)EMPTY 					[ -z "$my_var" ]      		my_var=""
-n			Length of String is NOT (zero)EMPTY					[ -n "$my_var" ]            my_var="num"
-f			File is Exists & normal,regular 					[ -f "$myfile" ]
-d			Directory is Exists  								[ -d "$mydir" ]
-e 			file exist
-w			Writeable
=			Strings are same									[ "abc" = "$my_var" ]
!=			Strings are Not Same   								[ "abc" != "$my_var" ]


-eq	  		Equal (Numeric equality)							[ 3 -eq 3 ("$my_integer") ]
-ne			Not Equal(Numeric inequality)						[ 3 -ne 4 ("$my_integer") ]
-lt			Less than (Numeric strict less than)				[ 3 -lt 4 ("$my_integer") ]
-le			Less than or equals	(Numeric less than or equals)	[ 3 -le 4 ("$my_integer") ]
-gt			Greater than (Numeric strict greater than)			[ 3 -gt 2 ("$my_integer") ]
-ge			Greater than or equals(Numeric) 					[ 3 -ge 3 ("$my_integer") ]

-nt			First file is newer than second one					[ "$myfile" -nt ~/.bashrc ]
-ot			First file is older than second one					[ "$myfile" -ot ~/.bashrc ]


### Test [ expression ] statement for Comparison operation [[ expression ]]     0:TRUE  1:FALSE 
A. Comparing variables									           For Integer
	Less than			        [[ $1 < $2 ]]                    = (( $a < $B )) 
	greater than			    [[ $a > $b ]]
	less than or equal to 		[[ $a <= $b ]]
	greater than or equal to 	[[ $a >= $b ]]
	equal(same)			        [[ $a == $b ]]
	not equal(same)		        [[ $a != $b ]]
		
$ [ 9 -lt 10 ]; echo $?
$ [ "awesome" = "awesome" ]; echo $?
$ [ 10 == 10 ]; echo $?
$ [[ 1 < 2 ]] ; echo $?
$ (( 1 < 2 )) ; echo $?
$ (( 1 == 2 )) ; echo $?
1


---------------------------------------------------------------------------------------------------
() <- Subshell
( list )
	Placing a list of commands between parentheses causes a "SUBSHELL" environment to be created, 
	and each of the commands in list to be executed in that subshell. Since the list is executed 
	in a subshell, variable assignments do not remain in effect after the subshell completes.
$ ( a=A )
$ echo $a
A
### e.g.
$ cd ; unset files
$ count_tmp() (cd /tmp; files=(*); echo "${#files[@]}")
$ pwd; count_tmp; pwd
/home/jackman
11
/home/jackman
$ echo "${#files[@]}"
0
---------------------------------------------------------------------------------------------------
{}   <- Current Shell
{ list; }
	Placing a list of commands between curly braces causes the list to be executed in the "Current 
	shell" context. No subshell is created. The semicolon (or newline) following list is required.
$ { a=A; }
$ echo $a
A
### e.g.
$ count_tmp() { cd /tmp; files=(*); echo "${#files[@]}"; }
$ pwd; count_tmp; pwd
/home/jackman
11
/tmp
$ echo "${#files[@]}"
11  
---------------------------------------------------------------------------------------------------
		

The shell treats several parameters specially. These parameters may only be referenced; assignment to them is not allowed.

Table 3-3. Special bash variables

Character	Definition
$*	Expands to the positional parameters, starting from one. When the expansion 
	occurs within double quotes, it expands to a single word with the value of each 
	parameter separated by the first character of the IFS special variable.
$@	Expands to the positional parameters, starting from one. When the expansion occurs 
	within double quotes, each parameter expands to a separate word.
$#	Expands to the number of positional parameters in number(decimal).
$?	Expands to the "exit status" of the Last(most recently) executed foreground pipeline.
$-	A hyphen expands to the current option flags as specified upon invocation, by the 
	set built-in command, or those set by the shell itself (such as the -i).
$$	Expands to the process ID of the shell.
$!	Expands to the process ID of the most recently executed background (asynchronous)
	 command.
$0	Expands to the name of the shell or shell script.
$_	The underscore variable is set at shell startup and contains the absolute file name 
	of the shell or script being executed as passed in the argument list. Subsequently, 
	it expands to the last argument to the previous command, after expansion. It is also
	set to the full pathname of each command executed and placed in the environment 
	exported to that command. When checking mail, this parameter holds the name of the 
	mail file.


grep "echo" ./function1.sh
   	echo "Hi $1! what a nice $2!!"
	echo "And now, a greeting!"
	echo $_
	./function1.sh
	echo $$
	35810
	echo $!


	
$IFS   <-Internal Field Seperator

$ bash -c 'set w x y z; IFS=":-;"; echo "$*"'
w:x:y:z

Compare to:

$ bash -c 'set w x y z; IFS="-:;"; echo "$*"'
w-x-y-z	
	
	
######################## 
# Bash Shell Variables #
########################

varname=value                # defines a variable
varname=value command        # defines a variable to be in the environment of a particular subprocess
echo $varname                # checks a variable's value
echo $$                      # prints process ID of the current shell
echo $!                      # prints process ID of the most recently invoked background job
echo $?                      # displays the exit status of the last command
export VARNAME=value         # defines an environment variable (will be available in subprocesses)

array[0] = val               # several ways to define an array
array[1] = val
array[2] = val
array=([2]=val [0]=val [1]=val)
array(val val val)

${array[i]}                  # displays array's value for this index. If no index is supplied, array element 0 is assumed
${#array[i]}                 # to find out the length of any element in the array
${#array[@]}                 # to find out how many values there are in the array

declare -a                   # the variables are treated as arrays
declare -f                   # uses function names only
declare -F                   # displays function names without definitions
declare -i                   # the variables are treaded as integers
declare -r                   # makes the variables read-only(Constant)
	ex) declare -r NUM1=5
declare -x                   # marks the variables for export via the environment

${varname:-word}             # if varname exists and isn't null, return its value; otherwise return word
${varname:=word}             # if varname exists and isn't null, return its value; otherwise set it word and then return its value
${varname:?message}          # if varname exists and isn't null, return its value; otherwise print varname, followed by message and abort the current command or script
${varname:+word}             # if varname exists and isn't null, return word; otherwise return null
${varname:offset:length}     # performs substring expansion. It returns the substring of $varname starting at offset and up to length characters

${variable#pattern}          # if the pattern matches the beginning of the variable's value, delete the shortest part that matches and return the rest
${variable##pattern}         # if the pattern matches the beginning of the variable's value, delete the longest part that matches and return the rest
${variable%pattern}          # if the pattern matches the end of the variable's value, delete the shortest part that matches and return the rest
${variable%%pattern}         # if the pattern matches the end of the variable's value, delete the longest part that matches and return the rest
${variable/pattern/string}   # the longest match to pattern in variable is replaced by string. Only the first match is replaced
${variable//pattern/string}  # the longest match to pattern in variable is replaced by string. All matches are replaced

${#varname}                  # returns the length of the value of the variable as a character string

*(pattern list)               # matches zero or more occurences of the given patterns
+(pattern list)               # matches one or more occurences of the given patterns
?(pattern list)               # matches zero or one occurence of the given patterns
@(pattern list)               # matches exactly one of the given patterns
!(pattern list)               # matches anything except one of the given patterns

$(Linux command)              # command substitution: runs the command and returns standard output		
		
### White Sapce		
whitespace (spaces or tabs).



$ my_var=This is my environment variable!	
$ echo foo${my_var}bar							<= must use { }
fooThis is my environment variable!bar



### IF statement ###### IF statement ###### IF statement ###### IF statement ###
### IF statement ###### IF statement ###### IF statement ###### IF statement ###

$ test 100 -gt 99 && echo "Yes, that's true." || echo "No, that's false."
	Yes, that's true.
$ test 90 -gt 99 && echo "Yes, that's true." || echo "No, that's false."
	No, that's false.

	
#!/bin/bash
if [ $id -u = 0 ];then				# if (id -u) 0 = 0 are True
    echo "You are root" >&2			# 	
    exit 0
fi

---------------------------
#!/bin/bash
if [ $id -u = 0 ];then				# if (id -u) 0 = 0 are True
    echo "You are root" 			# 	
else
	echo "You are not root"
fi

	
### ! -z $HOME <= If home is NOT empty, echo $HOME
$ if [ ! -z $HOME ]; then echo $HOME; else echo "No Home"; fi
$ if [[ -n $HOME]]; then echo $HOME; else echo "No Home"; fi                     <= home is exist
/home/noza                                                                     <= Same answer
           
### -z $HOME    <= $HOME is empty which is False, echo "No Home"
$ if [ -z $HOME ]; then echo $HOME; else echo "no home"; fi
$ if [[ ! -n $HOME ]]; then echo $HOME; else echo "no home"; fi
no home  


$ if [[ ! -z $HOME ]]; then echo $HOME; elif [[ -z $HOME ]]; then echo "No Home"; fi
/home/noza



















### for_loop### for_loop### for_loop### for_loop### for_loop ###
### for_loop### for_loop### for_loop### for_loop### for_loop ###

#!/bin/bash

for i in $(ls)
do
    echo $i
done
------------------------------------

### for_loop1.sh		
#!/bin/bash
for i in *; do   # * is local directory
echo “$i”
done
$./for_loop1.sh 
=> local files list
------------------------------------
### for_loop2.sh
#!/bin/bash
for i in $#; do
echo “$i”			# zip archive "$i"
done
$./for_loop1.sh 1 2 3 4	
=> 4   <= total number of argument 1,2,3,4 is 4 total!
------------------------------------
### for_loop2.sh
#!/bin/bash
for i in $@; do
echo “$i”			# zip archive "$i"
done
$./for_loop1.sh 1 2 3 4	
=> 1 2 3 4

------------------------------------
$ for i in {1..100..2};do echo $i; done
$ for (( i=1; i<=10; i++));do echo $i; done
$ for (( i=1; i<=10; i++));do echo -n $i `sleep 1`" "; done

### Array ###### Array ###### Array ###### Array ###### Array ###### Array ###### Array ###
### Array ###### Array ###### Array ###### Array ###### Array ###### Array ###### Array ###

ARRAY_NAME[index_number]=value
The Index_Number is treated as an arithmetic expression that must evaluate to a + positive number.

### Associate Array only works on BASH 4 &< 
------------------------------------
#!/bin/bash
array_name=("apple" "banaba" "cherry")
for i in ${array_name[@]}             # @ or * <- both works 
do
    echo -n `sleep 1` $i " "
done

------------------------------------
#!/bin/bash
declare -a array_name
array_name["0"]="Albert"
array_name["1"]="1234"

for i in "${!array_name[@]}"  				### ! <-access keys in array  ""<- if space is in array
do
    echo "$i \= ${array_name[$i]}"
done

"declare -a" declares an array and all the elements in the parentheses are the elements of an array.
 
$declare -a array_name=('Debian' 'Red hat' 'Red hat' 'Suse' 'Fedora');
$echo ${array_name[@]}
  Debian Red hat Red hat Suse Fedora

------------------------------------
#!/bin/bash
# Declaring an Array and Assigning values
declare -a Linux

Linux[0]="Debian"
Linux[1]="Redhat"
Linux[2]="Ubuntu"
Linux[3]="Suse"

for i in "${!Linux[@]}"   # whole elements of the array
do
  echo "$i: ${Linux[$i]}"
done
==>> Output
0: Debian
1: Redhat
2: Ubuntu
3: Suse

###  Length of the Bash Array ###
get the length of an array using the special parameter called $#.
${#array_name[@]} gives you the length of the array.

e.g.
$ declare -a Linux=('Debian' 'Red hat' 'Suse' 'Fedora');
# Number of elements in the array
$ echo ${#Linux[@]} 
  4
# Number of "characters" in the first element of the array.i.e Debian
$ echo ${#Linux}  		<- same as 0
  6
$ declare -a Linux=('Debian' 'Red hat' 'Suse' 'Fedora');
$ echo ${#Linux[3]}
  7  <- counting SPACE, too

------------------------------------
$ declare -a num=(1 22 333 4444 55555 666666)
$ echo ${#num[2]}
	3
$ echo ${num[4]}
	4  
 ------------------------------------ 
$ declare -a name=(albert sujin sumin)
$ echo ${name}
	albert
$ echo ${name[1]}
	sujin
$ echo ${#name}
	6
$ echo ${name[@]}
	albert sujin sumin

	
  
  
### Replace ###
$ Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
$ echo ${Unix[@]/Debian/Linux}
Linux

### Add more elements into array
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
Unix=("${Unix[@]}" "AIX" "HP-UX")
echo ${Unix[7]}
->AIX

### Remove elements from array
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
unset Unix[3]
echo ${Unix[@]}











### * wild including current directory files
#!/bin/sh
for i in hello 1 * 2 goodbye 
do
  echo "Looping ... i is set to $i"
done


### Test statement ###### Test statement ###### Test statement ###### Test statement ###
### Test statement ###### Test statement ###### Test statement ###### Test statement ###


if test  == if [ ]
[ expression ] 
[[ expression ]]  		<= extended e.g. grep, egrep
if (( integer comparison )); then

###
if expression
then
	echo "True"
#elif
else
	echo "False"
fi
###
------------------------------------
#!/bin/bash
# Integer comparison
a=5
b=4
if [ $a -gt $b ]; then
	echo "$a is greater than $b."
else
    echo "$a is less than $b."
fi
------------------------------------	
#!/bin/bash
# String matches using REGEX   =~ [0-9]+
a="This is my 1st string!"
if [[ $a =~ [0-9]+ ]]; then
    echo "There are Numbers in the string: $a"
else
    echo "There are no numbers in the string: $a"
fi
------------------------------------
#!/bin/bash
# empty variable or not
if [ -z "$my_var" ]
then
    echo "my_var is an Empty variable!!"
fi







17. if [ $id -u != "0" ] ;then
	echo "You must be the supper user" >&2  						<= user id -u is 0
	exit 1															<= exit status sets to 1(failure)
    fi

	
19. Arithmetic
	echo $(( 1+2 ))
	+, -, *, /, %, **,

------------------------------------	
#!/bin/bash
number=0
echo -n "Enter a number >"
read number
echo "The number is $number"
if [ $(( number %2 )) -eq 0 ]; then
    echo "The number is even"
else
    echo "The number is odd"
fi

------------------------------------
20. Read : within min time to input
# -t timing
# -s security hidden

	#!/bin/bash
	echo -n  "Enter your number before expire within 3sec: "
	echo seq 3
	
	if read -t 3  -s response; then
	        echo "Great, you made it in time"
	else
        	echo "Sorry, you are too slow"
	fi
------------------------------------
### Time counting 

$ for i in {0..10}; do echo -ne "$i" '\r'; sleep 1; done; echo 

	#\r is returning to begin of line (without new line - \n)
	# -e escape, -n new line


### Directory or file name

#!/usr/bin/env bash
for myfile in /etc/r*
do
    if [ -d "$myfile" ]
    then
      echo "$myfile is a directory!"
    else
      echo "$myfile is a file name"
    fi
done



	
24. Test statement for Comparison operation [[ expression ]]     0:TRUE  1:FALSE 
	A. Comparing variables									        For Integer
		Less than			        [[ $a < $b ]]             = (( $a < $B )) 
		greater than			    [[ $a > $b ]]
		less than or equal to 		[[ $a <= $b ]]
		greater than or equal to 	[[ $a >= $b ]]
		equal(same)			        [[ $a == $b ]]
		not equal(same)		        [[ $a != $b ]]
	
	### String comparison
	ex) [[ "cat" == "cat" ]]
		a=cat
		b=dog
		[[ $a == $b ]]
		echo $?			<= 1:FALSE 0:TRUE

	B. Logical Operations
		AND     [[ $a && $b ]]
		OR   	[[ $a || $b ]] 
		NOT     [[ ! $a ]]

	C. Integer Number comparison operations
		less than			         [[ $a -lt $b ]]
		greater than			     [[ $a -gt $b ]]
		less than or equal to 		 [[ $a -le $b ]]
		greater than or equal to	 [[ $a -ge $b ]]
		equal				         [[ $a -eq $b ]]
		not equal			         [[ $a -ne $b ]]
		
	Eg)	[[ 20 -gt 100 ]]
		echo $?
	
	D. String null value
		is null(EMPTY)?			    [[ -z $a ]]   <= [[ !-z $a ]]
		is not null(EMPTY)?			[[ -n $a ]]   <= [[ !-n $a ]]

		
	Ex)	a=""
		b="cat"
		[[ -z $a && -n $b ]]
		echo $?

		if [ $? == 0 ]; then
			echo "TRUE"
		else
			echo "FALSE"
		fi



28. Array (can do from prompt)
	
	a=()
	b=("apple" "banana" "cherry" "$today" "$time")
	echo ${b[2]}
	b[5]="kiwi"
	b+=("mango")
	echo ${b[@]}            # @ <= whole array
	echo ${b[@]: -1}        # -1 <= last item in array
	
	
	
	
	
1. Comparisons: cmp vs diff
	cmp -  compare files byte by byte
	cmp -s $file1 $file2
    
    comm <= Compare two sorted files line by line   

    diff - compare files line by line
	diff $file1 $file2 > /dev/null

	sdiff  <= side by side comparison
	
	
32. if Condition statement

	a. if condition ; then	<= if condition is true, commands run
		commands
   	   fi			<= if condition is false, do nothing!

	b. if condition ; then  <= if condition is true, 1st commands run otherwise 
	   	commands   
	   else			<= if condition is false, 2nd commands run
		commands
	   fi

	c. if condition ; then   <= if condition is true, 1st commands run
	   	commands
	   elif conditions; then <= if condition is false, and if the 2nd command is true
	   	commands	 <= then 2nd set of commands run  	
	   if
	   
	#!/bin/bash
	if [ -f /etc/foo ]; then     # -f for file exit?
        	cp /etc/foo .
       		echo "copy done!"
	else
        	echo "This file does not exist"
        	exit (1 ??)
	fi
--------------------------------------------------

	if cmp -s "$file1" "$file2"
		then
	   echo "The files match"
	else
	   echo "The files are different"
	fi




# Exit code
	#!/bin/bash

	touch /root/test 2> /dev/null

	if [ $? -eq 0 ]
	then
  	  echo "Successfully created file"
	  exit 0
	else
	  echo "Could not create file" >&2
	  exit 1
	fi
	

	## With the exit command in this script, we will exit with a successful message 
	and 0 exit code if the touch command is successful. If the touch command fails 
	however, we will print a failure message to stderr and exit with a 1 value 
	which indicates failure. ##

	
	# Move or rename file from CMD
	$ if [ -e .vimrc ]; then mv .vimrc .vimrc_bak; fi

	
	
	
	
### While loop ###### While loop ###### While loop ###### While_loop ###### While_loop ###
### While loop ###### While loop ###### While loop ###### While_loop ###### While_loop ###

$while read i; do echo $i; done < while1.sh
#!/bin/bash
i=1
while read file; do
echo "Line $i: $file"
((i++))
done < echo.txt


#!/bin/bash
i=1
while read file; do
    echo "Line $1: $file"
    (i++))
done < file.txt

Line 1: apple
Line 2: banaba
.......

#!/bin/bash
# WHILE LOOP - i 가 10보다 적거나 같을때 까지
i=0
while [ $i -le 10 ]; do
    echo i is $i
#   ((i++))
    ((i+=1))
#   ((i=$i+1))
done

### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###
### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###### UNTIL LOOP ###

- J 가 10보다 크거나 같을때 가지.
j=0
until [ $j -ge 10 ]; do
    echo j is $j
    ((j++))
done



#!/bin/bash

INPUT_STRING=hello

while [ "$INPUT_STRING" != "bye" ]
do
  echo "Please type something or type 'bye' to quit!"
  read INPUT_STRING
  echo "You typed '$INPUT_STRING' to exit."
done







33. while and until statement                   <= while & until true statement
	i=0
	while [ $i -le 10 ]; do
        	echo i = $i
        	((i++))
	done			<= 0 ~ 10
-------------------------------------------------
    j=0
    until [$j -ge 10 ]; do
        echo j = $j
       ((j++))
    done			<= 0 ~ 9
--------------------------------------------------

	#!/bin/bash
	x=0			<= initializing to 0
	while [ $x -le 10 ] ; do 
        echo "Current value of X is $x."
        ((x++))
		# x=$(($x + 1 ))
		# x=$(expr $x + 1 )  <= ((x++)                   
        sleep 1
	done
	prints 0 ~ 10
--------------------------------------------------
	x=0;

	while [ $x -gt -10 ] ; do
        echo "X value is $x"
	    ((x--))
	done


#!/bin/sh
INPUT_STRING=hello
#INPUT_STRING=  		                <= works too
while [ "$INPUT_STRING" != "bye" ]
do
  echo "Please type something in (bye to quit)"
  read INPUT_STRING
  echo "You typed: $INPUT_STRING"
done
	
	
	
	
34. for loop
	x="nozatech"
	for i in /home/*; do
		echo $x is exist in home directory
	done
	

35. file
	i=1
	while read f; do
		echo "Line $i: $f"
		((i++))
	done < ffile.txt	


e.g.
	if [ -f .bashrc ]; then	
	    echo "you have the .bashrc."
	else
		echo "No .bashrc found!"
	fi	

	if [ $(id -u) = "0" ]; then
		echo "supersuser"
	fi


37. read -p "What year?[nnnn] " a
   while [[ ! $a =~ [0-9]{4} ]]; do
       read -p "A year, pelase! [nnnn] " a
   done
   echo "Selected year: $a"

	
	
	
	
	mkdir
	$ mkdir -p production/{modules,manifests}  <= creating multi folders
	
	mkdir and cd into directory
	$ mkdir ~/docker-registry && cd $_


38. && ( AND )   

#T&&R    true  && echo runs		<= if cmd1 runs then cmd2 runs also 

#F&&N    false && echo runs		<= if cmd2 fails then cmd2 No runs
	
e.g.	cd $directory && rm -rf *

# Both run in cmd line and bash script
	    *TRUE*	   *RUN!*
	[ ! -d ~/tmp ] && mkdir ~/tmp
	echo $? <= 0  Success

	    *FALSE*	   *NO RUN*
	[ ! -d ~/tmp ] && mkdir ~/tmp
	echo $? <= 1  fail  Did not created!


Coding
### FIZZBUZZ  ###	
	Prints out when there is a number divied by 3 == 0, then fizz
	Prints out when there is a number divied by 5 == 0, then buzz
	Prints out when there is a number divied by 3 == 0 && 5 == 0, then FizzBuzz

	
	#!/bin/bash  
	for i in {1..100}; do
        if (( i % 3 == 0 )) && (( i % 5 == 0)); then echo "fizzbuzz"
                elif (( i % 3 == 0 )); then echo "fizz"
                elif (( i % 5 == 0 )); then echo "buzz"
        else
                echo $i;
        fi
	done

	
	#!/bin/bash
	for i in {1..100}; do
		if (! ((i % 3)) ) && (! ((i % 5)) ); then echo "FizzBuzz"
			elif (! ((i % 3)) ); then echo "fizz"
			elif (! ((i % 5)) ); then echo "buzz"
		else
			echo $i;
		fi
	done

	### check modulo value from terminal ###
	# m=$(( 1 % 5 ))
	# echo $m
	# 1
	# m=$(( 55 % 5 ))
	# echo $m
	# 0

39. || ( OR )

#T||N    true  || echo runs		<= if cmd1 runs then cmd2 NO runs

#F||R    false || echo runs		<= if cmd1 fails then cmd2 RUNS!

   	     *TRUE*	   *NO RUN*
	[ -d ~/tmp ] || mkdir ~/tmp
	echo $? <= 1  False

	    *FALSE*	   *YES RUN*
	[ -d ~/tmp ] || mkdir ~/tmp
	echo $? <= 0  Created folder!





e.g.    cd $directory || error_exit "No such dir and aborting!"




39. Function

#!/bin/bash
function numberthings {		<= Declaring function name
    i=1			<= 
    for f in $@; do		<= $@ special array variable that represents all 
								of the arguments pass to a function
        echo $i: $f
        ((i+=1))			<= incrementing ((i++)) or ((i=i+1))
    done
}

numberthings $(ls)
numberthings pine birch maple spruce




40. Argument
	#!/bin/bash
	echo $1
	echo $2

    $./my.sh apple banana


	#!/bin/bash
	echo $1
	echo $2
    $./my.sh "apple Apple" "banana Banana"   <=use " " for when space in them

###
# Don't have to define the variables to saves a lot of time
###

	#!/bin/bash
	for i in $@			<= array arugment $@
	do
		echo $i
	done
	echo "There were $# arugments." <= $# contains number of argument

$./my.sh apple orange kiwi lemon



### CASE statement ###### CASE statement ###### CASE statement ###### CASE statement ###### CASE statement ###
### CASE statement ###### CASE statement ###### CASE statement ###### CASE statement ###### CASE statement ###

#!/bin/bash
a="dog"
case $a in
    cat)       echo "It is a cat_name";;
    dog|puppy) echo "It is a dog_name";;   				# | <- pipe to match dog or puppy
    *)         echo "No match!";;
esac


#!/bin/bash
while read i
do
  case $i in
        hello)  echo 1;;
        howdy)  echo 2;;
  esac
done < myfile.txt 
	myfile.txt
	hello
	howdy

	


### Function statement ###### Function statement ###### Function statement ###### Function statement ###
### Function statement ###### Function statement ###### Function statement ###### Function statement ###

#!/bin/bash
function greeting {
	echo "Hello There!"
}
echo "And now, a greeting!"
greeting
------------------------------------
#!/bin/bash
#A function to print "Hello World"
hello()
    {
      echo "Hello World"
    }
hello;
------------------------------------
#!/bin/bash
#function quit {
#    exit
#}
quit() {
	exit
}
function hello {
    echo Hello!
}
hello
quit
------------------------------------
#!/bin/bash
function quit { exit}
function input { echo $1 }    # $1 <-first argument pass to the function, but $@ <- works too.      
input hello
input world
quit  						  # exit
------------------------------------
#!/bin/bash
#numberthings (){
function numberthings {
        i=1
        for f in $@; do
                echo $i: $f
                ((i++))
        done
}

echo "First function"
numberthings $(ls)

echo "Second function"
numberthings pine birch maple spruce
------------------------------------

#!/bin/bash
#function to display commands
display() { echo "\$ $@" ; "$@" ; }
#display() { echo "\$ $@" 
			 echo "$@"  }
display echo hello world

------------------------------------
#!/bin/bash
function greet {
	echo "Hi, $1! What a nice $2!"
}
echo "And now, a greeting!"
greet Albert Morning
greet Everyone Evening






















	
######################################################################################################################################
# Bash Scripting
######################################################################################################################################
These are positional arguments of the script. 
position of arguments passed to the script on the command line, not line numbers
#!/bin/sh
echo "$1"
echo "$2"

./script.sh Hello World
$0 = script.sh             <- File name of the current script
$1 = Hello
$2 = World	
	
The $@ variable expands to all the parameters used when calling the function

function foo()
{
    echo "$@"
}
foo 1 2 3


It would display 1 2 3. If not used inside a function, it specifies all parameters 
used when calling the script. See the bash manual page for more info.	
	
The shell treats several parameters specially. These parameters may only be referenced; assignment to them is not allowed.

*
($*) Print all the parameter.
	 Expands to the positional parameters, starting from one. When the expansion is not within double quotes, 
     each positional parameter expands to a separate word. In contexts where it is performed, those words are 
	 subject to further word splitting and pathname expansion. When the expansion occurs within double quotes, 
	 it expands to a single word with the value of each parameter separated by the first character of the IFS 
	 special variable. That is, "$*" is equivalent to "$1c$2c…", where c is the first character of the value 
	 of the IFS variable. If IFS is unset, the parameters are separated by spaces. If IFS is null, the parameters 
	 are joined without intervening separators.

@
($@) Individually double quoted 
	Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, 
	each parameter expands to a separate word. That is, "$@" is equivalent to "$1" "$2" …. If the double-quoted 
	expansion occurs within a word, the expansion of the first parameter is joined with the beginning part of the 
	original word, and the expansion of the last parameter is joined with the last part of the original word. 
	When there are no positional parameters, "$@" and $@ expand to nothing (i.e., they are removed).

#
($#) Expands to the number of positional parameters in decimal(Counts number of parameters).	
 
($?) Exit status of the last command
	0 - successful
	1 - fail
	e.g. echo $?
($$) Process ID under which order getting executed

(?!) Process number of the last background command
 
 
 
#!/bin/bash
echo "Hello, World. Calls $# of parameters"	
echo "argument 0 is '$0'"
.....	
echo "argument 9 is '$9'"
echo "argument 10 is '{$10}'"	 # from 10, use {} 

./argument.sh a b ... y z
		Hello, World. Calls 24 of parameters
		argument 0 is './argument.sh'
		argument 1 is 'a'
		.....
		argument 10 is 'j'
	
	
79.Special parameters


  
###############
# FUNCTIONS   #
###############
The function refers to passed arguments by position (as if they were positional parameters), that is, $1, $2, and so forth. $@ is equal to "$1" "$2"... "$N", where N is the number of positional parameters. $# holds the number of positional parameters.
functname() {
  shell commands
}

unset -f functname  # deletes a function definition
declare -f          # displays all defined functions in your login session
2.3. FLOW CONTROL.

statement1 && statement2  # and operator
statement1 || statement2  # or operator

-a                        # and operator inside a test conditional expression
-o                        # or operator inside a test conditional expression

str1=str2                 # str1 matches str2
str1!=str2                # str1 does not match str2
str1<str2                 # str1 is less than str2
str1>str2                 # str1 is greater than str2
-n str1                   # str1 is not null (has length greater than 0)
-z str1                   # str1 is null (has length 0)

-a file                   # file exists
-d file                   # file exists and is a directory
-e file                   # file exists; same -a
-f file                   # file exists and is a regular file (i.e., not a directory or other special type of file)
-r file                   # you have read permission
-r file                   # file exists and is not empty
-w file                   # your have write permission
-x file                   # you have execute permission on file, or directory search permission if it is a directory
-N file                   # file was modified since it was last read
-O file                   # you own file
-G file                   # file's group ID matches yours (or one of yours, if you are in multiple groups)
file1 -nt file2           # file1 is newer than file2
file1 -ot file2           # file1 is older than file2

-lt                       # less than
-le                       # less than or equal
-eq                       # equal
-ge                       # greater than or equal
-gt                       # greater than
-ne                       # not equal

if condition
then
  statements
[elif condition
  then statements...]
[else
  statements]
fi

for x := 1 to 10 do
begin
  statements
end

for name [in list]
do
  statements that can use $name
done

for (( initialisation ; ending condition ; update ))
do
  statements...
done

case expression in
  pattern1 )
    statements ;;
  pattern2 )
    statements ;;
  ...
esac

select name [in list]
do
  statements that can use $name
done

while condition; do
  statements
done

until condition; do
  statements
done

##################################
# 4. INPUT/OUTPUT REDIRECTORS.   #
##################################
cmd1 | cmd2  # pipe; takes standard output of cmd1 as standard input to cmd2
> file       # directs standard output to file
< file       # takes standard input from file
>> file      # directs standard output to file; append to file if it already exists
>|file       #   forces standard output to file even if noclobber is set
n>|file      # forces output to file from file descriptor n even if noclobber is set
<> file      # uses file as both standard input and standard output
n<>file      # uses file as both input and output for file descriptor n
<<label      # here-document
n>file       # directs file descriptor n to file
n<file       # takes file descriptor n from file
n>>file      # directs file description n to file; append to file if it already exists
n>&          # duplicates standard output to file descriptor n
n<&          # duplicates standard input from file descriptor n
n>&m         # file descriptor n is made to be a copy of the output file descriptor
n<&m         # file descriptor n is made to be a copy of the input file descriptor
&>file       # directs standard output and standard error to file
<&-          # closes the standard input
>&-          # closes the standard output
n>&-         # closes the ouput from file descriptor n
n<&-         # closes the input from file descriptor n



##############################
### 5. Regular Expression  ###
##############################
Basic Regular Expression
Operator	Effect
.			Matches any single character.
?			The preceding item is optional and will be matched, at most, once.
*			The preceding item will be matched zero or more times.
+			The preceding item will be matched one or more times.
{N}			The preceding item is matched exactly N times.
{N,}		The preceding item is matched N or more times.
{N,M}		The preceding item is matched at least N times, but not more than M times.
-			represents the range if it's not first or last in a list or the ending point of a range in a list.
^			Start with(Matches the empty string at the beginning of a line; 
					  also represents the characters not in the range of a list.)
$			Matches the empty string at the end of a line.
\b			Matches the empty string at the edge of a word.
\B			Matches the empty string provided it's not at the edge of a word.
\<			Match the empty string at the beginning of word.
\>			Match the empty string at the end of word.

### Extended regular expressions
	In basic regular expressions the metacharacters "?", "+", "{", "|", "(", and ")" lose their special meaning; 
	instead use the backslashed versions "\?", "\+", "\{", "\|", "\(", and "\)".


e.g.
$ grep ^root /etc/passwd
	root:x:0:0:root:/root:/bin/bash

$







################################
# 7. DEBUGGING SHELL PROGRAMS. #
################################

bash -n scriptname  # don't run commands; check for syntax errors only
set -o noexec       # alternative (set option in script file)

bash -v scriptname  # echo commands before running them
set -o verbose      # alternative (set option in script file)

bash -x scriptname  # echo commands after command-line processing
set -o xtrace       # alternative (set option in script file)

trap 'echo $varname' EXIT  # useful when you want to print out the values of variables 
			     at the point that your script exits

function errtrap {
  es=$?
  echo "ERROR line $1: Command exited with status $es."
}

trap 'errtrap $LINENO' ERR  # is run whenever a command in the surrounding script or function exists with non-zero status 

function dbgtrap {
  echo "badvar is $badvar"
}

trap dbgtrap DEBUG  # causes the trap code to be executed before every statement in a function or script
# ...section of code in which the problem occurs...
trap - DEBUG  # turn off the DEBUG trap

function returntrap {
  echo "A return occured"
}

trap returntrap RETURN  # is executed each time a shell function or a script executed with the . or source commands finishes executing
















###################################################
########################################################################################################################################
### 			Questions 				###
#######################################################################################################################
###################################################

1: What is a shell?
	Shell is a interface between user and the kernel. Even though there can be  only one kernel ; 
	a system can have many shell running simultaneously . Whenever  a user enters a command  through 
	keyboard the shell communicates with the kernel  to execute it and then display the output to the user.

4:What is the difference between soft and hard links?
	Soft links are link to the file name and can reside on different filesytem as well; 
	however hard links are link to the inode of the file and has to be on the 
	same filesytem as that of the file. Deleting the orginal file makes the soft link inactive 
	(broken link) but does not affect the hard link (Hard link will still access a copy of the file)
	e.g. ln source dest_file
		 ln -s source dest_file

5: How will you pass and access arguments to a script in Linux?
	scriptName “Arg1” “Arg2”….”Argn” and can be accessed inside the script as $1 , $2 .. $n

6: What is the significance of $#?

	$# shows the total counts of the arguments passed to the script.
	e.g. $# out puts like wc -l 
	
	
7: What is the difference between $* and $@?
	$@ treats each quoted arguments as separate arguments  
	$* will consider the entire set of positional parameters as a single string.

8: Use sed command to replace the content of the file (emulate tac command)
if cat file1
ABCD
EFGH

Then O/p should be
EFGH
ABCD


sed '1! G; h;$!d' file1

Here G command appends to the pattern space,

h command copies pattern buffer to hold buffer

and d command deletes the current pattern  space.

9: Given a file,  replace all occurrence of word “ABC” with “DEF” from 5th line till end in only those lines that contains word “MNO”


sed –n ‘5,$p’ file1|sed ‘/MNO/s/ABC/DEF/’
 

10: Given a file , write a command sequence to find the count of each word.


tr –s  “(backslash)040” <file1|tr –s  “(backslash)011”|tr “(backslash)040 (backslash)011” “(backslash)012” |uniq –c

where “(backslash)040” is octal equivalent of “space”
1
2
3
tr –s  “(backslash)040” <file1|tr –s  “(backslash)011”|tr “(backslash)040 (backslash)011” “(backslash)012” |uniq –c
 
where “(backslash)040” is octal equivalent of “space”
 

”(backslash)011” is octal equivalent of “tab character” and

“(backslash)012” is octal equivalent of newline character.

11: How will you find the 99th line of a file using only tail and head command?

tail +99 file1|head -1


12: Print the 10th line without using tail and head command.
sed –n ‘10p’ file1


13:In my bash shell I want my prompt to be of format  ‘$”Present working directory”:”hostname”>  and load a file containing a list of user defined functions as soon as I login , how will you automate this?

	In bash shell we can create “.profile”  file which automatically gets invoked as soon as I login and write the following syntax into it.

	export PS1=’$ `pwd`:`hostname`>’ .File1

 
Here File1 is the file containing the user defined functions and “.” invokes this file in current shell.

14: Explain about “s” permission bit in a file?

“s” bit is called “set user id” (SUID) bit.

“s” bit on a file causes the process to have the privileges of the owner of the file during the instance of the program.

Eg: Executing “passwd” command to change current password causes the user to writes its new password to shadow file even though it has “root” as its owner.

15: I want to create a directory such that anyone in the group can create a file and access any person’s file in it but none should be able to delete a file other than the one created by himself.

We can create the directory giving read and execute access to everyone in the group and setting its sticky bit “t” on as follows:


mkdir direc1

chmod g+wx direc1

chmod +t direc1
1
2
3
4
5
mkdir direc1
 
chmod g+wx direc1
 
chmod +t direc1
 

16: How can you find out how long the system has been running?

Command “uptime”

17: How can any user find out all information about a specific user like his default shell, real life name, default directory,when and how long he has been using the sytem?

finger  “loginName”                  …where loginName is the  login name of  the

user whose  information is expected.

18: What is the difference between $$ and $!?

$$ gives the process id of the currently executing process whereas $! shows the process id of the process that recently went into background.

19: What are zombie processes?

These are the processes which have died but whose exit status is still not picked by the parent process. These processes even if not functional still have its process id entry in the process table.

20: How will you copy file from one machine to other?
	”scp” or “rsync” to copy file from one machine to other.


26: What are the 3 standard streams in Linux?
	0 – Standard Input
	1 – Standard Output
	2 – Standard Error

27: I want to read all input to the command from file1 direct all output to file2 and error to file3?
	command < file1   1 > file2    2 > file3

28: What will happen to my current process when I execute a command using exec?
	“exec” overlays the newly forked process on the current  process; so when I execute the command using exec, 
	the command gets executed on the current shell without creating any new processes. 
	### Then DISCONNECT SSH connection!!!

	Eg: Executing “exec  ls”  on command prompt will execute ls and once ls exits, the process will shut down

29: How will you emulate wc –l using awk?
	awk ‘END {print NR} fileName’


31: What is the difference between grep and egrep?
	Extended grep that supports added grep features like “+” (1 or more occurrence of previous character),
	”?”(0 or 1 occurrence of previous character) and “|” (alternate matching)

32: How will you print the login names of all users on a system?
	/etc/shadow file has all the users listed.
	awk –F ‘:’ ‘{print $1} /etc/shadow’|uniq -u

33: How to set an array in bash?
	array_name=(element1 element2 element3 …. elementn)

   

37:What is the significance of "$?" ?
	$? gives the exit status of the last command that was executed.

38: How do we delete all blank lines in a file?

	sed  ‘^ [\011\040]*$/d’ file1
 
		011 is octal equivalent of space
		040 is octal equivalent of tab

39: How will I insert a line “ABCDEF” at every 100th line of a file?
	sed ‘100i\ABCDEF’ file1

40: Write a command sequence to find all the files modified in less than 2 days and print the record count of each.
	find . –mtime -2 –exec wc –l {} \;

41: How can I set the default rwx permission to all users on  every file which is created in the current shell?
	umask 777

42: How can we find the process name from its process id?
	“ps –p ProcessId”

43: What are the four fundamental components of every file system on linux?
	bootblock, super block, inode block and  data block

44: What is a boot block?
	This block contains a small program called “Master Boot record”(MBR) which loads the kernel  during system boot up.

45: What is a super block?
	Super block contains all the information about the file system like size of file system, block size used by it,
	number of free data blocks and list of free inodes and data blocks.

46: What is an inode block?
	This block contains the inode for every file of the file system along with all the file attributes except its name.

49: What are “c” and “b” permission fields of a file?
“c “ and “b” permission fields are generally associated with a device file. It specifies whether a file is a character special file or a block special file.





Fibonacci Script
Write a script to print the first 10 elements of Fibonacci series.



$ a=1;b=1;for i in `seq 8`;do echo $((x=b,b=a+b,a=x));done

$ echo $((b=1,a=0));for i in `seq 8`;do echo $((x=b,b=a+b,a=x));done

#####################
#!/bin/bash -x
a=1
b=1
echo $a
echo $b
for i in 1 2 3 4 5 6 7 8
do

c=`expr $b + $a`
b=$a
a=$c

echo $c
done
### 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
















