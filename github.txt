How to use GIT

1. Create a new repository on the command line

	echo "# jenkins" >> README.md
	git init
	git add README.md
	git commit -m "first commit"
	git remote add origin https://github.com/nozatech/jenkins.git
	git push -u origin master


2. push an existing repository from the command line

	git remote add origin https://github.com/nozatech/jenkins.git
	git push -u origin master


3. GIT how-to between Client A and B

	### Client A: #### 
		a. git clone https://github.com/nozatech/daily_cmd.git     	<= first time
		b. git status
		c. edit files & save
		d. git status	
		e. git add . ('-A' all, or a new file_name)
		f. git commit -m "message"
		g. git push
		------------------------------------------------------
		h. git pull <= every morning gets updated codes
		i. edit files & save
		j. git status
		k. git add . ('-A' all, or file_name)
		j. git commit -m "more changes"
		l. git push
		 
			
	### Client B: ###
		a. git clone https://github.com/nozatech/daily_cmd.git  	<= first time
		b. git pull				<= any updates
		c. edit files & save
		d. git status
		e. git add . ( or -A or any new file_name )
		f. git commit -m " updated & add new file"
		g. git push


4. GIT BRANCHING
4. GIT BRANCHING
		a. $ git pull
		b. $ git branch
		* master
		c. $ git branch function01 				<= creating new 'function01' branch from Master
		d. $ git branch
			function01							<= complete copy of MASTER
			* master
		e. $ git checkout 'function01'
			Switched to branch 'function01'     <= SWITCHED TO FUNCTION01 ****
			<<... EDIT OR ADD NEW FILES ... >>	
		f. $ git status
			On branch function01
			Changes not staged for commit:
			(use "git add <file>..." to update what will be committed)
			(use "git checkout -- <file>..." to discard changes in working directory)
			modified:   linux_daily.txt
			no changes added to commit (use "git add" and/or "git commit -a")
		h. $ git add . ('-A' all, or a new file_name)
		i. $ git commit -m "added branches "
			[function01 def7db3] added branches
			1 file changed, 22 insertions(+), 15 deletions(-)
		-------------------------------------------------------------------
		j. $ git branch							<= checking which branch you are in 'function01'
			* function01
			master
		k. $ git checkout master				<= switch back to master if others has some updates one the same file while editing
			Switched to branch 'master'
			Your branch is up-to-date with 'origin/master'.
		l. $ git pull   <= check if MASTER has been modified by others
		-------------------------------------------------------------------
		m. 	$ git checkout function01
		n.	$ git merge master
			
		o.  $ git checkout master

		p.	$ git status
				On branch function01
				Your branch is up-to-date with 'origin/function01'.
				nothing to commit, working directory clean

				
				
		'git pull' does two operations; first it does a 'git fetch' to get up to date with the 'commits' 
		in the remote repo (which updates the origin/master ref in your local repo), then it does 
		a 'git merge' to merge those commits into the current branch.

		Until you do the fetch step (either on its own or via 'git pull') your local repo has no way 
		to know that there are additional 'commits upstream', and 'git status' only looks at your local 
		repo (in this case it looks at the origin/master ref, which is just a commit ID stored on 
		your local file system).

		When 'git status' says up to date, it means "up to date with the upstream status that was 
		retrieved last time we did a fetch" which is not the same as "up to date with the latest 
		live status of the upstream".	
		
		
		
		
		